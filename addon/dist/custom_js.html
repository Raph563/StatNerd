<script>
(() => {
  'use strict';

  const S = {
    active: 'all',
    applying: false,
    tabs: null,
    excludedFood: new Set(),
    groupOptionsByNorm: new Map(),
    dt: null,
    charts: {},
    timer: null,
    drawBound: false,
    drawTry: 0,
    foodFilterRegistered: false,
    chartLoadPromise: null,
    colMap: null,
    colSig: '',
    apiLoadPromise: null,
    apiLoaded: false,
    apiStockByProductId: new Map(),
    apiParentModeByProductId: new Map(),
    apiBrandByProductId: new Map(),
    apiProductGroupById: new Map(),
    apiQuantityUnitById: new Map(),
    apiQuantityUnitIdsByNorm: new Map(),
    apiQuantityConversionsByProductId: new Map(),
    apiQuantityConversionsGlobalByUnitId: new Map(),
    manualQtyFactorByProductId: new Map(),
    qtyLookupBusyByProductId: new Set(),
    qtyLookupPickerState: null,
    qtyLookupEventsBound: false,
    apiStockSource: '',
    apiStockRawRows: 0,
    apiQuantityConversionSource: '',
    apiQuantityConversionRows: 0,
    apiBrandMethod: '',
    apiBrandRequests: 0,
    apiBrandFailures: 0,
    apiBrandFieldNames: [],
    dashboardReady: false,
    dashboardOpen: false,
    dashboardView: 'stats',
    kpiFunOpen: false,
    rankingsCategory: 'all',
    rankingsDetailsExpanded: false,
    rankingsPodiumModes: {},
    rankingsCardsIndex: new Map(),
    rankingsFocusedCardId: '',
    chartPrefs: {},
    fullChart: null,
    fullChartId: '',
    fullChartContext: null,
    lastMetrics: null,
    lastAllRows: [],
    lastFilteredRows: [],
    dueSoonDays: 5,
    aiSettings: null,
    barcodeLookupSettings: null,
    barcodeAutofillUiSettings: null,
    photoSearchSettings: null,
    photoSearchProgress: null,
    aiFormState: null,
    aiCache: new Map(),
    aiCacheSignature: '',
    aiRequestSeq: 0,
    aiRequestInFlight: false,
    aiProviderRuntimeState: {},
    aiOverlayAutoCalls: 0,
    aiOverlayTotalCalls: 0,
    aiOverlayLastCallAt: 0,
    aiValidationInProgress: false,
    overlayFocus: null,
    overlayActiveIndex: -1,
    overlayDetailsExpanded: true,
    overlayActiveIndexByChart: {},
    overlayLimitModeByChart: {},
    overlayBucketUiByKey: {},
    overlayEquivalentUiByKey: {},
    funPanelRandomNonceByKey: {},
    uiStateSaveTimer: null,
    uiStateRestored: false,
    dataSignature: '',
    savedFullChartId: '',
    lastGroupQtyState: null,
    overlayVisualBase: null,
    rowMetaByProductId: new Map(),
    facetFilterRegistered: false,
    stockFacetType: '',
    stockFacetValue: '',
    stockFacetValueNorm: '',
    brandLogoLookupEnabled: false,
    brandLogoBannerDismissed: false,
    brandLogoKnownCount: 0,
    brandLogoSource: 'duckduckgo',
    brandLogoLogoDevToken: '',
    brandLogoOverrides: new Map(),
    brandLogoCleared: new Set(),
    brandLogoDefaultCache: new Map(),
    brandLogoDefaultCacheBuilt: false,
    brandLogoDefaultCacheSignature: '',
    groupLogoOverrides: new Map(),
    groupLogoCleared: new Set(),
    groupLogoDefaultCache: new Map(),
    groupLogoDefaultCacheBuilt: false,
    groupLogoDefaultCacheSignature: '',
    hoverPreviewKey: '',
    hoverPreviewContextKey: '',
    hoverPreviewRenderToken: 0,
    hoverPreviewPendingContexts: new Set(),
    hoverRecipeMapByProductId: new Map(),
    hoverRecipeMapLoaded: false,
    hoverRecipeMapPromise: null,
    hoverPriceRangeByProductId: new Map(),
    hoverPriceRangeLoaded: false,
    hoverPriceRangePromise: null,
    hoverPurchaseStatsByProductId: new Map(),
    hoverPurchaseStatsLoaded: false,
    hoverPurchaseStatsPromise: null,
    kpiLifetimeTotals: null,
    kpiLifetimeTotalsPromise: null,
    overlayHoverClearTimer: null,
    productImageSearchRefresh: null,
    productImageSearchBarcodeObserver: null,
    productImageSearchFocusHandler: null,
    productEnergyRobotRefresh: null,
    productEnergyRobotObserver: null,
    productBarcodesHeaderRefresh: null,
    barcodeAutofillObserver: null,
    productFormTypeRulesRefresh: null,
    productFormRuleSyncing: false,
    productUserfieldsSavePatched: false,
    productParentPersistLastKey: '',
    productParentPersistInFlight: false,
    productParentPersistTimer: null,
    productParentPersistPendingSnapshot: null,
    productStatusTerminalReady: false,
    productStatusTerminalExpanded: false,
    productStatusTerminalPinned: false,
    productStatusTerminalSettingsLoaded: false,
    productStatusTerminalUnseen: 0,
    productStatusEntrySeq: 0,
    productStatusEntries: [],
    addonCompatState: null,
    addonCompatApplying: false,
    addonCompatScan: null,
    addonCompatScanPromise: null,
    addonCompatMappingResolve: null,
    addonUpdateState: null,
    addonUpdateChecking: false,
    addonUpdateInstalling: false,
    addonUpdateReleaseChoices: [],
    addonUpdateLocalVersionPromise: null,
  };

  const CHART_IDS = [
    'g_val', 'g_qty', 'risk', 'due', 'brand_price', 'brand_rel', 'top_val', 'price_val', 'g_cal'
  ];

  const CHART_DEFAULT_LIMITS = {
    g_val: 10,
    g_qty: 10,
    risk: 4,
    due: 6,
    brand_price: 12,
    brand_rel: 20,
    top_val: 25,
    price_val: 30,
    g_cal: 12,
  };

  const FUN_PRICE_EQUIVALENTS_BASE = [
    { unitValue: 0.025, frSingular: 'sachet de sucre de café', frPlural: 'sachets de sucre de café', enSingular: 'coffee sugar packet', enPlural: 'coffee sugar packets' },
    { unitValue: 0.03, frSingular: 'trombone', frPlural: 'trombones', enSingular: 'paper clip', enPlural: 'paper clips' },
    { unitValue: 0.35, frSingular: 'banane', frPlural: 'bananes', enSingular: 'banana', enPlural: 'bananas' },
    { unitValue: 0.75, frSingular: 'pain au chocolat', frPlural: 'pains au chocolat', enSingular: 'chocolate pastry', enPlural: 'chocolate pastries' },
    { unitValue: 1.1, frSingular: 'baguette', frPlural: 'baguettes', enSingular: 'baguette', enPlural: 'baguettes' },
    { unitValue: 1.6, frSingular: 'expresso', frPlural: 'expressos', enSingular: 'espresso', enPlural: 'espressos' },
    { unitValue: 2.15, frSingular: 'trajet de métro', frPlural: 'trajets de métro', enSingular: 'subway ride', enPlural: 'subway rides' },
    { unitValue: 3.8, frSingular: 'pizza surgelée', frPlural: 'pizzas surgelées', enSingular: 'frozen pizza', enPlural: 'frozen pizzas' },
    { unitValue: 5.9, frSingular: 'menu fast-food', frPlural: 'menus fast-food', enSingular: 'fast-food menu', enPlural: 'fast-food menus' },
    { unitValue: 8.5, frSingular: 'cocktail sans alcool', frPlural: 'cocktails sans alcool', enSingular: 'mocktail', enPlural: 'mocktails' },
    { unitValue: 12, frSingular: 'place de cinéma', frPlural: 'places de cinéma', enSingular: 'movie ticket', enPlural: 'movie tickets' },
    { unitValue: 16.99, frSingular: 'abonnement streaming mensuel', frPlural: 'abonnements streaming mensuels', enSingular: 'monthly streaming subscription', enPlural: 'monthly streaming subscriptions' },
    { unitValue: 24.5, frSingular: 'brunch du week-end', frPlural: 'brunchs du week-end', enSingular: 'weekend brunch', enPlural: 'weekend brunches' },
    { unitValue: 89, frSingular: 'casque audio entrée de gamme', frPlural: 'casques audio entrée de gamme', enSingular: 'entry-level headset', enPlural: 'entry-level headsets' },
  ];

  const FUN_CAL_EQUIVALENTS_BASE = [
    { unitValue: 2, frSingular: 'expresso', frPlural: 'expressos', enSingular: 'espresso', enPlural: 'espressos' },
    { unitValue: 7, frSingular: 'minute de marche rapide', frPlural: 'minutes de marche rapide', enSingular: 'minute of brisk walking', enPlural: 'minutes of brisk walking' },
    { unitValue: 45, frSingular: 'carré de chocolat', frPlural: 'carrés de chocolat', enSingular: 'chocolate square', enPlural: 'chocolate squares' },
    { unitValue: 78, frSingular: 'œuf', frPlural: 'œufs', enSingular: 'egg', enPlural: 'eggs' },
    { unitValue: 95, frSingular: 'yaourt nature', frPlural: 'yaourts nature', enSingular: 'plain yogurt', enPlural: 'plain yogurts' },
    { unitValue: 105, frSingular: 'banane', frPlural: 'bananes', enSingular: 'banana', enPlural: 'bananas' },
    { unitValue: 140, frSingular: 'canette de soda', frPlural: 'canettes de soda', enSingular: 'soda can', enPlural: 'soda cans' },
    { unitValue: 180, frSingular: 'toast beurre-confiture', frPlural: 'toasts beurre-confiture', enSingular: 'butter-jam toast', enPlural: 'butter-jam toasts' },
    { unitValue: 230, frSingular: 'croissant', frPlural: 'croissants', enSingular: 'croissant', enPlural: 'croissants' },
    { unitValue: 285, frSingular: 'part de pizza', frPlural: 'parts de pizza', enSingular: 'slice of pizza', enPlural: 'slices of pizza' },
    { unitValue: 420, frSingular: 'portion de lasagnes', frPlural: 'portions de lasagnes', enSingular: 'serving of lasagna', enPlural: 'servings of lasagna' },
    { unitValue: 540, frSingular: 'burger', frPlural: 'burgers', enSingular: 'burger', enPlural: 'burgers' },
    { unitValue: 760, frSingular: 'grosse part de gâteau', frPlural: 'grosses parts de gâteau', enSingular: 'large cake slice', enPlural: 'large cake slices' },
  ];

  const FUN_EQ_VARIANTS = [
    { factor: 0.62, frTag: 'micro', enTag: 'micro' },
    { factor: 0.82, frTag: 'compact', enTag: 'compact' },
    { factor: 1.0, frTag: 'classique', enTag: 'classic' },
    { factor: 1.28, frTag: 'maxi', enTag: 'maxi' },
    { factor: 1.58, frTag: 'ultra', enTag: 'ultra' },
  ];

  const FUN_PRICE_EQUIVALENT_SEEDS = [
    { unitValue: 849.99, frLabel: 'LEGO Star Wars UCS Faucon Millenium 75192', enLabel: 'LEGO Star Wars UCS Millennium Falcon 75192' },
    { unitValue: 239.99, frLabel: 'LEGO Star Wars R2-D2 75379', enLabel: 'LEGO Star Wars R2-D2 75379' },
    { unitValue: 1499, frLabel: 'Apple iPhone 15 Pro Max 256 Go', enLabel: 'Apple iPhone 15 Pro Max 256 GB' },
    { unitValue: 579, frLabel: 'Sony PlayStation 5 Slim Digital', enLabel: 'Sony PlayStation 5 Slim Digital' },
    { unitValue: 349, frLabel: 'Nintendo Switch OLED', enLabel: 'Nintendo Switch OLED' },
    { unitValue: 1299, frLabel: 'Dyson V15 Detect Absolute', enLabel: 'Dyson V15 Detect Absolute' },
    { unitValue: 329, frLabel: 'Apple AirPods Max', enLabel: 'Apple AirPods Max' },
    { unitValue: 279, frLabel: 'Bose QuietComfort Ultra Headphones', enLabel: 'Bose QuietComfort Ultra Headphones' },
    { unitValue: 119, frLabel: 'LEGO Speed Champions McLaren F1', enLabel: 'LEGO Speed Champions McLaren F1' },
    { unitValue: 499, frLabel: 'GoPro HERO12 Black Creator Edition', enLabel: 'GoPro HERO12 Black Creator Edition' },
    { unitValue: 89.99, frLabel: 'Star Wars The Black Series casque Dark Vador', enLabel: 'Star Wars The Black Series Darth Vader helmet' },
    { unitValue: 299, frLabel: 'Samsung Galaxy Watch 6 Classic', enLabel: 'Samsung Galaxy Watch 6 Classic' },
    { unitValue: 2.1, frLabel: 'ticket de tram', enLabel: 'tram ticket' },
    { unitValue: 1.9, frLabel: 'café filtre', enLabel: 'filter coffee' },
    { unitValue: 0.65, frLabel: 'bouteille d’eau minérale', enLabel: 'mineral water bottle' },
    { unitValue: 3.4, frLabel: 'part de quiche', enLabel: 'slice of quiche' },
    { unitValue: 2.2, frLabel: 'donut maison', enLabel: 'homemade donut' },
    { unitValue: 0.55, frLabel: 'recharge de trottinette', enLabel: 'scooter recharge' },
    { unitValue: 1.8, frLabel: 'sachet de pop-corn', enLabel: 'popcorn bag' },
    { unitValue: 2.9, frLabel: 'carnet de notes', enLabel: 'pocket notebook' },
    { unitValue: 1.6, frLabel: 'paire de piles AA', enLabel: 'pair of AA batteries' },
    { unitValue: 0.3, frLabel: 'dose de lessive', enLabel: 'laundry dose' },
    { unitValue: 0.34, frLabel: 'capsule de café', enLabel: 'coffee pod' },
    { unitValue: 4.7, frLabel: 'trajet de covoiturage', enLabel: 'ride-share trip' },
    { unitValue: 1.3, frLabel: 'ticket de parking', enLabel: 'parking ticket' },
    { unitValue: 3.2, frLabel: 'heure de location de vélo', enLabel: 'bike rental hour' },
    { unitValue: 6.9, frLabel: 'bouquet de fleurs', enLabel: 'flower bouquet' },
    { unitValue: 0.95, frLabel: 'barre de céréales', enLabel: 'cereal bar' },
    { unitValue: 1.45, frLabel: 'paquet de mouchoirs', enLabel: 'tissue pack' },
    { unitValue: 0.07, frLabel: 'session de recharge smartphone', enLabel: 'phone charging session' },
    { unitValue: 16.0, frLabel: 'pass coworking à la journée', enLabel: 'coworking day pass' },
    { unitValue: 11.5, frLabel: 'entrée de musée', enLabel: 'museum entry' },
    { unitValue: 7.2, frLabel: 'livre de poche', enLabel: 'paperback book' },
    { unitValue: 4.2, frLabel: 'lot de stylos', enLabel: 'pen set' },
    { unitValue: 3.6, frLabel: 'pot de pesto', enLabel: 'pesto jar' },
    { unitValue: 12.9, frLabel: 'plat du jour', enLabel: 'daily special dish' },
    { unitValue: 14.8, frLabel: 'pizza en livraison', enLabel: 'delivered pizza' },
    { unitValue: 10.99, frLabel: 'abonnement musique mensuel', enLabel: 'monthly music subscription' },
    { unitValue: 4.6, frLabel: 'savon artisanal', enLabel: 'artisan soap bar' },
    { unitValue: 1.95, frLabel: 'ticket de bus', enLabel: 'bus ticket' },
    { unitValue: 0.18, frLabel: 'minute de blanchisserie', enLabel: 'laundromat minute' },
    { unitValue: 0.9, frLabel: 'recharge vélo électrique', enLabel: 'e-bike recharge' },
    { unitValue: 3.1, frLabel: 'mini plante aromatique', enLabel: 'mini herb plant' },
    { unitValue: 5.4, frLabel: 'smoothie frais', enLabel: 'fresh smoothie' },
  ];

  const FUN_CAL_EQUIVALENT_SEEDS = [
    { unitValue: 180, frLabel: 'verre de lait bleu de Tatooine Star Wars IV', enLabel: 'glass of Tatooine blue milk Star Wars IV' },
    { unitValue: 520, frLabel: 'plateau cantina Mos Eisley Star Wars IV', enLabel: 'Mos Eisley cantina platter Star Wars IV' },
    { unitValue: 640, frLabel: 'ragoût bantha style Tatooine Star Wars IV', enLabel: 'Tatooine-style bantha stew Star Wars IV' },
    { unitValue: 430, frLabel: 'assiette de ration rebelle Yavin IV', enLabel: 'Yavin IV rebel ration plate' },
    { unitValue: 360, frLabel: 'sandwich cantina Corellia', enLabel: 'Corellian cantina sandwich' },
    { unitValue: 710, frLabel: 'menu pilote X-Wing avant mission', enLabel: 'X-Wing pilot pre-mission meal' },
    { unitValue: 250, frLabel: 'dessert droides R2-D2 édition cantina', enLabel: 'R2-D2 cantina dessert' },
    { unitValue: 295, frLabel: 'bol de soupe de ferme de Lars', enLabel: 'Lars homestead soup bowl' },
    { unitValue: 560, frLabel: 'assiette spéciale Docking Bay 94', enLabel: 'Docking Bay 94 special plate' },
    { unitValue: 390, frLabel: 'collation du Faucon Millenium', enLabel: 'Millennium Falcon snack plate' },
    { unitValue: 6.2, frLabel: 'minute de marche rapide', enLabel: 'minute of brisk walking' },
    { unitValue: 10.5, frLabel: 'minute de montée d’escaliers', enLabel: 'minute of stair climbing' },
    { unitValue: 12.4, frLabel: 'minute de corde à sauter', enLabel: 'minute of jump rope' },
    { unitValue: 8.4, frLabel: 'minute de vélo urbain', enLabel: 'minute of city cycling' },
    { unitValue: 64, frLabel: 'cuillère de miel', enLabel: 'tablespoon of honey' },
    { unitValue: 94, frLabel: 'cuillère de beurre de cacahuète', enLabel: 'tablespoon of peanut butter' },
    { unitValue: 82, frLabel: 'tranche de pain complet', enLabel: 'wholegrain bread slice' },
    { unitValue: 52, frLabel: 'petite pomme', enLabel: 'small apple' },
    { unitValue: 174, frLabel: 'poignée d’amandes', enLabel: 'handful of almonds' },
    { unitValue: 89, frLabel: 'petite banane', enLabel: 'small banana' },
    { unitValue: 132, frLabel: 'pot de yaourt grec', enLabel: 'greek yogurt cup' },
    { unitValue: 206, frLabel: 'portion de riz cuit', enLabel: 'serving of cooked rice' },
    { unitValue: 118, frLabel: 'bol de soupe maison', enLabel: 'bowl of homemade soup' },
    { unitValue: 470, frLabel: 'bol de ramen', enLabel: 'bowl of ramen' },
    { unitValue: 156, frLabel: 'part de brownie', enLabel: 'brownie square' },
    { unitValue: 92, frLabel: 'cookie aux pépites', enLabel: 'chocolate-chip cookie' },
    { unitValue: 110, frLabel: 'mini muffin', enLabel: 'mini muffin' },
    { unitValue: 405, frLabel: 'wrap poulet', enLabel: 'chicken wrap' },
    { unitValue: 190, frLabel: 'taco street-food', enLabel: 'street taco' },
    { unitValue: 320, frLabel: 'part de gratin dauphinois', enLabel: 'serving of potato gratin' },
    { unitValue: 312, frLabel: 'portion de frites', enLabel: 'fries portion' },
    { unitValue: 152, frLabel: 'canette d’energy drink', enLabel: 'energy drink can' },
    { unitValue: 430, frLabel: 'part de cheesecake', enLabel: 'cheesecake slice' },
    { unitValue: 315, frLabel: 'part de quiche', enLabel: 'slice of quiche' },
    { unitValue: 360, frLabel: 'portion de chili con carne', enLabel: 'chili con carne serving' },
    { unitValue: 540, frLabel: 'portion de pâtes bolognaise', enLabel: 'pasta bolognese serving' },
    { unitValue: 290, frLabel: 'bol de salade César', enLabel: 'caesar salad bowl' },
    { unitValue: 210, frLabel: 'smoothie banane', enLabel: 'banana smoothie' },
    { unitValue: 410, frLabel: 'sandwich jambon-beurre', enLabel: 'ham-butter sandwich' },
    { unitValue: 425, frLabel: 'croque-monsieur', enLabel: 'croque monsieur' },
    { unitValue: 285, frLabel: 'portion de nuggets', enLabel: 'nuggets serving' },
    { unitValue: 205, frLabel: 'barre protéinée', enLabel: 'protein bar' },
  ];

  const FUN_DEFAULT_CATEGORY = { id: 'quotidien', fr: 'Quotidien', en: 'Everyday' };

  const FUN_REFERENCE_CATEGORIES = [
    {
      id: 'cinema',
      fr: 'Cinéma',
      en: 'Cinema',
      refs: [
        { fr: 'Star Wars épisode IV', en: 'Star Wars Episode IV' },
        { fr: 'Le Seigneur des Anneaux', en: 'The Lord of the Rings' },
        { fr: 'Matrix', en: 'The Matrix' },
        { fr: 'Jurassic Park', en: 'Jurassic Park' },
        { fr: 'Inception', en: 'Inception' },
        { fr: 'Interstellar', en: 'Interstellar' },
        { fr: 'Retour vers le futur', en: 'Back to the Future' },
        { fr: 'Indiana Jones', en: 'Indiana Jones' },
        { fr: 'Avatar', en: 'Avatar' },
        { fr: 'Top Gun Maverick', en: 'Top Gun Maverick' },
        { fr: 'Gladiator', en: 'Gladiator' },
        { fr: 'Titanic', en: 'Titanic' },
      ],
    },
    {
      id: 'series',
      fr: 'Séries',
      en: 'Series',
      refs: [
        { fr: 'Game of Thrones', en: 'Game of Thrones' },
        { fr: 'Breaking Bad', en: 'Breaking Bad' },
        { fr: 'Stranger Things', en: 'Stranger Things' },
        { fr: 'The Last of Us', en: 'The Last of Us' },
        { fr: 'The Mandalorian', en: 'The Mandalorian' },
        { fr: 'Sherlock', en: 'Sherlock' },
        { fr: 'Doctor Who', en: 'Doctor Who' },
        { fr: 'The Witcher', en: 'The Witcher' },
        { fr: 'Peaky Blinders', en: 'Peaky Blinders' },
        { fr: 'The Office', en: 'The Office' },
        { fr: 'Friends', en: 'Friends' },
        { fr: 'House of the Dragon', en: 'House of the Dragon' },
      ],
    },
    {
      id: 'musique',
      fr: 'Musique',
      en: 'Music',
      refs: [
        { fr: 'Thriller de Michael Jackson', en: 'Michael Jackson Thriller' },
        { fr: 'Abbey Road des Beatles', en: 'The Beatles Abbey Road' },
        { fr: 'Discovery de Daft Punk', en: 'Daft Punk Discovery' },
        { fr: 'Random Access Memories', en: 'Random Access Memories' },
        { fr: 'Nevermind de Nirvana', en: 'Nirvana Nevermind' },
        { fr: 'Back in Black d’AC/DC', en: 'AC/DC Back in Black' },
        { fr: '21 d’Adele', en: 'Adele 21' },
        { fr: 'Renaissance de Beyonce', en: 'Beyonce Renaissance' },
        { fr: 'The Wall de Pink Floyd', en: 'Pink Floyd The Wall' },
        { fr: 'After Hours de The Weeknd', en: 'The Weeknd After Hours' },
        { fr: 'Born to Run de Springsteen', en: 'Bruce Springsteen Born to Run' },
        { fr: 'Californication des Red Hot Chili Peppers', en: 'Red Hot Chili Peppers Californication' },
      ],
    },
    {
      id: 'jeux_video',
      fr: 'Jeux vidéo',
      en: 'Video games',
      refs: [
        { fr: 'The Legend of Zelda Breath of the Wild', en: 'The Legend of Zelda Breath of the Wild' },
        { fr: 'Mario Kart', en: 'Mario Kart' },
        { fr: 'Minecraft', en: 'Minecraft' },
        { fr: 'Grand Theft Auto V', en: 'Grand Theft Auto V' },
        { fr: 'Elden Ring', en: 'Elden Ring' },
        { fr: 'Fortnite', en: 'Fortnite' },
        { fr: 'League of Legends', en: 'League of Legends' },
        { fr: 'World of Warcraft', en: 'World of Warcraft' },
        { fr: 'Final Fantasy VII', en: 'Final Fantasy VII' },
        { fr: 'Cyberpunk 2077', en: 'Cyberpunk 2077' },
        { fr: 'Mass Effect', en: 'Mass Effect' },
        { fr: 'The Last of Us Part II', en: 'The Last of Us Part II' },
      ],
    },
    {
      id: 'histoire',
      fr: 'Histoire',
      en: 'History',
      refs: [
        { fr: 'Révolution française de 1789', en: 'French Revolution of 1789' },
        { fr: 'chute du mur de Berlin', en: 'fall of the Berlin Wall' },
        { fr: 'mission Apollo 11', en: 'Apollo 11 mission' },
        { fr: 'Renaissance florentine', en: 'Florentine Renaissance' },
        { fr: 'Empire romain', en: 'Roman Empire' },
        { fr: 'siècle des Lumières', en: 'Age of Enlightenment' },
        { fr: 'invention de l’imprimerie', en: 'invention of the printing press' },
        { fr: 'route de la soie', en: 'Silk Road' },
        { fr: 'expédition de Magellan', en: 'Magellan expedition' },
        { fr: 'construction de la Tour Eiffel', en: 'construction of the Eiffel Tower' },
        { fr: 'Traité de Versailles', en: 'Treaty of Versailles' },
        { fr: 'débarquement de Normandie', en: 'Normandy landings' },
      ],
    },
    {
      id: 'pop_culture',
      fr: 'Pop culture',
      en: 'Pop culture',
      refs: [
        { fr: 'Batman Year One', en: 'Batman Year One' },
        { fr: 'Spider-Man 1962', en: 'Spider-Man 1962' },
        { fr: 'X-Men', en: 'X-Men' },
        { fr: 'Avengers', en: 'Avengers' },
        { fr: 'Dragon Ball Z', en: 'Dragon Ball Z' },
        { fr: 'Naruto', en: 'Naruto' },
        { fr: 'One Piece', en: 'One Piece' },
        { fr: 'Attack on Titan', en: 'Attack on Titan' },
        { fr: 'Demon Slayer', en: 'Demon Slayer' },
        { fr: 'Tintin', en: 'Tintin' },
        { fr: 'Astérix', en: 'Asterix' },
        { fr: 'My Hero Academia', en: 'My Hero Academia' },
      ],
    },
    {
      id: 'science_fiction',
      fr: 'Science-fiction',
      en: 'Science fiction',
      refs: [
        { fr: 'Dune', en: 'Dune' },
        { fr: 'Star Trek', en: 'Star Trek' },
        { fr: 'Fondation', en: 'Foundation' },
        { fr: 'Blade Runner', en: 'Blade Runner' },
        { fr: '2001 Odyssée de l’espace', en: '2001 A Space Odyssey' },
        { fr: 'Warhammer 40K', en: 'Warhammer 40K' },
        { fr: 'Neuromancer', en: 'Neuromancer' },
        { fr: 'Ghost in the Shell', en: 'Ghost in the Shell' },
        { fr: 'Le Cinquième Élément', en: 'The Fifth Element' },
        { fr: 'Tron', en: 'Tron' },
        { fr: 'Alien', en: 'Alien' },
        { fr: 'Terminator', en: 'Terminator' },
      ],
    },
    {
      id: 'internet',
      fr: 'Internet & mèmes',
      en: 'Internet & memes',
      refs: [
        { fr: 'Doge', en: 'Doge' },
        { fr: 'Nyan Cat', en: 'Nyan Cat' },
        { fr: 'Rickroll', en: 'Rickroll' },
        { fr: 'Keyboard Cat', en: 'Keyboard Cat' },
        { fr: 'This is fine', en: 'This is fine' },
        { fr: 'Distracted Boyfriend', en: 'Distracted Boyfriend' },
        { fr: 'Harlem Shake', en: 'Harlem Shake' },
        { fr: 'Ice Bucket Challenge', en: 'Ice Bucket Challenge' },
        { fr: 'Among Us crewmate', en: 'Among Us crewmate' },
        { fr: 'Pikachu surpris', en: 'Surprised Pikachu' },
        { fr: 'Lo-fi study stream', en: 'Lo-fi study stream' },
        { fr: 'speedrun Any%', en: 'Any% speedrun' },
      ],
    },
  ];

  const FUN_PRICE_REFERENCE_TEMPLATES = [
    { frPrefix: 'objet collector', enPrefix: 'collector item', base: 48 },
    { frPrefix: 'pass fan expérience', enPrefix: 'fan experience pass', base: 28 },
  ];

  const FUN_CAL_REFERENCE_TEMPLATES = [
    { frPrefix: 'menu hommage', enPrefix: 'tribute meal', base: 560 },
    { frPrefix: 'snack marathon', enPrefix: 'marathon snack', base: 320 },
  ];

  const FUN_CATEGORY_DISPLAY_ORDER = [
    'cinema',
    'series',
    'musique',
    'jeux_video',
    'pop_culture',
    'science_fiction',
    'histoire',
    'internet',
    'quotidien',
  ];

  function funSeedHash(input = '') {
    const source = String(input || '');
    let hash = 0;
    for (let i = 0; i < source.length; i += 1) {
      hash = ((hash << 5) - hash) + source.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash);
  }

  function normalizeFunCategoryId(valueInput = '') {
    return String(valueInput || '')
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '') || FUN_DEFAULT_CATEGORY.id;
  }

  function funCategoryMetaById(categoryIdInput = '') {
    const id = normalizeFunCategoryId(categoryIdInput);
    const found = FUN_REFERENCE_CATEGORIES.find((cat) => normalizeFunCategoryId(cat.id) === id);
    if (found) {
      return {
        id,
        fr: String(found.fr || '').trim() || FUN_DEFAULT_CATEGORY.fr,
        en: String(found.en || '').trim() || FUN_DEFAULT_CATEGORY.en,
      };
    }
    if (id === normalizeFunCategoryId(FUN_DEFAULT_CATEGORY.id)) {
      return { ...FUN_DEFAULT_CATEGORY };
    }
    return {
      id,
      fr: FUN_DEFAULT_CATEGORY.fr,
      en: FUN_DEFAULT_CATEGORY.en,
    };
  }

  function generateFunEquivalentSeedsFromReferences(kindInput = 'price') {
    const kind = clean(kindInput || '') === 'calories' ? 'calories' : 'price';
    const templates = kind === 'calories' ? FUN_CAL_REFERENCE_TEMPLATES : FUN_PRICE_REFERENCE_TEMPLATES;
    const seeds = [];

    FUN_REFERENCE_CATEGORIES.forEach((category, categoryIndex) => {
      const categoryId = normalizeFunCategoryId(category && category.id ? category.id : '');
      const categoryFr = String(category && category.fr ? category.fr : '').trim() || FUN_DEFAULT_CATEGORY.fr;
      const categoryEn = String(category && category.en ? category.en : '').trim() || FUN_DEFAULT_CATEGORY.en;
      const refs = Array.isArray(category && category.refs) ? category.refs : [];
      refs.forEach((ref, refIndex) => {
        const refFr = String(ref && ref.fr ? ref.fr : '').trim();
        const refEn = String(ref && ref.en ? ref.en : '').trim();
        if (!refFr || !refEn) return;
        templates.forEach((tpl, templateIndex) => {
          const base = num(tpl && tpl.base);
          const frPrefix = String(tpl && tpl.frPrefix ? tpl.frPrefix : '').trim();
          const enPrefix = String(tpl && tpl.enPrefix ? tpl.enPrefix : '').trim();
          if (!(base > 0) || !frPrefix || !enPrefix) return;

          const hash = funSeedHash(`${kind}|${categoryId}|${refEn}|${templateIndex}|${refIndex}`);
          const jitter = 0.84 + ((hash % 39) / 100); // 0.84 .. 1.22
          const categoryBias = 0.92 + ((categoryIndex % 5) * 0.04);
          const unitRaw = base * jitter * categoryBias;
          const unitValue = kind === 'price'
            ? Number(unitRaw.toFixed(2))
            : Number(unitRaw.toFixed(1));
          if (!(unitValue > 0)) return;

          seeds.push({
            unitValue,
            frLabel: `${frPrefix} ${refFr}`,
            enLabel: `${enPrefix} ${refEn}`,
            categoryId,
            categoryFr,
            categoryEn,
          });
        });
      });
    });

    return seeds;
  }

  function withFunCategoryDefaults(catalogInput = [], fallbackMetaInput = FUN_DEFAULT_CATEGORY) {
    const catalog = Array.isArray(catalogInput) ? catalogInput : [];
    const fallbackMeta = fallbackMetaInput && typeof fallbackMetaInput === 'object'
      ? fallbackMetaInput
      : FUN_DEFAULT_CATEGORY;
    const fallbackId = normalizeFunCategoryId(fallbackMeta.id || FUN_DEFAULT_CATEGORY.id);
    const fallbackFr = String(fallbackMeta.fr || FUN_DEFAULT_CATEGORY.fr).trim() || FUN_DEFAULT_CATEGORY.fr;
    const fallbackEn = String(fallbackMeta.en || FUN_DEFAULT_CATEGORY.en).trim() || FUN_DEFAULT_CATEGORY.en;
    return catalog.map((entryInput) => {
      const entry = entryInput && typeof entryInput === 'object' ? entryInput : {};
      const id = normalizeFunCategoryId(entry.categoryId || fallbackId);
      const knownMeta = funCategoryMetaById(id);
      return {
        ...entry,
        categoryId: id,
        categoryFr: String(entry.categoryFr || knownMeta.fr || fallbackFr).trim() || fallbackFr,
        categoryEn: String(entry.categoryEn || knownMeta.en || fallbackEn).trim() || fallbackEn,
      };
    });
  }

  function buildExpandedFunEquivalentCatalog(baseCatalogInput, seedCatalogInput, variantCatalogInput = FUN_EQ_VARIANTS) {
    const baseCatalog = Array.isArray(baseCatalogInput) ? baseCatalogInput : [];
    const seeds = Array.isArray(seedCatalogInput) ? seedCatalogInput : [];
    const variants = Array.isArray(variantCatalogInput) ? variantCatalogInput : [];
    const generated = [];
    seeds.forEach((seed) => {
      const seedUnit = Number(seed && seed.unitValue);
      const frLabel = (seed && seed.frLabel ? String(seed.frLabel) : '').trim();
      const enLabel = (seed && seed.enLabel ? String(seed.enLabel) : '').trim();
      const categoryId = normalizeFunCategoryId(seed && seed.categoryId ? seed.categoryId : FUN_DEFAULT_CATEGORY.id);
      const categoryMeta = funCategoryMetaById(categoryId);
      const categoryFr = (seed && seed.categoryFr ? String(seed.categoryFr) : '').trim() || categoryMeta.fr;
      const categoryEn = (seed && seed.categoryEn ? String(seed.categoryEn) : '').trim() || categoryMeta.en;
      if (!(seedUnit > 0) || !frLabel || !enLabel) return;
      variants.forEach((variant) => {
        const factor = Number(variant && variant.factor);
        const frTag = (variant && variant.frTag ? String(variant.frTag) : '').trim();
        const enTag = (variant && variant.enTag ? String(variant.enTag) : '').trim();
        if (!(factor > 0) || !frTag || !enTag) return;
        const unitValue = Number((seedUnit * factor).toFixed(6));
        generated.push({
          unitValue,
          frSingular: `${frLabel} ${frTag}`,
          frPlural: `${frLabel} ${frTag}`,
          enSingular: `${enLabel} ${enTag}`,
          enPlural: `${enLabel} ${enTag}`,
          categoryId,
          categoryFr,
          categoryEn,
        });
      });
    });
    return withFunCategoryDefaults([...baseCatalog, ...generated], FUN_DEFAULT_CATEGORY);
  }

  const FUN_PRICE_GENERATED_SEEDS = [];
  const FUN_CAL_GENERATED_SEEDS = [];
  const FUN_PRICE_EQUIVALENTS = buildExpandedFunEquivalentCatalog(
    FUN_PRICE_EQUIVALENTS_BASE,
    [...FUN_PRICE_EQUIVALENT_SEEDS, ...FUN_PRICE_GENERATED_SEEDS]
  );
  const FUN_CAL_EQUIVALENTS = buildExpandedFunEquivalentCatalog(
    FUN_CAL_EQUIVALENTS_BASE,
    [...FUN_CAL_EQUIVALENT_SEEDS, ...FUN_CAL_GENERATED_SEEDS]
  );

  const FUN_QTY_EQUIVALENTS_MASS = [
    { unitValue: 0.03, frSingular: 'grain de riz', frPlural: 'grains de riz', enSingular: 'grain of rice', enPlural: 'grains of rice' },
    { unitValue: 0.4, frSingular: 'pincée de sel', frPlural: 'pincées de sel', enSingular: 'pinch of salt', enPlural: 'pinches of salt' },
    { unitValue: 4, frSingular: 'cuillère à café de sucre', frPlural: 'cuillères à café de sucre', enSingular: 'teaspoon of sugar', enPlural: 'teaspoons of sugar' },
    { unitValue: 8, frSingular: 'noisette de beurre', frPlural: 'noisettes de beurre', enSingular: 'small butter knob', enPlural: 'small butter knobs' },
    { unitValue: 20, frSingular: 'tranche de jambon', frPlural: 'tranches de jambon', enSingular: 'slice of ham', enPlural: 'slices of ham' },
    { unitValue: 25, frSingular: 'tranche de fromage', frPlural: 'tranches de fromage', enSingular: 'slice of cheese', enPlural: 'slices of cheese' },
    { unitValue: 60, frSingular: 'œuf moyen', frPlural: 'œufs moyens', enSingular: 'medium egg', enPlural: 'medium eggs' },
    { unitValue: 100, frSingular: 'tablette de chocolat', frPlural: 'tablettes de chocolat', enSingular: 'chocolate bar', enPlural: 'chocolate bars' },
    { unitValue: 120, frSingular: 'tomate moyenne', frPlural: 'tomates moyennes', enSingular: 'medium tomato', enPlural: 'medium tomatoes' },
    { unitValue: 125, frSingular: 'pot de yaourt', frPlural: 'pots de yaourt', enSingular: 'yogurt cup', enPlural: 'yogurt cups' },
    { unitValue: 140, frSingular: 'boîte de thon', frPlural: 'boîtes de thon', enSingular: 'tuna can', enPlural: 'tuna cans' },
    { unitValue: 150, frSingular: 'pomme moyenne', frPlural: 'pommes moyennes', enSingular: 'medium apple', enPlural: 'medium apples' },
    { unitValue: 180, frSingular: 'avocat moyen', frPlural: 'avocats moyens', enSingular: 'medium avocado', enPlural: 'medium avocados' },
    { unitValue: 200, frSingular: 'brique de crème', frPlural: 'briques de crème', enSingular: 'cream carton', enPlural: 'cream cartons' },
    { unitValue: 370, frSingular: 'pot de confiture', frPlural: 'pots de confiture', enSingular: 'jam jar', enPlural: 'jam jars' },
    { unitValue: 500, frSingular: 'paquet de pâtes', frPlural: 'paquets de pâtes', enSingular: 'pasta pack', enPlural: 'pasta packs' },
    { unitValue: 550, frSingular: 'pain de mie complet', frPlural: 'pains de mie complet', enSingular: 'wholegrain sandwich bread', enPlural: 'wholegrain sandwich breads' },
    { unitValue: 1000, frSingular: 'brique de lait', frPlural: 'briques de lait', enSingular: 'milk carton', enPlural: 'milk cartons' },
    { unitValue: 1200, frSingular: 'ananas moyen', frPlural: 'ananas moyens', enSingular: 'medium pineapple', enPlural: 'medium pineapples' },
    { unitValue: 2500, frSingular: 'sac de farine', frPlural: 'sacs de farine', enSingular: 'bag of flour', enPlural: 'bags of flour' },
  ];

  const FUN_QTY_EQUIVALENTS_VOLUME = [
    { unitValue: 5, frSingular: 'cuillère à café', frPlural: 'cuillères à café', enSingular: 'teaspoon', enPlural: 'teaspoons' },
    { unitValue: 10, frSingular: 'bouchon de bouteille', frPlural: 'bouchons de bouteille', enSingular: 'bottle cap', enPlural: 'bottle caps' },
    { unitValue: 15, frSingular: 'cuillère à soupe', frPlural: 'cuillères à soupe', enSingular: 'tablespoon', enPlural: 'tablespoons' },
    { unitValue: 30, frSingular: 'shot d’expresso', frPlural: 'shots d’expresso', enSingular: 'espresso shot', enPlural: 'espresso shots' },
    { unitValue: 100, frSingular: 'demi-verre', frPlural: 'demi-verres', enSingular: 'half glass', enPlural: 'half glasses' },
    { unitValue: 200, frSingular: 'verre', frPlural: 'verres', enSingular: 'glass', enPlural: 'glasses' },
    { unitValue: 250, frSingular: 'tasse', frPlural: 'tasses', enSingular: 'cup', enPlural: 'cups' },
    { unitValue: 330, frSingular: 'canette', frPlural: 'canettes', enSingular: 'can', enPlural: 'cans' },
    { unitValue: 350, frSingular: 'mug', frPlural: 'mugs', enSingular: 'mug', enPlural: 'mugs' },
    { unitValue: 450, frSingular: 'bol', frPlural: 'bols', enSingular: 'bowl', enPlural: 'bowls' },
    { unitValue: 500, frSingular: 'petite bouteille', frPlural: 'petites bouteilles', enSingular: 'small bottle', enPlural: 'small bottles' },
    { unitValue: 750, frSingular: 'gourde', frPlural: 'gourdes', enSingular: 'water flask', enPlural: 'water flasks' },
    { unitValue: 1000, frSingular: 'brique de lait', frPlural: 'briques de lait', enSingular: 'milk carton', enPlural: 'milk cartons' },
    { unitValue: 1500, frSingular: 'grande bouteille de soda', frPlural: 'grandes bouteilles de soda', enSingular: 'large soda bottle', enPlural: 'large soda bottles' },
    { unitValue: 2000, frSingular: 'carafe', frPlural: 'carafes', enSingular: 'carafe', enPlural: 'carafes' },
    { unitValue: 3000, frSingular: 'petit arrosoir', frPlural: 'petits arrosoirs', enSingular: 'small watering can', enPlural: 'small watering cans' },
    { unitValue: 5000, frSingular: 'demi-seau', frPlural: 'demi-seaux', enSingular: 'half bucket', enPlural: 'half buckets' },
    { unitValue: 10000, frSingular: 'seau', frPlural: 'seaux', enSingular: 'bucket', enPlural: 'buckets' },
    { unitValue: 25000, frSingular: 'jerrican', frPlural: 'jerricans', enSingular: 'jerrycan', enPlural: 'jerrycans' },
    { unitValue: 50000, frSingular: 'mini-cuve', frPlural: 'mini-cuves', enSingular: 'mini tank', enPlural: 'mini tanks' },
  ];

  const FUN_QTY_EQUIVALENTS_COUNT = [
    { unitValue: 1, frSingular: 'dose individuelle', frPlural: 'doses individuelles', enSingular: 'single dose', enPlural: 'single doses' },
    { unitValue: 1, frSingular: 'sachet', frPlural: 'sachets', enSingular: 'sachet', enPlural: 'sachets' },
    { unitValue: 1, frSingular: 'boîte', frPlural: 'boîtes', enSingular: 'box', enPlural: 'boxes' },
    { unitValue: 1, frSingular: 'paquet', frPlural: 'paquets', enSingular: 'pack', enPlural: 'packs' },
    { unitValue: 1, frSingular: 'plateau', frPlural: 'plateaux', enSingular: 'tray', enPlural: 'trays' },
    { unitValue: 1, frSingular: 'bocal', frPlural: 'bocaux', enSingular: 'jar', enPlural: 'jars' },
    { unitValue: 1, frSingular: 'barquette', frPlural: 'barquettes', enSingular: 'tray box', enPlural: 'tray boxes' },
    { unitValue: 1, frSingular: 'bouteille', frPlural: 'bouteilles', enSingular: 'bottle', enPlural: 'bottles' },
    { unitValue: 1, frSingular: 'canette', frPlural: 'canettes', enSingular: 'can', enPlural: 'cans' },
    { unitValue: 1, frSingular: 'flacon', frPlural: 'flacons', enSingular: 'vial', enPlural: 'vials' },
    { unitValue: 1, frSingular: 'tube', frPlural: 'tubes', enSingular: 'tube', enPlural: 'tubes' },
    { unitValue: 1, frSingular: 'rouleau', frPlural: 'rouleaux', enSingular: 'roll', enPlural: 'rolls' },
    { unitValue: 1, frSingular: 'capsule', frPlural: 'capsules', enSingular: 'capsule', enPlural: 'capsules' },
    { unitValue: 1, frSingular: 'pastille', frPlural: 'pastilles', enSingular: 'tablet', enPlural: 'tablets' },
    { unitValue: 1, frSingular: 'comprimé', frPlural: 'comprimés', enSingular: 'pill', enPlural: 'pills' },
    { unitValue: 1, frSingular: 'lingette', frPlural: 'lingettes', enSingular: 'wipe', enPlural: 'wipes' },
    { unitValue: 1, frSingular: 'gousse', frPlural: 'gousses', enSingular: 'clove', enPlural: 'cloves' },
    { unitValue: 1, frSingular: 'branche', frPlural: 'branches', enSingular: 'sprig', enPlural: 'sprigs' },
    { unitValue: 1, frSingular: 'portion', frPlural: 'portions', enSingular: 'portion', enPlural: 'portions' },
    { unitValue: 1, frSingular: 'unité produit', frPlural: 'unités produit', enSingular: 'product unit', enPlural: 'product units' },
  ];

  const QTY_MODE_IDS = ['auto', 'mass', 'volume'];

  const COLORS = ['#0d6efd','#198754','#fd7e14','#dc3545','#20c997','#0dcaf0','#ffc107','#6f42c1','#6c757d','#d63384'];
  const AI_STORAGE_KEY = 'grocy_dash_ai_settings_v1';
  const AI_CACHE_STORAGE_KEY = 'grocy_dash_ai_cache_v1';
  const BARCODE_LOOKUP_SETTINGS_KEY = 'grocy_dash_barcode_lookup_settings_v1';
  const BARCODE_AUTOFILL_UI_SETTINGS_KEY = 'grocy_dash_barcode_autofill_ui_settings_v1';
  const PHOTO_SEARCH_SETTINGS_KEY = 'grocy_dash_photo_search_settings_v1';
  const PHOTO_SEARCH_PROGRESS_KEY = 'grocy_dash_photo_search_progress_v1';
  const PRODUCT_STATUS_TERMINAL_SETTINGS_KEY = 'grocy_dash_product_status_terminal_v1';
  const PRODUCT_STATUS_TERMINAL_SESSION_KEY = 'grocy_dash_product_status_terminal_session_v1';
  const BRAND_LOGO_STORAGE_KEY = 'grocy_dash_brand_logos_v1';
  const QTY_CONVERSION_OVERRIDE_KEY = 'grocy_dash_qty_conversion_overrides_v1';
  const UI_STATE_STORAGE_KEY = 'grocy_dash_ui_state_v1';
  const ADDON_COMPATIBILITY_KEY = 'grocy_dash_addon_compatibility_v1';
  const ADDON_UPDATE_KEY = 'grocy_dash_addon_update_v1';
  const ADDON_RUNTIME_VERSION = '1.2.1';
  const ADDON_UPDATE_DEFAULT_REPOSITORY = 'Raph563/Grocy';
  const ADDON_UPDATE_DEFAULT_LOCAL_ROOT = 'C:\\Users\\Admin\\Documents\\Docker\\grocy';
  const ADDON_UPDATE_RELAY_BASE_URL = 'http://127.0.0.1:17863';
  const ADDON_UPDATE_PRERELEASE_VISIBLE_LIMIT = 5;
  const NO_DUE_SENTINEL_DATE = '2999-12-31';
  const STATNERD_AUTHOR_NAME = 'Raph563';
  const STATNERD_REPO_URL = 'https://github.com/Raph563/Grocy';
  const STATNERD_CHANGELOG_URL = `${STATNERD_REPO_URL}/blob/main/CHANGELOG.md`;
  const STATNERD_DOCS_URL = `${STATNERD_REPO_URL}/tree/main/docs`;
  const BARCODE_LOOKUP_PROVIDER_IDS = ['openfoodfacts', 'openproductsfacts'];
  const PHOTO_SEARCH_ENGINE_IDS = ['google', 'duckduckgo', 'bing'];
  const BRAND_LOGO_SOURCES = [
    { id: 'database' },
    { id: 'wikidata' },
    { id: 'simpleicons' },
    { id: 'duckduckgo' },
    { id: 'logodev' },
  ];
  const ADDON_COMPAT_REQUIRED_PRODUCT_GROUPS = [
    {
      name: 'Médicaments',
      descriptionFr: '',
      descriptionEn: '',
      active: 1,
    },
    {
      name: 'Entretien & maison',
      descriptionFr: '',
      descriptionEn: '',
      active: 1,
    },
    {
      name: 'Hygiène & soins personnels',
      descriptionFr: '',
      descriptionEn: '',
      active: 1,
    },
  ];

  const ADDON_COMPAT_REQUIRED_USERENTITIES = [
    {
      name: 'Medicaments',
      captionFr: 'Médicaments',
      captionEn: 'Medicines',
      descriptionFr: '',
      descriptionEn: '',
      showInSidebar: 1,
      iconCssClass: '',
    },
  ];

  const ADDON_COMPAT_REQUIRED_USERFIELDS = [
    {
      entity: 'products',
      name: 'Marque',
      captionFr: 'Marque',
      captionEn: 'Brand',
      type: 'preset-list',
      showAsColumn: 1,
      sortNumber: 1,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'Sous_marque',
      captionFr: 'Sous-marque',
      captionEn: 'Sub-brand',
      type: 'preset-list',
      showAsColumn: 0,
      sortNumber: 2,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'origine',
      captionFr: 'Origine',
      captionEn: 'Origin',
      type: 'preset-checklist',
      showAsColumn: 1,
      sortNumber: 3,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'SIQO',
      captionFr: 'Signes Officiels de l\'Origine et de la Qualité (SIQO)',
      captionEn: 'Official Origin and Quality signs (SIQO)',
      type: 'image',
      showAsColumn: 1,
      sortNumber: 4,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'parent',
      captionFr: 'parent',
      captionEn: 'parent',
      type: 'checkbox',
      showAsColumn: 1,
      sortNumber: 5,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'Dosage',
      captionFr: 'Dosage',
      captionEn: 'Dosage',
      type: 'text-single-line',
      showAsColumn: 1,
      sortNumber: 6,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'active_substance',
      captionFr: 'Substance active',
      captionEn: 'Active substance',
      type: 'text-single-line',
      showAsColumn: 1,
      sortNumber: 7,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'notice_link',
      captionFr: 'Lien notice',
      captionEn: 'Notice link',
      type: 'link-with-title',
      showAsColumn: 1,
      sortNumber: 8,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'Posologie',
      captionFr: 'Posologie',
      captionEn: 'Dosage instructions',
      type: 'text-multi-line',
      showAsColumn: 1,
      sortNumber: 9,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'Prescription',
      captionFr: 'Prescription',
      captionEn: 'Prescription',
      type: 'checkbox',
      showAsColumn: 1,
      sortNumber: 10,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'Renouvellement',
      captionFr: 'Renouvellement',
      captionEn: 'Renewal',
      type: 'date',
      showAsColumn: 1,
      sortNumber: 11,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'products',
      name: 'Notice_pdf',
      captionFr: 'Notice',
      captionEn: 'Notice',
      type: 'file',
      showAsColumn: 1,
      sortNumber: 12,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'userentity:Medicaments',
      name: 'Produit',
      captionFr: 'Produit',
      captionEn: 'Product',
      type: 'text-single-line',
      showAsColumn: 1,
      sortNumber: 1,
      inputRequired: 1,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'userentity:Medicaments',
      name: 'Quantite',
      captionFr: 'Quantité',
      captionEn: 'Quantity',
      type: 'number-decimal',
      showAsColumn: 1,
      sortNumber: 2,
      inputRequired: 1,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'userentity:Medicaments',
      name: 'Unite',
      captionFr: 'Unité',
      captionEn: 'Unit',
      type: 'preset-list',
      showAsColumn: 1,
      sortNumber: 3,
      inputRequired: 1,
      defaultValue: '',
      config: 'Comprimé(s)',
    },
    {
      entity: 'userentity:Medicaments',
      name: 'photo',
      captionFr: 'Photo',
      captionEn: 'Photo',
      type: 'image',
      showAsColumn: 1,
      sortNumber: 4,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'userentity:Medicaments',
      name: 'Molecule',
      captionFr: 'Molécule',
      captionEn: 'Molecule',
      type: 'text-single-line',
      showAsColumn: 1,
      sortNumber: 5,
      inputRequired: 1,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'userentity:Medicaments',
      name: 'Notice',
      captionFr: 'Notice',
      captionEn: 'Notice',
      type: 'file',
      showAsColumn: 1,
      sortNumber: 6,
      inputRequired: 0,
      defaultValue: '',
      config: '',
    },
    {
      entity: 'userentity:Medicaments',
      name: 'lien',
      captionFr: 'Lien',
      captionEn: 'Link',
      type: 'link-with-title',
      showAsColumn: 1,
      sortNumber: 7,
      inputRequired: 1,
      defaultValue: '',
      config: '',
    },
  ];

  const AI_PROVIDER_FIELDS = {
    apiKey: { label: 'Clé API', labelEn: 'API key', type: 'password', placeholder: 'sk-..., AIza..., etc.' },
    model: { label: 'Modèle', labelEn: 'Model', type: 'text', placeholder: 'gpt-4o-mini / gemini-2.0-flash / ...' },
    baseUrl: { label: 'URL de base', labelEn: 'Base URL', type: 'text', placeholder: 'https://.../v1' },
    organization: { label: 'Organisation (optionnel)', labelEn: 'Organization (optional)', type: 'text', placeholder: 'org_...' },
    project: { label: 'Projet (optionnel)', labelEn: 'Project (optional)', type: 'text', placeholder: 'proj_...' },
    siteUrl: { label: 'URL du site (optionnel)', labelEn: 'Site URL (optional)', type: 'text', placeholder: 'https://your-site.tld' },
    appName: { label: 'Nom de l’application (optionnel)', labelEn: 'App name (optional)', type: 'text', placeholder: 'Grocy Dashboard' },
    resource: { label: 'Ressource Azure', labelEn: 'Azure resource', type: 'text', placeholder: 'my-azure-resource' },
    deployment: { label: 'Déploiement', labelEn: 'Deployment', type: 'text', placeholder: 'gpt-4o-mini' },
    apiVersion: { label: 'Version API', labelEn: 'API version', type: 'text', placeholder: '2024-10-21' },
    keepAlive: { label: 'Keep alive (optionnel)', labelEn: 'Keep alive (optional)', type: 'text', placeholder: '5m' },
    extraHeaders: { label: 'En-têtes JSON (optionnel)', labelEn: 'JSON headers (optional)', type: 'textarea', placeholder: '{"X-Custom-Header":"value"}' },
  };

  const AI_PROVIDER_DEFS = [
    {
      id: 'gemini',
      label: 'Google Gemini',
      kind: 'gemini',
      fields: ['apiKey', 'model'],
      required: ['apiKey', 'model'],
      defaults: { apiKey: '', model: 'gemini-2.0-flash' },
      hint: 'Google AI Studio / Gemini API.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://ai.google.dev/gemini-api/docs/quickstart' },
        { labelKey: 'ai_provider_link_keys', url: 'https://aistudio.google.com/' },
      ],
    },
    {
      id: 'openai',
      label: 'OpenAI',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl', 'organization', 'project'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'gpt-4o-mini', baseUrl: 'https://api.openai.com/v1', organization: '', project: '' },
      hint: 'API officielle OpenAI.',
      hintEn: 'Official OpenAI API.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://platform.openai.com/docs/overview' },
        { labelKey: 'ai_provider_link_keys', url: 'https://platform.openai.com/' },
      ],
    },
    {
      id: 'azure_openai',
      label: 'Azure OpenAI',
      kind: 'azure_openai',
      fields: ['apiKey', 'resource', 'deployment', 'apiVersion', 'baseUrl'],
      required: ['apiKey', 'deployment', 'apiVersion'],
      defaults: { apiKey: '', resource: '', deployment: '', apiVersion: '2024-10-21', baseUrl: '' },
      hint: 'Utilise resource+deployment ou une URL de base Azure déjà complète.',
      hintEn: 'Use resource+deployment or an already complete Azure base URL.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://learn.microsoft.com/en-us/azure/ai-services/openai/quickstart' },
        { labelKey: 'ai_provider_link_console', url: 'https://portal.azure.com/' },
      ],
    },
    {
      id: 'anthropic',
      label: 'Anthropic Claude',
      kind: 'anthropic',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'claude-3-5-haiku-latest', baseUrl: 'https://api.anthropic.com/v1' },
      hint: 'API Anthropic Messages.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.anthropic.com/en/docs/get-started' },
        { labelKey: 'ai_provider_link_console', url: 'https://console.anthropic.com/docs' },
      ],
    },
    {
      id: 'cohere',
      label: 'Cohere',
      kind: 'cohere',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'command-r-plus', baseUrl: 'https://api.cohere.com/v2' },
      hint: 'API Cohere Chat.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.cohere.com/docs/build-things-with-cohere' },
        { labelKey: 'ai_provider_link_keys', url: 'https://dashboard.cohere.com/api-keys' },
      ],
    },
    {
      id: 'mistral',
      label: 'Mistral',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'mistral-small-latest', baseUrl: 'https://api.mistral.ai/v1' },
      hint: 'Endpoint OpenAI-compatible Mistral.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.mistral.ai/getting-started/quickstart/' },
        { labelKey: 'ai_provider_link_console', url: 'https://console.mistral.ai/' },
      ],
    },
    {
      id: 'groq',
      label: 'Groq',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'llama-3.3-70b-versatile', baseUrl: 'https://api.groq.com/openai/v1' },
      hint: 'Endpoint OpenAI-compatible Groq.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://console.groq.com/docs/responses-api' },
        { labelKey: 'ai_provider_link_keys', url: 'https://console.groq.com/keys' },
      ],
    },
    {
      id: 'together',
      label: 'Together AI',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'meta-llama/Llama-3.1-8B-Instruct-Turbo', baseUrl: 'https://api.together.xyz/v1' },
      hint: 'Endpoint OpenAI-compatible Together.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.together.ai/docs/quickstart' },
        { labelKey: 'ai_provider_link_console', url: 'https://api.together.ai/' },
      ],
    },
    {
      id: 'openrouter',
      label: 'OpenRouter',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl', 'siteUrl', 'appName'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'openai/gpt-4o-mini', baseUrl: 'https://openrouter.ai/api/v1', siteUrl: '', appName: 'Grocy Dashboard' },
      hint: 'Multi-model router OpenAI-compatible.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://openrouter.ai/docs/api-keys' },
      ],
    },
    {
      id: 'deepseek',
      label: 'DeepSeek',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'deepseek-chat', baseUrl: 'https://api.deepseek.com/v1' },
      hint: 'Endpoint OpenAI-compatible DeepSeek.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://api-docs.deepseek.com/' },
      ],
    },
    {
      id: 'xai',
      label: 'xAI (Grok)',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'grok-2-latest', baseUrl: 'https://api.x.ai/v1' },
      hint: 'Endpoint OpenAI-compatible xAI.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.x.ai/docs/guides/chat' },
        { labelKey: 'ai_provider_link_console', url: 'https://docs.x.ai/docs/management-api' },
      ],
    },
    {
      id: 'perplexity',
      label: 'Perplexity',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'sonar-pro', baseUrl: 'https://api.perplexity.ai' },
      hint: 'Endpoint OpenAI-compatible Perplexity.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.perplexity.ai/docs/agent-api/quickstart' },
        { labelKey: 'ai_provider_link_keys', url: 'https://docs.perplexity.ai/docs/getting-started' },
      ],
    },
    {
      id: 'fireworks',
      label: 'Fireworks AI',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'accounts/fireworks/models/llama-v3p1-8b-instruct', baseUrl: 'https://api.fireworks.ai/inference/v1' },
      hint: 'Endpoint OpenAI-compatible Fireworks.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.fireworks.ai/getting-started/quickstart' },
      ],
    },
    {
      id: 'huggingface',
      label: 'Hugging Face Router',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'meta-llama/Llama-3.1-8B-Instruct', baseUrl: 'https://router.huggingface.co/v1' },
      hint: 'Router OpenAI-compatible Hugging Face.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://huggingface.co/docs/api-inference' },
      ],
    },
    {
      id: 'cerebras',
      label: 'Cerebras',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'llama3.1-8b', baseUrl: 'https://api.cerebras.ai/v1' },
      hint: 'Endpoint OpenAI-compatible Cerebras.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://inference-docs.cerebras.ai/quickstart' },
      ],
    },
    {
      id: 'github_models',
      label: 'GitHub Models',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl'],
      required: ['apiKey', 'model', 'baseUrl'],
      defaults: { apiKey: '', model: 'gpt-4o-mini', baseUrl: 'https://models.inference.ai.azure.com' },
      hint: 'GitHub Models (token GitHub avec accès models).',
      hintEn: 'GitHub Models (GitHub token with models access).',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.github.com/en/rest/models/inference' },
        { labelKey: 'ai_provider_link_console', url: 'https://github.com/features/models' },
      ],
    },
    {
      id: 'ollama',
      label: 'Ollama (local)',
      kind: 'ollama',
      fields: ['apiKey', 'model', 'baseUrl', 'keepAlive'],
      required: ['model', 'baseUrl'],
      defaults: { apiKey: '', model: 'llama3.1:8b', baseUrl: 'http://localhost:11434', keepAlive: '5m' },
      hint: 'Modèle local via Ollama.',
      hintEn: 'Local model via Ollama.',
      links: [
        { labelKey: 'ai_provider_link_docs', url: 'https://docs.ollama.com/quickstart' },
        { labelKey: 'ai_provider_link_download', url: 'https://ollama.com/' },
      ],
    },
    {
      id: 'custom_openai',
      label: 'OpenAI-compatible (custom)',
      kind: 'openai_compat',
      fields: ['apiKey', 'model', 'baseUrl', 'extraHeaders'],
      required: ['model', 'baseUrl'],
      defaults: { apiKey: '', model: '', baseUrl: 'http://localhost:1234/v1', extraHeaders: '' },
      hint: 'LM Studio, vLLM, TGI, gateways custom, etc.',
      links: [
        { labelKey: 'ai_provider_link_selfhost', url: 'https://docs.vllm.ai/en/latest/serving/openai_compatible_server.html' },
        { labelKey: 'ai_provider_link_selfhost', url: 'https://lmstudio.ai/docs' },
      ],
    },
  ];

  const AI_PROVIDER_DEF_MAP = new Map(AI_PROVIDER_DEFS.map((def) => [def.id, def]));
  const AI_FOCUS_MODE_IDS = ['performance', 'eco', 'cheapest'];

  const AI_FOCUS_MODE_DEFS = {
    performance: {
      id: 'performance',
      label: 'Performance',
      autoOnClick: true,
      minIntervalMs: 450,
      maxAutoCallsPerOverlay: 120,
      maxTotalCallsPerOverlay: 180,
      autoMaxTokens: 260,
      manualMaxTokens: 340,
      promptStyle: 'full',
      temperatureCap: 0.45,
      timeoutMs: 15000,
      allowFallbackAuto: true,
      allowFallbackManual: true,
    },
    eco: {
      id: 'eco',
      label: 'Eco',
      autoOnClick: true,
      minIntervalMs: 1600,
      maxAutoCallsPerOverlay: 20,
      maxTotalCallsPerOverlay: 35,
      autoMaxTokens: 170,
      manualMaxTokens: 230,
      promptStyle: 'compact',
      temperatureCap: 0.3,
      timeoutMs: 12000,
      allowFallbackAuto: false,
      allowFallbackManual: true,
    },
    cheapest: {
      id: 'cheapest',
      label: 'Cheapest',
      autoOnClick: false,
      minIntervalMs: 7000,
      maxAutoCallsPerOverlay: 0,
      maxTotalCallsPerOverlay: 12,
      autoMaxTokens: 90,
      manualMaxTokens: 130,
      promptStyle: 'tiny',
      temperatureCap: 0.2,
      timeoutMs: 9000,
      allowFallbackAuto: false,
      allowFallbackManual: false,
    },
  };

  const UI_TEXT = {
    fr: {
      lang_name_fr: 'Français',
      lang_name_en: 'English',
      lang_mode_label: 'Langue de l’interface',
      due_date_format_label: 'Format date péremption',
      due_date_format_hint: 'Format utilisé pour afficher les dates de péremption dans les infos locales.',
      due_date_format_hint_sample: 'Exemple: {{sample}}',
      due_date_format_auto: 'Auto (langue UI)',
      due_date_format_ymd: 'YYYY-MM-DD',
      due_date_format_dmy: 'DD/MM/YYYY',
      due_date_format_mdy: 'MM/DD/YYYY',
      lang_mode_hint_auto: 'Détection automatique: {{lang}}',
      lang_mode_hint_fixed: 'Langue forcée: {{lang}}',
      tab_food: 'Nourriture',
      tab_meds_default: 'Médicaments',
      tab_hyg_default: 'Hygiène & soins',
      tab_home_default: 'Entretien & maison',
      dash_title: 'Statistiques & graphiques',
      dash_view_stats: 'Statistiques',
      dash_view_rankings: 'Classements',
      dash_refresh: 'Rafraîchir',
      dash_show: 'Afficher',
      dash_hide: 'Masquer',
      dash_context_default: 'Analyse en temps réel de la vue actuelle.',
      kpi_products: 'Produits',
      kpi_total_value: 'Valeur totale',
      kpi_avg_price: 'Prix moyen',
      kpi_calories: 'Calories',
      kpi_alerts: 'Alertes',
      kpi_brands: 'Marques',
      kpi_fun_value_stock_title: 'Comparaisons valeur stock',
      kpi_fun_value_lifetime_title: 'Comparaisons valeur achats cumulés',
      kpi_fun_cal_stock_title: 'Comparaisons calories stock',
      kpi_fun_cal_lifetime_title: 'Comparaisons calories achats cumulés',
      kpi_fun_loading: 'Chargement des historiques...',
      kpi_fun_no_data: 'Historique insuffisant pour comparaison.',
      kpi_fun_history_error: 'Historique achats indisponible.',
      kpi_fun_rounded_badge: 'arrondi',
      kpi_fun_toggle_show: 'Afficher les comparaisons fun',
      kpi_fun_toggle_hide: 'Masquer les comparaisons fun',
      kpi_fun_randomize_all: 'Randomiser',
      overlay_fun_title: 'Comparaisons fun',
      overlay_fun_scope_current: 'Vue actuelle',
      overlay_fun_scope_lifetime: 'Historique total',
      overlay_fun_no_data: 'Aucune comparaison fun disponible.',
      kpi_fun_thumb_hover_hint: 'Survol pour agrandir',
      kpi_fun_thumb_fallback_name: 'Produit',
      quick_read_title: 'Lecture rapide',
      chart_group_value_title: 'Valeur par groupe',
      chart_group_value_sub: 'Poids financier des groupes dans le stock.',
      chart_group_qty_title: 'Quantité par groupe',
      chart_group_qty_sub: 'Volumes disponibles par groupe.',
      chart_risk_title: 'État des alertes',
      chart_risk_sub: 'Sous-stock, proche date, retard et expiré.',
      chart_due_title: 'Échéances',
      chart_due_sub: 'Projection temporelle des prochaines dates.',
      chart_brand_price_title: 'Prix moyen par marque',
      chart_brand_price_sub: 'Comparaison des marques sur le prix unitaire.',
      chart_brand_rel_title: 'Relation prix-marque',
      chart_brand_rel_sub: 'X=prix moyen, Y=valeur stock, taille=nb produits.',
      chart_top_value_title: 'Top produits par valeur',
      chart_top_value_sub: 'Produits qui immobilisent le plus de valeur.',
      chart_price_vs_value_title: 'Prix produit vs valeur',
      chart_price_vs_value_sub: 'Détection des produits chers et lourds en stock.',
      chart_group_cal_title: 'Calories par groupe',
      chart_group_cal_sub: 'Lecture nutritionnelle agrégée par groupe.',
      global_conclusions_title: 'Conclusions globales combinées',
      rankings_title: 'Classements',
      rankings_context: 'Classements de la vue actuelle.',
      rank_top_value_title: 'Top produits par valeur',
      rank_top_value_sub: 'Produits qui immobilisent le plus de budget',
      rank_top_qty_title: 'Top produits par quantité',
      rank_top_qty_sub: 'Volumes disponibles les plus élevés',
      rank_top_price_title: 'Top produits par prix unitaire',
      rank_top_price_sub: 'Produits les plus chers à l’unité',
      rank_top_cal_title: 'Top produits par calories',
      rank_top_cal_sub: 'Impact nutritionnel individuel',
      rank_top_value_per_unit_title: 'Top valeur/unité',
      rank_top_value_per_unit_sub: 'Poids financier par unité stockée',
      rank_due_nearest_title: 'Échéances les plus proches',
      rank_due_nearest_sub: 'Produits à consommer en priorité',
      rank_due_over_title: 'Produits dépassés',
      rank_due_over_sub: 'Retards à traiter en priorité',
      rank_group_value_title: 'Groupes par valeur',
      rank_group_value_sub: 'Concentration budget par groupe',
      rank_group_qty_title: 'Groupes par quantité',
      rank_group_qty_sub: 'Concentration volume par groupe',
      rank_brand_value_title: 'Marques par valeur',
      rank_brand_value_sub: 'Poids financier des marques',
      rank_brand_avg_price_title: 'Marques par prix moyen',
      rank_brand_avg_price_sub: 'Niveau de prix marque',
      rank_brand_coverage_title: 'Marques par couverture',
      rank_brand_coverage_sub: 'Nombre de produits par marque',
      rankings_category_all: 'Tout',
      rankings_category_products: 'Produits',
      rankings_category_brands: 'Marques',
      rankings_category_groups: 'Catégories',
      rankings_category_ops: 'Pilotage',
      rankings_podium_title: 'Podiums',
      rankings_podium_sub: 'Vue rapide des principaux classements (premiers/derniers).',
      rankings_mode_top: 'Premiers',
      rankings_mode_bottom: 'Derniers',
      rankings_see_more: 'Voir plus',
      rankings_full_title: 'Classements détaillés',
      rankings_full_sub: 'Vue complète de chaque critère (repliée par défaut).',
      rankings_full_expand: 'Développer',
      rankings_full_collapse: 'Réduire',
      rankings_mode_badge_top: 'Mode: premiers',
      rankings_mode_badge_bottom: 'Mode: derniers',
      rankings_mode_toggle_title: 'Cliquer pour alterner premiers/derniers',
      rankings_none: 'Aucun classement disponible pour cette vue.',
      overlay_chart_title: 'Graphique',
      status_below_min: 'Sous stock mini',
      status_due_soon: 'Proche date',
      status_overdue: 'En retard',
      status_expired: 'Expiré',
      due_over: 'Dépassé',
      due_0_3: '0-3 jours',
      due_4_7: '4-7 jours',
      due_8_30: '8-30 jours',
      due_30_plus: '>30 jours',
      due_none: 'Sans date',
      no_data: 'Aucune donnée',
      overlay_close: 'Fermer',
      overlay_full_suffix: 'vue complète',
      overlay_legend_title: 'Légende détaillée',
      overlay_explain_title: 'Comment lire ce graphique',
      overlay_takeaways_title: 'Conclusions à tirer',
      overlay_details_title: 'Données détaillées',
      overlay_details_expand: 'Développer',
      overlay_details_collapse: 'Réduire',
      overlay_focus_title: 'Spot IA sur l’élément cliqué',
      overlay_focus_local_title: 'Infos locales',
      overlay_focus_ai_title: 'Infos IA',
      overlay_open_product: 'Ouvrir fiche produit',
      overlay_open_brand_products: 'Voir les produits de cette marque',
      overlay_open_group_products: 'Voir les produits de cette catégorie',
      overlay_stock_links_title: 'Accès stock ciblé',
      overlay_retry_ai: 'Relancer IA',
      overlay_focus_hint: 'Clique un élément du graphique pour afficher un focus détaillé.',
      overlay_ai_waiting: 'Agent IA en attente.',
      overlay_focus_ai_unvalidated: 'Agent non validé',
      overlay_focus_ai_error: 'Erreur IA',
      overlay_focus_ai_missing: 'Configuration IA manquante',
      overlay_focus_ai_disabled: 'IA désactivée',
      overlay_focus_ai_settings_btn: 'Paramètres IA',
      overlay_focus_bucket_see_more: 'Voir plus',
      overlay_focus_bucket_show_more: 'Afficher plus',
      ai_settings_title: 'Paramètres généraux de StatNerd',
      ai_settings_close: 'Fermer',
      ai_enable_focus: 'Activer l’agent IA sur le focus plein écran',
      ai_provider_active: 'Fournisseur actif',
      ai_cost_mode: 'Mode coût IA',
      ai_mode_perf: 'Performance (auto détaillée)',
      ai_mode_eco: 'Éco (auto limitée)',
      ai_mode_cheapest: 'Cheapest (manuel, ultra-économe)',
      ai_mode_label_perf: 'Performance',
      ai_mode_label_eco: 'Éco',
      ai_mode_label_cheapest: 'Cheapest',
      ai_temperature: 'Température',
      ai_timeout: 'Timeout (ms)',
      ai_fallback_enable: 'Activer fallback auto',
      ai_fallback_order: 'Ordre fallback (sélection multiple)',
      ai_provider_configs: 'Configurations par fournisseur',
      ai_local_key_hint: 'La clé est stockée localement dans ton navigateur (localStorage).',
      ai_test_btn: 'Tester la connexion',
      ai_save_btn: 'Enregistrer',
      settings_save_btn: 'Sauvegarder',
      settings_save_all_btn: 'Sauvegarder tout',
      settings_section_interface: 'Interface & IA',
      settings_section_runtime: 'Comportement IA',
      settings_section_providers: 'Fournisseurs IA (manuel)',
      settings_section_brand_logos: 'Logos marques',
      settings_section_group_logos: 'Logos groupes',
      settings_section_addon_compat: 'Compatibilité',
      settings_section_saved: 'Section "{{section}}" sauvegardée.',
      settings_tabs_general: 'Général',
      settings_tabs_product_data: 'Données produit',
      settings_tabs_visuals: 'Logos',
      settings_tabs_compat: 'Compatibilité',
      settings_tabs_providers: 'Fournisseurs IA',
      settings_tabs_update: 'Mises à jour',
      settings_group_general: 'Réglages généraux',
      settings_group_product_data: 'Services produit',
      settings_group_visuals: 'Identité visuelle',
      settings_group_compat: 'Compatibilité StatNerd',
      settings_group_providers: 'Fournisseurs IA',
      settings_group_update: 'Mises à jour & infos',
      settings_group_reduce: '(réduire)',
      settings_group_expand: '(ouvrir)',
      addon_compat_desc: 'Ajoute les groupes produits, entités utilisateur et attributs utilisés par l’addon.',
      addon_compat_scope_note: 'Portée: product_groups + userentities + userfields. Détection automatique de l’existant.',
      addon_compat_run_btn: 'Appliquer la compatibilité',
      addon_compat_map_btn: 'Associer les éléments similaires',
      addon_compat_reoffer_btn: 'Réafficher la proposition au prochain chargement',
      addon_compat_banner_text: 'Compatibilité addon: détecte l’existant, propose les associations, puis crée uniquement ce qui manque.',
      addon_compat_banner_apply: 'Appliquer',
      addon_compat_banner_map: 'Associer',
      addon_compat_banner_later: 'Plus tard',
      addon_compat_banner_missing_detail: 'Éléments manquants: {{missing}} | associations proposées: {{mapping}}.',
      addon_compat_status_idle: 'En attente d’exécution.',
      addon_compat_status_running: 'Application de la compatibilité en cours...',
      addon_compat_status_done: 'Compatibilité appliquée: {{created}} créé(s), {{existing}} déjà présent(s), {{mapped}} associé(s), {{failed}} échec(s).',
      addon_compat_status_ready: 'Compatibilité déjà satisfaisante: aucun ajout nécessaire.',
      addon_compat_status_mapping_none: 'Aucune association pertinente détectée.',
      addon_compat_status_mapping_cancelled: 'Association annulée.',
      addon_compat_status_fail: 'Échec compatibilité: {{msg}}',
      addon_compat_status_prompt_reset: 'La proposition sera réaffichée au prochain chargement.',
      addon_compat_mapping_title: 'Associations de compatibilité',
      addon_compat_mapping_intro: 'Des éléments proches ont été détectés ({{count}}). Choisis ceux à réutiliser ou laisse \"Créer\".',
      addon_compat_mapping_close: 'Fermer',
      addon_compat_mapping_skip: 'Ignorer',
      addon_compat_mapping_apply: 'Valider',
      addon_compat_mapping_create: 'Créer "{{name}}"',
      addon_compat_mapping_similarity: '{{score}} % similaire',
      settings_section_addon_update: 'Mise à jour StatNerd',
      addon_update_desc: 'Vérifie les releases GitHub, permet de choisir une version, puis prépare la commande de mise à jour locale.',
      addon_update_repo_label: 'Dépôt GitHub (owner/repo)',
      addon_update_repo_hint: 'Ex: Raph563/Grocy.',
      addon_update_local_root_label: 'Dossier racine Grocy local',
      addon_update_local_root_hint: 'Ex: C:\\Users\\Admin\\Documents\\Docker\\grocy (contient addon/ et config/).',
      addon_update_local_root_browse_btn: 'Parcourir',
      addon_update_local_root_pick_fail: 'Sélection impossible depuis ce navigateur. Renseigne le dossier manuellement.',
      addon_update_check_stable_btn: 'Vérifier stable',
      addon_update_check_prerelease_btn: 'Vérifier alpha/bêta',
      addon_update_run_bridge_btn: 'Mettre à jour automatiquement',
      addon_update_bridge_test_btn: 'Tester l’app desktop',
      addon_update_bridge_hint: 'Nécessite l’app desktop StatNerd Relay lancée (Windows/macOS).',
      addon_update_bridge_status_ready: 'App desktop détectée.',
      addon_update_bridge_status_missing: 'App desktop introuvable. Lance StatNerd Relay.',
      addon_update_bridge_status_running: 'Mise à jour en cours via app desktop...',
      addon_update_bridge_status_success: 'Mise à jour terminée via app desktop.',
      addon_update_bridge_status_error: 'Mise à jour desktop en échec: {{msg}}',
      addon_update_open_release_btn: 'Ouvrir la release',
      addon_update_open_release_tag: 'Release {{tag}}',
      addon_update_copy_btn: 'Copier',
      addon_update_cmd_ps_label: 'Commande Windows PowerShell',
      addon_update_cmd_sh_label: 'Commande Linux/macOS',
      addon_update_cmd_hint: 'One-liner PowerShell: Set-Location vers addon/scripts puis update-from-github avec le dossier config. Sélectionne une version pour injecter automatiquement le tag.',
      addon_update_release_list_label: 'Choisir une version à installer',
      addon_update_release_list_empty: 'Aucune version chargée. Lance une vérification.',
      addon_update_release_badge_prerelease: 'alpha/bêta',
      addon_update_release_selected: 'Version sélectionnée: {{tag}}',
      addon_update_changelog_label: 'Changelog de la version sélectionnée',
      addon_update_changelog_empty: 'Aucun changelog disponible pour cette version.',
      statnerd_about_title: 'Infos StatNerd',
      statnerd_about_author: 'Auteur: {{author}}',
      statnerd_about_version: 'Version locale installée: {{version}}',
      statnerd_about_release_link: 'Releases GitHub',
      statnerd_about_changelog_link: 'Changelog global',
      statnerd_about_docs_link: 'Documentation',
      statnerd_about_selected_changelog: 'Changelog de la version sélectionnée',
      addon_update_versions_line: 'Version locale: {{local}} | Version sélectionnée: {{remote}} (tag {{tag}}).',
      addon_update_last_checked: 'Dernière vérification: {{date}}.',
      addon_update_not_checked: 'Aucune vérification encore.',
      addon_update_version_unknown: 'inconnue',
      addon_update_repo_invalid: 'Format dépôt invalide (attendu: owner/repo).',
      addon_update_status_idle: 'Lance une vérification stable ou alpha/bêta pour charger les versions.',
      addon_update_status_checking: 'Vérification GitHub en cours...',
      addon_update_status_up_to_date: 'StatNerd est à jour: version {{version}}.',
      addon_update_status_update_available: 'Mise à jour disponible: local {{local}} -> {{latest}} ({{tag}}).',
      addon_update_status_local_ahead: 'Version locale plus récente que la release choisie: local {{local}} / release {{latest}}.',
      addon_update_status_release_missing: 'Aucune release trouvée sur GitHub.',
      addon_update_status_release_missing_asset: 'Release {{tag}} détectée mais aucun asset ZIP exploitable.',
      addon_update_status_error: 'Échec vérification mise à jour: {{msg}}',
      addon_update_copy_ok: 'Commande copiée.',
      addon_update_copy_fail: 'Copie impossible: sélectionne la commande manuellement.',
      ai_validation_mode_label: 'Mode de validation au clic sur Enregistrer',
      ai_validation_mode_single: 'Agent unique',
      ai_validation_mode_fallback: 'Chaîne fallback',
      ai_validation_mode_single_tip: 'Agent unique: teste et utilise uniquement le fournisseur actif.',
      ai_validation_mode_fallback_tip: 'Chaîne fallback: essaie l’agent actif puis les suivants selon l’ordre.',
      ai_validation_mode_hint_single: 'Teste uniquement l’agent actif.',
      ai_validation_mode_hint_fallback: 'Teste l’agent actif puis fallback, et s’arrête au premier valide.',
      ai_save_running: 'Validation des agents en cours...',
      ai_save_validation_fail: 'Enregistrement bloqué: {{msg}}',
      ai_save_validation_ok: 'Validation réussie sur {{provider}}.',
      error_short: 'Erreur',
      ai_provider_links_title: 'Ressources',
      ai_provider_link_docs: 'Docs',
      ai_provider_link_keys: 'Clés API',
      ai_provider_link_console: 'Console',
      ai_provider_link_download: 'Télécharger',
      ai_provider_link_selfhost: 'Self-hosted',
      ai_field_required: 'Champ requis.',
      ai_provider_rejected_short: 'Refusé',
      ai_provider_valid_short: 'Valide',
      ai_provider_rejected_reason: 'Raison: {{msg}}',
      ai_api_key_error_low_credit: 'Crédit insuffisant / quota dépassé.',
      ai_api_key_error_access_denied: 'Accès refusé / clé invalide.',
      configured_short: 'Configuré',
      not_configured_short: 'Non configuré',
      error_short: 'Erreur',
      provider_links_title: 'Liens utiles',
      provider_link_docs: 'Documentation',
      provider_link_keys: 'Clés API',
      provider_link_download: 'Téléchargement',
      provider_link_selfhosted: 'Self-hosted',
      ai_settings_btn_title_configured: 'Paramètres de StatNerd (IA: {{provider}} configuré)',
      ai_settings_btn_title_not_configured: 'Paramètres de StatNerd (IA: {{provider}} non configuré)',
      ai_mode_goal_perf: 'la réactivité',
      ai_mode_goal_eco: 'l’équilibre coût/perf',
      ai_mode_goal_cheapest: 'le coût minimal',
      ai_mode_changed: 'Mode {{mode}}: optimisé pour {{goal}}.',
      ai_saved: 'Paramètres enregistrés ({{provider}}{{model}} | mode {{mode}}).',
      ai_test_disabled: 'IA désactivée: active-la pour tester.',
      ai_test_incomplete: 'Configuration incomplète pour {{provider}}.',
      ai_test_running: 'Test {{provider}} en cours...',
      ai_test_ok: 'Connexion réussie ({{provider}}{{model}}): {{msg}}',
      ai_test_fail: 'Échec test {{provider}}: {{msg}}',
      focus_ai_disabled: 'Agent IA désactivé. Active-le via l’icône paramètres.',
      focus_ai_config_missing: 'Configuration {{provider}} incomplète. Configure-la via l’icône paramètres.',
      focus_ai_auto_disabled: 'Mode {{mode}}: analyse auto désactivée. Clique "Relancer IA" pour lancer 1 analyse ciblée.',
      focus_ai_busy: 'Mode {{mode}}: analyse déjà en cours, attends 1-2 s.',
      focus_ai_auto_limit: 'Mode {{mode}}: limite auto atteinte ({{count}} appels). Utilise "Relancer IA" si nécessaire.',
      focus_ai_total_limit: 'Budget IA de la vue atteint ({{count}} appels). Ferme/réouvre le plein écran pour réinitialiser.',
      focus_ai_throttle: 'Mode {{mode}}: anti-spam actif, attends {{wait}} s.',
      focus_ai_running: 'Agent IA ({{provider}} | mode {{mode}}): analyse en cours...',
      focus_ai_unavailable: 'Agent IA indisponible: {{message}}.',
      focus_ai_restore_missing: 'Donnée IA non mise en cache. Clique "Relancer IA" pour la recharger.',
      focus_resp_empty: 'Réponse IA vide.',
      source_ai_prefix: 'Source IA',
      meta_element: 'Élément',
      meta_type: 'Type',
      meta_chart: 'Graphique',
      meta_group: 'Groupe',
      meta_brand: 'Marque',
      meta_value: 'Valeur',
      meta_quantity: 'Quantité',
      meta_price: 'Prix',
      meta_avg_price: 'Prix moyen',
      meta_calories: 'Calories',
      focus_anchor_qty: 'Repère pratique',
      focus_anchor_cal: 'Repère énergie',
      focus_anchor_random: 'Random',
      focus_anchor_random_title: 'Changer de repère',
      meta_due: 'Échéance',
      meta_alerts: 'Alertes',
      default_all: 'Tous',
      default_no_group: 'Sans groupe',
      default_no_brand: 'Sans marque',
      default_category: 'Catégorie',
      default_product: 'Produit',
      default_brand: 'Marque',
      default_item: 'Élément',
      default_none: 'aucune',
      default_na: 'N/A',
      unit_units: 'unités',
      unit_products: 'produits',
      unit_brands: 'marques',
      unit_alerts: 'alertes',
      unit_days_short: 'j',
      others_label: 'Autres',
      no_info_available: 'Aucune information disponible.',
      metric_value_prefix: 'valeur',
      metric_price_prefix: 'prix',
      metric_avg_price_prefix: 'prix moyen',
      metric_quantity_prefix: 'quantité',
      metric_group_prefix: 'groupe',
      chart_dataset_brands: 'Marques',
      chart_dataset_products: 'Produits',
      chart_axis_avg_unit_price: 'Prix unitaire moyen',
      chart_axis_stock_value: 'Valeur en stock',
      chart_axis_unit_price: 'Prix unitaire',
      chart_label_value: 'Valeur',
      chart_label_quantity: 'Quantité',
      chart_label_products: 'Produits',
      chart_label_avg_price: 'Prix moyen',
      ctl_sort_desc_title: 'Trier du plus grand au plus petit',
      ctl_sort_desc: 'Desc',
      ctl_sort_asc_title: 'Trier du plus petit au plus grand',
      ctl_sort_asc: 'Asc',
      ctl_limit_all: 'Tout',
      ctl_limit_all_title: 'Afficher toutes les valeurs',
      ctl_limit_top: 'Top',
      ctl_limit_top_title: 'Afficher seulement les {{limit}} premières valeurs',
      ctl_include_zero: '0+',
      ctl_include_zero_title: 'Inclure les valeurs nulles',
      ctl_qty_auto: 'Auto',
      ctl_qty_auto_title: 'Auto selon les unités dominantes de la vue',
      ctl_qty_mass: 'Masse',
      ctl_qty_mass_title: 'Forcer les quantités en masse (kg/g)',
      ctl_qty_volume: 'Volume',
      ctl_qty_volume_title: 'Forcer les quantités en volume (L/ml)',
      ctl_qty_count: 'Pièces',
      ctl_qty_count_title: 'Forcer les quantités en unités (pièces)',
      ctl_type_bar: 'Barres',
      ctl_type_bar_title: 'Afficher en barres',
      ctl_type_donut: 'Camembert',
      ctl_type_donut_title: 'Afficher en camembert',
      ctl_type_scatter: 'Nuage',
      ctl_type_scatter_title: 'Afficher en nuage de points',
      ctl_type_bubble: 'Bulles',
      ctl_type_bubble_title: 'Afficher en bulles',
      qty_mode_auto_label: 'Auto',
      qty_mode_mass_label: 'Masse',
      qty_mode_volume_label: 'Volume',
      qty_mode_count_label: 'Pièces',
      chart_qty_unit_badge: 'Unité active: {{unit}} (mode {{mode}})',
      chart_qty_total_badge: 'Total: {{total}}',
      chart_qty_total_badge_empty: 'Total: N/A',
      chart_qty_total_badge_title: 'Somme des quantités classables (mode {{mode}}).',
      chart_qty_unclassified_title: 'Produits non classables pour cette unité',
      chart_qty_unclassified_none: 'Aucun produit non classable pour ce mode.',
      chart_qty_unclassified_more: '+{{count}} autres',
      chart_qty_unclassified_fix_link: 'Trouver une conversion',
      chart_qty_unclassified_fix_link_title: 'Chercher une conversion via OFF/OPF',
      qty_lookup_terminal_source: 'Conversions quantité',
      qty_lookup_step_start: 'Conversion: analyse de {{product}}.',
      qty_lookup_step_barcode_try: 'Recherche code-barres OFF/OPF...',
      qty_lookup_step_barcode_found: 'Code-barres trouvé: {{barcode}}.',
      qty_lookup_step_barcode_missing: 'Code-barres introuvable, recherche approfondie par nom...',
      qty_lookup_step_provider_try: 'Analyse {{provider}}...',
      qty_lookup_step_provider_error: '{{provider}}: {{error}}',
      qty_lookup_none: 'Aucune conversion exploitable trouvée pour {{product}}.',
      qty_lookup_found: '{{count}} conversion(s) trouvée(s) pour {{product}}.',
      qty_lookup_picker_title: 'Conversions proposées',
      qty_lookup_picker_subtitle: '{{product}} - choisis une conversion à appliquer.',
      qty_lookup_picker_apply: 'Appliquer',
      qty_lookup_picker_close: 'Fermer',
      qty_lookup_picker_hint: '1 {{stockUnit}} = {{converted}} (mode {{mode}}) | {{provider}}',
      qty_lookup_picker_basis: 'Base: {{basis}}',
      qty_lookup_picker_via_barcode: 'via code-barres',
      qty_lookup_picker_via_name: 'via nom',
      qty_lookup_applied: 'Conversion appliquée: 1 {{stockUnit}} = {{converted}} pour {{product}}.',
      qty_lookup_refreshed: 'Graphique quantité rafraîchi.',
      ctl_expand_title: 'Ouvrir en grand',
      overlay_controls_label: 'Contrôles du graphique',
      brand_rel_none: 'Aucune marque avec prix moyen et valeur exploitables.',
      brand_rel_more_suffix: '... ({{count}} autres éléments, clic sur agrandir)',
      charts_unavailable: 'Graphiques indisponibles pour le moment (chargement de Chart.js en cours ou bloqué).',
      hover_preview_due_label: 'Échéance',
      hover_preview_price_label: 'Prix',
      hover_preview_recipes_label: 'Recettes',
      hover_preview_recipes_none: 'Aucune recette liée.',
      hover_preview_recipes_more: '+{{count}} autres recettes',
      hover_preview_top_products_label: 'Top 5 produits les plus achetés',
      hover_preview_low_label: 'Prix bas',
      hover_preview_high_label: 'Prix haut',
      hover_preview_currency_symbol: '€',
      hover_preview_loading: 'Chargement des détails...',
      hover_preview_more: '+{{count}} autres produits',
      hover_preview_empty: 'Aucun produit correspondant.',
      due_no_date_text: 'sans date',
      due_over_by: 'dépassé de {{days}}',
      due_over_by_span: 'dépassé de {{span}}',
      due_today: 'aujourd’hui',
      due_in: 'dans {{days}}',
      due_in_span: 'dans {{span}}',
      ranking_context_line: '{{products}}/{{total}} analysés | {{cards}} classements.',
      rank_value_text: 'valeur {{value}}',
      rank_quantity_text: 'quantité {{value}}',
      rank_qty_scope_text: 'Périmètre quantité: {{scope}}',
      rank_qty_unclassified_text: '{{count}} non classables',
      rank_price_text: 'prix {{value}}',
      rank_value_per_unit_text: 'valeur/{{unit}} {{value}}',
      rank_avg_price_text: 'prix moyen {{value}}',
      rank_brand_value_text: 'valeur {{value}} | {{count}}',
      rank_cal_fun_prefix: 'Comparaison calories',
      chart_relation_line: '{{index}}. {{brand}}: prix {{price}} | valeur {{value}} | {{count}}',
      focus_no_theme: 'Aucun thème.',
      insight_scope: 'Périmètre: {{filtered}} / {{total}} | Onglet: {{tab}} | Couverture: {{coverage}}',
      insight_no_rows: 'Aucune ligne dans la vue actuelle. Élargis les filtres pour obtenir des analyses.',
      global_no_data: 'Aucune conclusion disponible: aucun produit dans la vue actuelle.',
      global_value_visible: 'Valeur visible: {{value}} pour {{filtered}} / {{total}} (vue courante).',
      global_main_weight: 'Poids principal: {{group}} concentre {{share}} de la valeur.',
      global_shift_value_volume: 'Décalage valeur/volume: valeur dominée par "{{valueGroup}}", volume dominé par "{{qtyGroup}}".',
      global_aligned_value_volume: 'Valeur et volume sont alignés sur le groupe "{{group}}".',
      global_product_concentration: 'Concentration produits: top 5 = {{share}} de la valeur (leader: {{leader}}).',
      global_operational_risk: 'Risque opérationnel: {{alertShare}} des produits ont une alerte; {{dueShare}} sont déjà dépassés ou <= 3 jours.',
      global_brand_summary: 'Marques: "{{brand}}" pèse {{share}} de la valeur; {{premium}}',
      global_brand_no_premium: 'aucune marque premium détectée.',
      global_brand_insufficient: 'Marques: pas assez de données de marque pour une conclusion solide.',
      global_nutrition_summary: 'Nutrition: "{{group}}" concentre {{share}} des calories visibles.',
      global_nutrition_insufficient: 'Nutrition: informations caloriques insuffisantes pour une conclusion globale.',
      ai_test_prompt: 'Réponds uniquement par "OK" puis une phrase brève (max 12 mots) en français.',
      ai_test_prompt_tiny: 'Réponds uniquement: OK',
      ai_empty_response_short: 'Réponse vide',
      focus_unknown_error: 'erreur inconnue',
      brand_logo_section_title: 'Logos de marques',
      brand_logo_lookup_btn: 'Rechercher depuis la base',
      brand_logo_lookup_refresh_btn: 'Actualiser la recherche',
      brand_logo_lookup_done: 'Recherche logos terminée: {{count}} marque(s) avec logo.',
      brand_logo_lookup_off: 'Recherche de logos désactivée (à la demande).',
      brand_logo_brand_label: 'Marque ciblée',
      brand_logo_source_label: 'Source des logos',
      brand_logo_source_database: 'Base Grocy',
      brand_logo_source_wikidata: 'Wikidata / Wikimedia Commons',
      brand_logo_source_simpleicons: 'Simple Icons (CDN)',
      brand_logo_source_duckduckgo: 'DuckDuckGo Icons',
      brand_logo_source_logodev: 'Logo.dev (API)',
      brand_logo_source_hint_database: 'Utilise les images produits déjà présentes dans Grocy.',
      brand_logo_source_hint_wikidata: 'Recherche la marque sur Wikidata puis récupère le logo depuis Wikimedia Commons (P154).',
      brand_logo_source_hint_simpleicons: 'Tente de trouver le logo officiel via le slug de marque sur le CDN Simple Icons.',
      brand_logo_source_hint_duckduckgo: 'Récupère l’icône du domaine officiel (site web de la marque).',
      brand_logo_source_hint_logodev: 'Interroge Logo.dev par nom de marque (token API requis).',
      brand_logo_logodev_token_label: 'Token Logo.dev (optionnel)',
      brand_logo_url_label: 'URL du logo',
      brand_logo_fetch_btn: 'Récupérer logo',
      brand_logo_fetch_all_btn: 'Récupérer tous les logos',
      brand_logo_fetch_running: 'Recherche du logo "{{brand}}" via {{source}}...',
      brand_logo_fetch_all_running: 'Récupération {{index}}/{{total}}: {{brand}} via {{source}}...',
      brand_logo_fetch_success: 'Logo récupéré depuis {{source}} pour {{brand}}.',
      brand_logo_fetch_fail: 'Échec récupération logo ({{source}}): {{msg}}',
      brand_logo_fetch_none: 'Aucun logo trouvé via {{source}} pour {{brand}}.',
      brand_logo_fetch_all_done: 'Récupération terminée: {{ok}} logo(s), {{skipped}} sans résultat, {{failed}} échec(s).',
      brand_logo_fetch_all_none: 'Aucune marque sans logo à traiter.',
      brand_logo_logodev_token_missing: 'Source Logo.dev sélectionnée: renseigne un token API.',
      brand_logo_save_btn: 'Enregistrer logo',
      brand_logo_clear_btn: 'Clear logo',
      brand_logo_reset_btn: 'Reset défaut',
      brand_logo_status_saved: 'Logo enregistré pour {{brand}}.',
      brand_logo_status_cleared: 'Logo masqué pour {{brand}}.',
      brand_logo_status_reset: 'Logo par défaut restauré pour {{brand}}.',
      brand_logo_status_missing_brand: 'Sélectionne d’abord une marque.',
      brand_logo_status_missing_url: 'Renseigne une URL de logo.',
      brand_logo_preview_none: 'Aucun logo actif pour cette marque.',
      brand_logo_preview_default: 'Source: base de données',
      brand_logo_preview_override: 'Source: logo personnalisé',
      brand_logo_preview_cleared: 'Logo masqué (clear actif).',
      brand_logo_preview_expand_btn: 'Agrandir',
      brand_logo_preview_open_title: 'Ouvrir le logo en grand',
      brand_logo_modal_title: 'Logo de marque',
      brand_logo_modal_close: 'Fermer',
      brand_logo_brand_placeholder: 'Sélectionne ou tape une marque...',
      brand_logo_brand_toggle: 'Afficher la liste des marques',
      brand_logo_brand_empty: 'Aucune marque correspondante.',
      brand_logo_status_missing_logo: 'Aucun logo disponible à afficher en grand.',
      brand_logo_banner_intro: 'Logos de marques: recherche désactivée pour limiter les requêtes. Clique pour lancer une recherche ponctuelle.',
      brand_logo_banner_new_brand: 'Nouvelles marques détectées: relance la recherche logos si tu veux enrichir les graphiques.',
      brand_logo_banner_enable: 'Activer maintenant',
      brand_logo_banner_refresh: 'Relancer recherche',
      brand_logo_banner_close: 'Masquer',
      brand_logo_settings_hint: 'La recherche base de données ne se fait qu’à la demande (bouton).',
      group_logo_group_label: 'Groupe ciblé',
      group_logo_url_label: 'URL du logo',
      group_logo_save_btn: 'Enregistrer logo',
      group_logo_clear_btn: 'Effacer logo',
      group_logo_reset_btn: 'Restaurer défaut',
      group_logo_status_saved: 'Logo enregistré pour {{group}}.',
      group_logo_status_cleared: 'Logo masqué pour {{group}}.',
      group_logo_status_reset: 'Logo par défaut restauré pour {{group}}.',
      group_logo_status_missing_group: 'Sélectionne d’abord un groupe.',
      group_logo_status_missing_url: 'Renseigne une URL de logo.',
      group_logo_preview_none: 'Aucun logo actif pour ce groupe.',
      group_logo_preview_default: 'Source: base de données',
      group_logo_preview_override: 'Source: logo personnalisé',
      group_logo_preview_cleared: 'Logo masqué (clear actif).',
      group_logo_preview_expand_btn: 'Agrandir',
      group_logo_preview_open_title: 'Ouvrir le logo en grand',
      group_logo_group_placeholder: 'Sélectionne ou tape un groupe...',
      group_logo_group_toggle: 'Afficher la liste des groupes',
      group_logo_group_empty: 'Aucun groupe correspondant.',
      group_logo_status_missing_logo: 'Aucun logo disponible à afficher en grand.',
      group_logo_settings_hint: 'Tu peux personnaliser un logo par groupe de produits.',
      settings_section_barcode_lookup: 'API OFF / OPF',
      barcode_lookup_provider_label: 'Fournisseur prioritaire (essayé en 1er)',
      barcode_lookup_provider_openfoodfacts: 'OFF (OpenFoodFacts)',
      barcode_lookup_provider_openproductsfacts: 'OPF (OpenProductsFacts)',
      barcode_lookup_provider_off: 'Désactivé',
      barcode_lookup_provider_hint_openfoodfacts: 'OFF est essayé en premier, puis OPF en fallback si activé.',
      barcode_lookup_provider_hint_openproductsfacts: 'OPF est essayé en premier, puis OFF en fallback si activé.',
      barcode_lookup_provider_hint_off: 'Désactive toutes les requêtes API OFF/OPF.',
      barcode_lookup_enabled_label: 'Activer les requêtes API OFF/OPF',
      barcode_lookup_enabled_hint: 'Si désactivé, aucun appel OFF/OPF n’est lancé.',
      barcode_lookup_auto_fallback_label: 'Fallback auto vers le fournisseur secondaire',
      barcode_lookup_auto_fallback_hint: 'En cas d’erreur ou de résultat vide, essaye automatiquement l’autre fournisseur.',
      barcode_lookup_status_saved: 'Paramètres OFF/OPF enregistrés: 1er {{provider}} | fallback {{fallback}} | API {{enabled}}.',
      barcode_lookup_enabled_yes: 'active',
      barcode_lookup_enabled_no: 'désactivée',
      barcode_lookup_fallback_yes: 'activé',
      barcode_lookup_fallback_no: 'désactivé',
      facts_provider_disabled: 'API OFF/OPF désactivée dans les paramètres.',
      settings_section_facts_api_tests: 'Tests API OFF / OPF',
      facts_api_test_hint: 'Teste rapidement l’accessibilité API des deux fournisseurs.',
      facts_api_test_off_btn: 'Tester OFF',
      facts_api_test_opf_btn: 'Tester OPF',
      facts_api_test_active_btn: 'Tester l’ordre actif',
      facts_api_test_running: 'Test {{provider}} en cours…',
      facts_api_test_success: '{{provider}} OK (HTTP 200, {{count}} résultat(s), {{ms}} ms).',
      facts_api_test_error: '{{provider}} en erreur: {{msg}}.',
      facts_api_test_active_success: 'Ordre actif validé: {{provider}} a répondu en {{ms}} ms.',
      facts_api_test_active_error: 'Échec ordre actif: {{msg}}.',
      facts_provider_switch_note: 'Ordre actif: {{order}}',
      settings_section_photo_search: 'Recherche photo produit',
      photo_search_engine_label: 'Moteur de recherche image',
      photo_search_engine_google: 'Google Images',
      photo_search_engine_duckduckgo: 'DuckDuckGo Images',
      photo_search_engine_bing: 'Bing Images',
      photo_search_engine_hint_google: 'Recherche image via Google (onglet images).',
      photo_search_engine_hint_duckduckgo: 'Recherche image via DuckDuckGo (onglet images).',
      photo_search_engine_hint_bing: 'Recherche image via Bing Images.',
      photo_search_off_name_fallback_label: 'OFF/OPF: fallback par nom si code-barres introuvable',
      photo_search_status_saved: 'Paramètres photo enregistrés.',
      photo_search_btn_png: 'PNG',
      photo_search_btn_jpg: 'JPG',
      photo_search_btn_off_title: 'Rechercher sur {{provider}}',
      photo_search_status_need_name: 'Un nom de produit est requis.',
      photo_search_status_need_barcode: 'Code-barres requis pour {{provider}}.',
      photo_search_status_running_barcode: 'Recherche {{provider}} par code-barres…',
      photo_search_status_running_name: 'Code-barres introuvable, essai {{provider}} par nom…',
      photo_search_status_success_barcode: 'Ouverture {{provider}} via code-barres {{barcode}}.',
      photo_search_status_success_name: 'Ouverture {{provider}} via nom du produit.',
      photo_search_status_no_result_barcode: 'Aucun produit {{provider}} trouvé pour ce code-barres.',
      photo_search_status_no_result_name: 'Aucun produit {{provider}} trouvé pour ce nom.',
      photo_search_status_api_error: 'Échec {{provider}}: {{msg}}.',
      photo_search_btn_facts_combined: 'Rechercher OFF + OPF',
      photo_search_btn_facts_openfoodfacts: 'Rechercher OFF',
      photo_search_btn_facts_openproductsfacts: 'Rechercher OPF',
      photo_search_status_need_barcode_or_name: 'Code-barres requis, ou active le fallback par nom.',
      photo_search_status_running_images: 'Recherche de photos via {{providers}}…',
      photo_search_status_images_found: '{{count}} photo(s) trouvée(s).',
      photo_search_status_images_none: 'Aucune photo trouvée via {{providers}}.',
      photo_search_status_image_download_error: 'Impossible de télécharger la photo: {{msg}}.',
      photo_search_status_image_saving: 'Sauvegarde de la photo {{provider}} en cours…',
      photo_search_status_image_saved: 'Photo enregistrée depuis {{provider}}.',
      photo_search_status_image_pending_refresh: 'Photo sélectionnée depuis {{provider}}. Clique sur rafraîchir pour mettre à jour l\'aperçu.',
      photo_search_status_image_refreshed: 'Aperçu photo rafraîchi.',
      photo_search_status_keep_current: 'Image actuelle conservée. Résultats retirés.',
      photo_search_status_image_save_error: 'Échec de sauvegarde photo: {{msg}}.',
      photo_search_card_source: 'Source: {{provider}}',
      photo_search_card_source_current: 'Source: image actuelle',
      photo_search_card_choose: 'Choisir pour photo du produit',
      photo_search_card_keep_current: 'Conserver l\'image actuelle',
      photo_search_card_choose_title: 'Cliquer pour appliquer cette photo au produit',
      photo_search_btn_refresh_preview: 'Rafraîchir la photo',
      photo_search_btn_refresh_preview_title: 'Rafraîchir l\'aperçu avec la photo sélectionnée',
      photo_search_error_need_saved_product: 'Enregistre d’abord le produit (ID manquant) pour sauvegarder automatiquement la photo.',
      barcode_autofill_assist_name: 'Assistant instantané',
      barcode_autofill_assist_on_title: 'Assistant instantané activé (recherche auto à l’ouverture).',
      barcode_autofill_assist_off_title: 'Assistant instantané désactivé.',
      barcode_autofill_assist_auto_run: 'Assistant instantané: lancement automatique de la recherche.',
      barcode_header_open_off_title: 'Ouvrir OFF (OpenFoodFacts) pour ce produit',
      barcode_header_open_opf_title: 'Ouvrir OPF (OpenProductsFacts) pour ce produit',
      barcode_header_google_title: 'Rechercher sur Google + fournisseur actif',
      barcode_header_robot_title: 'Créer automatiquement un code-barres (OFF/OPF -> Grocy)',
      barcode_header_robot_need_product_id: 'ID produit introuvable sur cette page.',
      barcode_header_robot_need_unit: 'Unité d\'achat introuvable. Vérifie "Unité d\'achat par défaut".',
      barcode_header_robot_running: 'Robot: recherche en cours…',
      barcode_header_robot_exists: 'Le code-barres {{code}} existe déjà dans la fiche.',
      barcode_header_robot_created: 'Robot: code-barres {{code}} créé ({{unit}} x{{amount}}).',
      barcode_header_robot_api_error: 'Robot: erreur {{msg}}.',
      lang_applied_instant: 'Langue appliquée immédiatement: {{lang}}.',
    },
    en: {
      lang_name_fr: 'French',
      lang_name_en: 'English',
      lang_mode_label: 'Interface language',
      due_date_format_label: 'Expiry date format',
      due_date_format_hint: 'Format used to display expiry dates in local info.',
      due_date_format_hint_sample: 'Example: {{sample}}',
      due_date_format_auto: 'Auto (UI language)',
      due_date_format_ymd: 'YYYY-MM-DD',
      due_date_format_dmy: 'DD/MM/YYYY',
      due_date_format_mdy: 'MM/DD/YYYY',
      lang_mode_hint_auto: 'Automatic detection: {{lang}}',
      lang_mode_hint_fixed: 'Forced language: {{lang}}',
      tab_food: 'Food',
      tab_meds_default: 'Medicines',
      tab_hyg_default: 'Hygiene & care',
      tab_home_default: 'Home & cleaning',
      dash_title: 'Statistics & charts',
      dash_view_stats: 'Statistics',
      dash_view_rankings: 'Rankings',
      dash_refresh: 'Refresh',
      dash_show: 'Show',
      dash_hide: 'Hide',
      dash_context_default: 'Real-time analysis of the current view.',
      kpi_products: 'Products',
      kpi_total_value: 'Total value',
      kpi_avg_price: 'Average price',
      kpi_calories: 'Calories',
      kpi_alerts: 'Alerts',
      kpi_brands: 'Brands',
      kpi_fun_value_stock_title: 'Stock value comparisons',
      kpi_fun_value_lifetime_title: 'Lifetime purchase value comparisons',
      kpi_fun_cal_stock_title: 'Stock calorie comparisons',
      kpi_fun_cal_lifetime_title: 'Lifetime purchase calorie comparisons',
      kpi_fun_loading: 'Loading history...',
      kpi_fun_no_data: 'Not enough history for comparison.',
      kpi_fun_history_error: 'Purchase history unavailable.',
      kpi_fun_rounded_badge: 'rounded',
      kpi_fun_toggle_show: 'Show fun comparisons',
      kpi_fun_toggle_hide: 'Hide fun comparisons',
      kpi_fun_randomize_all: 'Shuffle',
      overlay_fun_title: 'Fun comparisons',
      overlay_fun_scope_current: 'Current view',
      overlay_fun_scope_lifetime: 'Lifetime history',
      overlay_fun_no_data: 'No fun comparison available.',
      kpi_fun_thumb_hover_hint: 'Hover to enlarge',
      kpi_fun_thumb_fallback_name: 'Product',
      quick_read_title: 'Quick read',
      chart_group_value_title: 'Value by group',
      chart_group_value_sub: 'Financial weight of groups in stock.',
      chart_group_qty_title: 'Quantity by group',
      chart_group_qty_sub: 'Available volume by group.',
      chart_risk_title: 'Alert status',
      chart_risk_sub: 'Below min stock, due soon, overdue and expired.',
      chart_due_title: 'Due dates',
      chart_due_sub: 'Time projection of upcoming dates.',
      chart_brand_price_title: 'Average price by brand',
      chart_brand_price_sub: 'Brand comparison on unit price.',
      chart_brand_rel_title: 'Price-brand relation',
      chart_brand_rel_sub: 'X=average price, Y=stock value, size=product count.',
      chart_top_value_title: 'Top products by value',
      chart_top_value_sub: 'Products locking the most value.',
      chart_price_vs_value_title: 'Product price vs value',
      chart_price_vs_value_sub: 'Detect expensive and heavy-stock products.',
      chart_group_cal_title: 'Calories by group',
      chart_group_cal_sub: 'Aggregated nutritional view by group.',
      global_conclusions_title: 'Combined global conclusions',
      rankings_title: 'Rankings',
      rankings_context: 'Rankings for the current view.',
      rank_top_value_title: 'Top products by value',
      rank_top_value_sub: 'Products locking the most budget',
      rank_top_qty_title: 'Top products by quantity',
      rank_top_qty_sub: 'Highest available volumes',
      rank_top_price_title: 'Top products by unit price',
      rank_top_price_sub: 'Most expensive products per unit',
      rank_top_cal_title: 'Top products by calories',
      rank_top_cal_sub: 'Individual nutritional impact',
      rank_top_value_per_unit_title: 'Top value/unit',
      rank_top_value_per_unit_sub: 'Financial weight per stocked unit',
      rank_due_nearest_title: 'Nearest due dates',
      rank_due_nearest_sub: 'Products to consume first',
      rank_due_over_title: 'Overdue products',
      rank_due_over_sub: 'Delays to handle first',
      rank_group_value_title: 'Groups by value',
      rank_group_value_sub: 'Budget concentration by group',
      rank_group_qty_title: 'Groups by quantity',
      rank_group_qty_sub: 'Volume concentration by group',
      rank_brand_value_title: 'Brands by value',
      rank_brand_value_sub: 'Financial weight of brands',
      rank_brand_avg_price_title: 'Brands by average price',
      rank_brand_avg_price_sub: 'Brand price level',
      rank_brand_coverage_title: 'Brands by coverage',
      rank_brand_coverage_sub: 'Product count by brand',
      rankings_category_all: 'All',
      rankings_category_products: 'Products',
      rankings_category_brands: 'Brands',
      rankings_category_groups: 'Categories',
      rankings_category_ops: 'Operations',
      rankings_podium_title: 'Podiums',
      rankings_podium_sub: 'Quick view of key rankings (top/bottom).',
      rankings_mode_top: 'Top',
      rankings_mode_bottom: 'Bottom',
      rankings_see_more: 'See more',
      rankings_full_title: 'Detailed rankings',
      rankings_full_sub: 'Complete view for each criterion (collapsed by default).',
      rankings_full_expand: 'Expand',
      rankings_full_collapse: 'Collapse',
      rankings_mode_badge_top: 'Mode: top',
      rankings_mode_badge_bottom: 'Mode: bottom',
      rankings_mode_toggle_title: 'Click to toggle top/bottom',
      rankings_none: 'No ranking available for this view.',
      overlay_chart_title: 'Chart',
      status_below_min: 'Below minimum stock',
      status_due_soon: 'Due soon',
      status_overdue: 'Overdue',
      status_expired: 'Expired',
      due_over: 'Overdue',
      due_0_3: '0-3 days',
      due_4_7: '4-7 days',
      due_8_30: '8-30 days',
      due_30_plus: '>30 days',
      due_none: 'No date',
      no_data: 'No data',
      overlay_close: 'Close',
      overlay_full_suffix: 'full view',
      overlay_legend_title: 'Detailed legend',
      overlay_explain_title: 'How to read this chart',
      overlay_takeaways_title: 'Key takeaways',
      overlay_details_title: 'Detailed data',
      overlay_details_expand: 'Expand',
      overlay_details_collapse: 'Collapse',
      overlay_focus_title: 'AI focus on selected element',
      overlay_focus_local_title: 'Local info',
      overlay_focus_ai_title: 'AI info',
      overlay_open_product: 'Open product card',
      overlay_open_brand_products: 'View products of this brand',
      overlay_open_group_products: 'View products in this category',
      overlay_stock_links_title: 'Targeted stock access',
      overlay_retry_ai: 'Retry AI',
      overlay_focus_hint: 'Click a chart element to show detailed focus.',
      overlay_ai_waiting: 'AI agent waiting.',
      overlay_focus_ai_unvalidated: 'Agent not validated',
      overlay_focus_ai_error: 'AI error',
      overlay_focus_ai_missing: 'AI not configured',
      overlay_focus_ai_disabled: 'AI disabled',
      overlay_focus_ai_settings_btn: 'AI settings',
      overlay_focus_bucket_see_more: 'See more',
      overlay_focus_bucket_show_more: 'Show more',
      ai_settings_title: 'StatNerd general settings',
      ai_settings_close: 'Close',
      ai_enable_focus: 'Enable AI agent on fullscreen focus',
      ai_provider_active: 'Active provider',
      ai_cost_mode: 'AI cost mode',
      ai_mode_perf: 'Performance (detailed auto)',
      ai_mode_eco: 'Eco (limited auto)',
      ai_mode_cheapest: 'Cheapest (manual, ultra-frugal)',
      ai_mode_label_perf: 'Performance',
      ai_mode_label_eco: 'Eco',
      ai_mode_label_cheapest: 'Cheapest',
      ai_temperature: 'Temperature',
      ai_timeout: 'Timeout (ms)',
      ai_fallback_enable: 'Enable auto fallback',
      ai_fallback_order: 'Fallback order (multi-select)',
      ai_provider_configs: 'Provider configurations',
      ai_local_key_hint: 'The key is stored locally in your browser (localStorage).',
      ai_test_btn: 'Test connection',
      ai_save_btn: 'Save',
      settings_save_btn: 'Save',
      settings_save_all_btn: 'Save all',
      settings_section_interface: 'Interface & AI',
      settings_section_runtime: 'AI behavior',
      settings_section_providers: 'AI providers (manual)',
      settings_section_brand_logos: 'Brand logos',
      settings_section_group_logos: 'Group logos',
      settings_section_addon_compat: 'Compatibility',
      settings_section_saved: 'Section "{{section}}" saved.',
      settings_tabs_general: 'General',
      settings_tabs_product_data: 'Product data',
      settings_tabs_visuals: 'Logos',
      settings_tabs_compat: 'Compatibility',
      settings_tabs_providers: 'AI providers',
      settings_tabs_update: 'Updates',
      settings_group_general: 'General settings',
      settings_group_product_data: 'Product services',
      settings_group_visuals: 'Visual identity',
      settings_group_compat: 'StatNerd compatibility',
      settings_group_providers: 'AI providers',
      settings_group_update: 'Updates & info',
      settings_group_reduce: '(collapse)',
      settings_group_expand: '(open)',
      addon_compat_desc: 'Adds product groups, user entities, and fields used by the addon.',
      addon_compat_scope_note: 'Scope: product_groups + userentities + userfields. Existing items are auto-detected.',
      addon_compat_run_btn: 'Apply compatibility',
      addon_compat_map_btn: 'Map similar items',
      addon_compat_reoffer_btn: 'Show first-run proposal again',
      addon_compat_banner_text: 'Addon compatibility: detect existing items, map similar ones, then create only missing items.',
      addon_compat_banner_apply: 'Apply',
      addon_compat_banner_map: 'Map',
      addon_compat_banner_later: 'Later',
      addon_compat_banner_missing_detail: 'Missing items: {{missing}} | mapping suggestions: {{mapping}}.',
      addon_compat_status_idle: 'Waiting to run.',
      addon_compat_status_running: 'Applying compatibility...',
      addon_compat_status_done: 'Compatibility applied: {{created}} created, {{existing}} already present, {{mapped}} mapped, {{failed}} failed.',
      addon_compat_status_ready: 'Compatibility already satisfied: nothing to add.',
      addon_compat_status_mapping_none: 'No relevant mapping suggestions found.',
      addon_compat_status_mapping_cancelled: 'Mapping cancelled.',
      addon_compat_status_fail: 'Compatibility failed: {{msg}}',
      addon_compat_status_prompt_reset: 'The proposal will appear again on next load.',
      addon_compat_mapping_title: 'Compatibility mapping',
      addon_compat_mapping_intro: 'Similar items were found ({{count}}). Choose what to reuse or keep \"Create\".',
      addon_compat_mapping_close: 'Close',
      addon_compat_mapping_skip: 'Skip',
      addon_compat_mapping_apply: 'Apply',
      addon_compat_mapping_create: 'Create \"{{name}}\"',
      addon_compat_mapping_similarity: '{{score}}% match',
      settings_section_addon_update: 'StatNerd update',
      addon_update_desc: 'Checks GitHub releases, lets you choose a version, then prepares local update commands.',
      addon_update_repo_label: 'GitHub repository (owner/repo)',
      addon_update_repo_hint: 'Example: Raph563/Grocy.',
      addon_update_local_root_label: 'Local Grocy root folder',
      addon_update_local_root_hint: 'Example: C:\\Users\\Admin\\Documents\\Docker\\grocy (contains addon/ and config/).',
      addon_update_local_root_browse_btn: 'Browse',
      addon_update_local_root_pick_fail: 'Folder selection is unavailable in this browser. Enter the path manually.',
      addon_update_check_stable_btn: 'Check stable',
      addon_update_check_prerelease_btn: 'Check alpha/beta',
      addon_update_run_bridge_btn: 'Update automatically',
      addon_update_bridge_test_btn: 'Test desktop app',
      addon_update_bridge_hint: 'Requires the StatNerd Relay desktop app running (Windows/macOS).',
      addon_update_bridge_status_ready: 'Desktop app detected.',
      addon_update_bridge_status_missing: 'Desktop app not found. Start StatNerd Relay.',
      addon_update_bridge_status_running: 'Updating through desktop app...',
      addon_update_bridge_status_success: 'Update completed through desktop app.',
      addon_update_bridge_status_error: 'Desktop update failed: {{msg}}',
      addon_update_open_release_btn: 'Open release',
      addon_update_open_release_tag: 'Release {{tag}}',
      addon_update_copy_btn: 'Copy',
      addon_update_cmd_ps_label: 'Windows PowerShell command',
      addon_update_cmd_sh_label: 'Linux/macOS command',
      addon_update_cmd_hint: 'PowerShell one-liner: Set-Location to addon/scripts then run update-from-github with config path. Selecting a version auto-injects the tag.',
      addon_update_release_list_label: 'Choose a version to install',
      addon_update_release_list_empty: 'No versions loaded yet. Run a check first.',
      addon_update_release_badge_prerelease: 'alpha/beta',
      addon_update_release_selected: 'Selected version: {{tag}}',
      addon_update_changelog_label: 'Selected version changelog',
      addon_update_changelog_empty: 'No changelog available for this release.',
      statnerd_about_title: 'StatNerd info',
      statnerd_about_author: 'Author: {{author}}',
      statnerd_about_version: 'Installed local version: {{version}}',
      statnerd_about_release_link: 'GitHub releases',
      statnerd_about_changelog_link: 'Global changelog',
      statnerd_about_docs_link: 'Documentation',
      statnerd_about_selected_changelog: 'Selected version changelog',
      addon_update_versions_line: 'Local version: {{local}} | Selected release: {{remote}} (tag {{tag}}).',
      addon_update_last_checked: 'Last check: {{date}}.',
      addon_update_not_checked: 'Not checked yet.',
      addon_update_version_unknown: 'unknown',
      addon_update_repo_invalid: 'Invalid repository format (expected: owner/repo).',
      addon_update_status_idle: 'Run a stable or alpha/beta check to load versions.',
      addon_update_status_checking: 'Checking GitHub releases...',
      addon_update_status_up_to_date: 'StatNerd is up to date: version {{version}}.',
      addon_update_status_update_available: 'Update available: local {{local}} -> {{latest}} ({{tag}}).',
      addon_update_status_local_ahead: 'Local version is newer than selected release: local {{local}} / release {{latest}}.',
      addon_update_status_release_missing: 'No GitHub release found.',
      addon_update_status_release_missing_asset: 'Release {{tag}} found but no usable ZIP asset.',
      addon_update_status_error: 'Update check failed: {{msg}}',
      addon_update_copy_ok: 'Command copied.',
      addon_update_copy_fail: 'Copy failed: select command manually.',
      ai_validation_mode_label: 'Validation mode when clicking Save',
      ai_validation_mode_single: 'Single agent',
      ai_validation_mode_fallback: 'Fallback chain',
      ai_validation_mode_single_tip: 'Single agent: test and use only the active provider.',
      ai_validation_mode_fallback_tip: 'Fallback chain: try active provider then the next ones in order.',
      ai_validation_mode_hint_single: 'Tests only the active agent.',
      ai_validation_mode_hint_fallback: 'Tests active agent then fallback chain, stops at first valid.',
      ai_save_running: 'Agent validation running...',
      ai_save_validation_fail: 'Save blocked: {{msg}}',
      ai_save_validation_ok: 'Validation succeeded with {{provider}}.',
      error_short: 'Error',
      ai_provider_links_title: 'Resources',
      ai_provider_link_docs: 'Docs',
      ai_provider_link_keys: 'API keys',
      ai_provider_link_console: 'Console',
      ai_provider_link_download: 'Download',
      ai_provider_link_selfhost: 'Self-hosted',
      ai_field_required: 'Required field.',
      ai_provider_rejected_short: 'Rejected',
      ai_provider_valid_short: 'Valid',
      ai_provider_rejected_reason: 'Reason: {{msg}}',
      ai_api_key_error_low_credit: 'Low credit / quota exceeded.',
      ai_api_key_error_access_denied: 'Access denied / invalid key.',
      configured_short: 'Configured',
      not_configured_short: 'Not configured',
      error_short: 'Error',
      provider_links_title: 'Useful links',
      provider_link_docs: 'Documentation',
      provider_link_keys: 'API keys',
      provider_link_download: 'Download',
      provider_link_selfhosted: 'Self-hosted',
      ai_settings_btn_title_configured: 'StatNerd settings (AI: {{provider}} configured)',
      ai_settings_btn_title_not_configured: 'StatNerd settings (AI: {{provider}} not configured)',
      ai_mode_goal_perf: 'responsiveness',
      ai_mode_goal_eco: 'cost/perf balance',
      ai_mode_goal_cheapest: 'minimum cost',
      ai_mode_changed: 'Mode {{mode}}: optimized for {{goal}}.',
      ai_saved: 'Settings saved ({{provider}}{{model}} | mode {{mode}}).',
      ai_test_disabled: 'AI disabled: enable it to test.',
      ai_test_incomplete: 'Incomplete configuration for {{provider}}.',
      ai_test_running: '{{provider}} test running...',
      ai_test_ok: 'Connection successful ({{provider}}{{model}}): {{msg}}',
      ai_test_fail: '{{provider}} test failed: {{msg}}',
      focus_ai_disabled: 'AI agent disabled. Enable it via settings icon.',
      focus_ai_config_missing: 'Incomplete {{provider}} configuration. Set it via settings icon.',
      focus_ai_auto_disabled: 'Mode {{mode}}: automatic analysis disabled. Click "Retry AI" to run one targeted analysis.',
      focus_ai_busy: 'Mode {{mode}}: analysis already running, wait 1-2s.',
      focus_ai_auto_limit: 'Mode {{mode}}: auto limit reached ({{count}} calls). Use "Retry AI" if needed.',
      focus_ai_total_limit: 'AI budget reached for this view ({{count}} calls). Close/reopen fullscreen to reset.',
      focus_ai_throttle: 'Mode {{mode}}: anti-spam active, wait {{wait}} s.',
      focus_ai_running: 'AI agent ({{provider}} | mode {{mode}}): analysis running...',
      focus_ai_unavailable: 'AI agent unavailable: {{message}}.',
      focus_ai_restore_missing: 'AI data not cached. Click "Retry AI" to regenerate.',
      focus_resp_empty: 'Empty AI response.',
      source_ai_prefix: 'AI source',
      meta_element: 'Element',
      meta_type: 'Type',
      meta_chart: 'Chart',
      meta_group: 'Group',
      meta_brand: 'Brand',
      meta_value: 'Value',
      meta_quantity: 'Quantity',
      meta_price: 'Price',
      meta_avg_price: 'Average price',
      meta_calories: 'Calories',
      focus_anchor_qty: 'Practical anchor',
      focus_anchor_cal: 'Energy anchor',
      focus_anchor_random: 'Random',
      focus_anchor_random_title: 'Shuffle anchor',
      meta_due: 'Due date',
      meta_alerts: 'Alerts',
      default_all: 'All',
      default_no_group: 'No group',
      default_no_brand: 'No brand',
      default_category: 'Category',
      default_product: 'Product',
      default_brand: 'Brand',
      default_item: 'Element',
      default_none: 'none',
      default_na: 'N/A',
      unit_units: 'units',
      unit_products: 'products',
      unit_brands: 'brands',
      unit_alerts: 'alerts',
      unit_days_short: 'd',
      others_label: 'Others',
      no_info_available: 'No information available.',
      metric_value_prefix: 'value',
      metric_price_prefix: 'price',
      metric_avg_price_prefix: 'average price',
      metric_quantity_prefix: 'quantity',
      metric_group_prefix: 'group',
      chart_dataset_brands: 'Brands',
      chart_dataset_products: 'Products',
      chart_axis_avg_unit_price: 'Average unit price',
      chart_axis_stock_value: 'Stock value',
      chart_axis_unit_price: 'Unit price',
      chart_label_value: 'Value',
      chart_label_quantity: 'Quantity',
      chart_label_products: 'Products',
      chart_label_avg_price: 'Average price',
      ctl_sort_desc_title: 'Sort from highest to lowest',
      ctl_sort_desc: 'Desc',
      ctl_sort_asc_title: 'Sort from lowest to highest',
      ctl_sort_asc: 'Asc',
      ctl_limit_all: 'All',
      ctl_limit_all_title: 'Show all values',
      ctl_limit_top: 'Top',
      ctl_limit_top_title: 'Show only the top {{limit}} values',
      ctl_include_zero: '0+',
      ctl_include_zero_title: 'Include zero values',
      ctl_qty_auto: 'Auto',
      ctl_qty_auto_title: 'Auto mode based on dominant units in current view',
      ctl_qty_mass: 'Mass',
      ctl_qty_mass_title: 'Force quantities in mass (kg/g)',
      ctl_qty_volume: 'Volume',
      ctl_qty_volume_title: 'Force quantities in volume (L/ml)',
      ctl_qty_count: 'Units',
      ctl_qty_count_title: 'Force quantities in count units',
      ctl_type_bar: 'Bars',
      ctl_type_bar_title: 'Show as bars',
      ctl_type_donut: 'Donut',
      ctl_type_donut_title: 'Show as donut',
      ctl_type_scatter: 'Scatter',
      ctl_type_scatter_title: 'Show as scatter points',
      ctl_type_bubble: 'Bubbles',
      ctl_type_bubble_title: 'Show as bubbles',
      qty_mode_auto_label: 'Auto',
      qty_mode_mass_label: 'Mass',
      qty_mode_volume_label: 'Volume',
      qty_mode_count_label: 'Units',
      chart_qty_unit_badge: 'Active unit: {{unit}} (mode {{mode}})',
      chart_qty_total_badge: 'Total: {{total}}',
      chart_qty_total_badge_empty: 'Total: N/A',
      chart_qty_total_badge_title: 'Sum of classifiable quantities (mode {{mode}}).',
      chart_qty_unclassified_title: 'Products not classifiable for this unit',
      chart_qty_unclassified_none: 'No unclassifiable product for this mode.',
      chart_qty_unclassified_more: '+{{count}} more',
      chart_qty_unclassified_fix_link: 'Find a conversion',
      chart_qty_unclassified_fix_link_title: 'Search a conversion via OFF/OPF',
      qty_lookup_terminal_source: 'Quantity conversions',
      qty_lookup_step_start: 'Conversion: analyzing {{product}}.',
      qty_lookup_step_barcode_try: 'Searching OFF/OPF barcode...',
      qty_lookup_step_barcode_found: 'Barcode found: {{barcode}}.',
      qty_lookup_step_barcode_missing: 'No barcode found, running deep name search...',
      qty_lookup_step_provider_try: 'Analyzing {{provider}}...',
      qty_lookup_step_provider_error: '{{provider}}: {{error}}',
      qty_lookup_none: 'No usable conversion found for {{product}}.',
      qty_lookup_found: '{{count}} conversion(s) found for {{product}}.',
      qty_lookup_picker_title: 'Suggested conversions',
      qty_lookup_picker_subtitle: '{{product}} - choose a conversion to apply.',
      qty_lookup_picker_apply: 'Apply',
      qty_lookup_picker_close: 'Close',
      qty_lookup_picker_hint: '1 {{stockUnit}} = {{converted}} (mode {{mode}}) | {{provider}}',
      qty_lookup_picker_basis: 'Basis: {{basis}}',
      qty_lookup_picker_via_barcode: 'via barcode',
      qty_lookup_picker_via_name: 'via name',
      qty_lookup_applied: 'Conversion applied: 1 {{stockUnit}} = {{converted}} for {{product}}.',
      qty_lookup_refreshed: 'Quantity chart refreshed.',
      ctl_expand_title: 'Open fullscreen',
      overlay_controls_label: 'Chart controls',
      brand_rel_none: 'No brand with usable average price and value.',
      brand_rel_more_suffix: '... ({{count}} more items, click expand)',
      charts_unavailable: 'Charts unavailable right now (Chart.js is loading or blocked).',
      hover_preview_due_label: 'Due date',
      hover_preview_price_label: 'Price',
      hover_preview_recipes_label: 'Recipes',
      hover_preview_recipes_none: 'No linked recipe.',
      hover_preview_recipes_more: '+{{count}} more recipes',
      hover_preview_top_products_label: 'Top 5 most purchased products',
      hover_preview_low_label: 'Low price',
      hover_preview_high_label: 'High price',
      hover_preview_currency_symbol: '$',
      hover_preview_loading: 'Loading details...',
      hover_preview_more: '+{{count}} more products',
      hover_preview_empty: 'No matching product.',
      due_no_date_text: 'no date',
      due_over_by: 'overdue by {{days}}',
      due_over_by_span: 'overdue by {{span}}',
      due_today: 'today',
      due_in: 'in {{days}}',
      due_in_span: 'in {{span}}',
      ranking_context_line: '{{products}}/{{total}} analyzed | {{cards}} rankings.',
      rank_value_text: 'value {{value}}',
      rank_quantity_text: 'quantity {{value}}',
      rank_qty_scope_text: 'Quantity scope: {{scope}}',
      rank_qty_unclassified_text: '{{count}} unclassifiable',
      rank_price_text: 'price {{value}}',
      rank_value_per_unit_text: 'value/{{unit}} {{value}}',
      rank_avg_price_text: 'average price {{value}}',
      rank_brand_value_text: 'value {{value}} | {{count}}',
      rank_cal_fun_prefix: 'Calorie comparison',
      chart_relation_line: '{{index}}. {{brand}}: price {{price}} | value {{value}} | {{count}}',
      focus_no_theme: 'No theme.',
      insight_scope: 'Scope: {{filtered}} / {{total}} | Tab: {{tab}} | Coverage: {{coverage}}',
      insight_no_rows: 'No row in the current view. Widen filters to get analyses.',
      global_no_data: 'No conclusion available: no product in the current view.',
      global_value_visible: 'Visible value: {{value}} for {{filtered}} / {{total}} (current view).',
      global_main_weight: '{{group}} is the main weight with {{share}} of value.',
      global_shift_value_volume: 'Value/volume mismatch: value led by "{{valueGroup}}", volume led by "{{qtyGroup}}".',
      global_aligned_value_volume: 'Value and volume are aligned on group "{{group}}".',
      global_product_concentration: 'Product concentration: top 5 = {{share}} of value (leader: {{leader}}).',
      global_operational_risk: 'Operational risk: {{alertShare}} of products have an alert; {{dueShare}} are overdue or <= 3 days.',
      global_brand_summary: 'Brands: "{{brand}}" accounts for {{share}} of value; {{premium}}',
      global_brand_no_premium: 'no premium brand detected.',
      global_brand_insufficient: 'Brands: not enough brand data for a solid conclusion.',
      global_nutrition_summary: 'Nutrition: "{{group}}" accounts for {{share}} of visible calories.',
      global_nutrition_insufficient: 'Nutrition: insufficient calorie data for a global conclusion.',
      ai_test_prompt: 'Reply only with "OK" then one short sentence (max 12 words) in English.',
      ai_test_prompt_tiny: 'Reply only: OK',
      ai_empty_response_short: 'Empty response',
      focus_unknown_error: 'unknown error',
      brand_logo_section_title: 'Brand logos',
      brand_logo_lookup_btn: 'Lookup from database',
      brand_logo_lookup_refresh_btn: 'Refresh lookup',
      brand_logo_lookup_done: 'Logo lookup done: {{count}} brand(s) with logo.',
      brand_logo_lookup_off: 'Logo lookup disabled (on demand only).',
      brand_logo_brand_label: 'Target brand',
      brand_logo_source_label: 'Logo source',
      brand_logo_source_database: 'Grocy database',
      brand_logo_source_wikidata: 'Wikidata / Wikimedia Commons',
      brand_logo_source_simpleicons: 'Simple Icons (CDN)',
      brand_logo_source_duckduckgo: 'DuckDuckGo Icons',
      brand_logo_source_logodev: 'Logo.dev (API)',
      brand_logo_source_hint_database: 'Uses product images already available in Grocy.',
      brand_logo_source_hint_wikidata: 'Searches brand on Wikidata and retrieves logo from Wikimedia Commons (P154).',
      brand_logo_source_hint_simpleicons: 'Tries to find official logo from brand slug on Simple Icons CDN.',
      brand_logo_source_hint_duckduckgo: 'Fetches icon from the official brand domain.',
      brand_logo_source_hint_logodev: 'Queries Logo.dev by brand name (API token required).',
      brand_logo_logodev_token_label: 'Logo.dev token (optional)',
      brand_logo_url_label: 'Logo URL',
      brand_logo_fetch_btn: 'Fetch logo',
      brand_logo_fetch_all_btn: 'Fetch all logos',
      brand_logo_fetch_running: 'Fetching "{{brand}}" logo via {{source}}...',
      brand_logo_fetch_all_running: 'Fetching {{index}}/{{total}}: {{brand}} via {{source}}...',
      brand_logo_fetch_success: 'Logo fetched from {{source}} for {{brand}}.',
      brand_logo_fetch_fail: 'Logo fetch failed ({{source}}): {{msg}}',
      brand_logo_fetch_none: 'No logo found via {{source}} for {{brand}}.',
      brand_logo_fetch_all_done: 'Batch done: {{ok}} logo(s), {{skipped}} without result, {{failed}} failed.',
      brand_logo_fetch_all_none: 'No brand without logo to process.',
      brand_logo_logodev_token_missing: 'Logo.dev source selected: provide an API token.',
      brand_logo_save_btn: 'Save logo',
      brand_logo_clear_btn: 'Clear logo',
      brand_logo_reset_btn: 'Reset default',
      brand_logo_status_saved: 'Logo saved for {{brand}}.',
      brand_logo_status_cleared: 'Logo hidden for {{brand}}.',
      brand_logo_status_reset: 'Default logo restored for {{brand}}.',
      brand_logo_status_missing_brand: 'Select a brand first.',
      brand_logo_status_missing_url: 'Enter a logo URL.',
      brand_logo_preview_none: 'No active logo for this brand.',
      brand_logo_preview_default: 'Source: database',
      brand_logo_preview_override: 'Source: custom logo',
      brand_logo_preview_cleared: 'Logo hidden (clear active).',
      brand_logo_preview_expand_btn: 'Enlarge',
      brand_logo_preview_open_title: 'Open large logo',
      brand_logo_modal_title: 'Brand logo',
      brand_logo_modal_close: 'Close',
      brand_logo_brand_placeholder: 'Select or type a brand...',
      brand_logo_brand_toggle: 'Show brand list',
      brand_logo_brand_empty: 'No matching brand.',
      brand_logo_status_missing_logo: 'No logo available to display in large format.',
      brand_logo_banner_intro: 'Brand logos: lookup is off to reduce requests. Click to run a one-time lookup.',
      brand_logo_banner_new_brand: 'New brands detected: rerun logo lookup if you want richer charts.',
      brand_logo_banner_enable: 'Enable now',
      brand_logo_banner_refresh: 'Run lookup again',
      brand_logo_banner_close: 'Dismiss',
      brand_logo_settings_hint: 'Database lookup is on-demand only (button).',
      group_logo_group_label: 'Target group',
      group_logo_url_label: 'Logo URL',
      group_logo_save_btn: 'Save logo',
      group_logo_clear_btn: 'Clear logo',
      group_logo_reset_btn: 'Reset default',
      group_logo_status_saved: 'Logo saved for {{group}}.',
      group_logo_status_cleared: 'Logo hidden for {{group}}.',
      group_logo_status_reset: 'Default logo restored for {{group}}.',
      group_logo_status_missing_group: 'Select a group first.',
      group_logo_status_missing_url: 'Enter a logo URL.',
      group_logo_preview_none: 'No active logo for this group.',
      group_logo_preview_default: 'Source: database',
      group_logo_preview_override: 'Source: custom logo',
      group_logo_preview_cleared: 'Logo hidden (clear active).',
      group_logo_preview_expand_btn: 'Enlarge',
      group_logo_preview_open_title: 'Open large logo',
      group_logo_group_placeholder: 'Select or type a group...',
      group_logo_group_toggle: 'Show group list',
      group_logo_group_empty: 'No matching group.',
      group_logo_status_missing_logo: 'No logo available to display in large format.',
      group_logo_settings_hint: 'You can customize one logo per product group.',
      settings_section_barcode_lookup: 'OFF / OPF API',
      barcode_lookup_provider_label: 'Primary provider (tried first)',
      barcode_lookup_provider_openfoodfacts: 'OFF (OpenFoodFacts)',
      barcode_lookup_provider_openproductsfacts: 'OPF (OpenProductsFacts)',
      barcode_lookup_provider_off: 'Disabled',
      barcode_lookup_provider_hint_openfoodfacts: 'OFF is tried first, then OPF as fallback when enabled.',
      barcode_lookup_provider_hint_openproductsfacts: 'OPF is tried first, then OFF as fallback when enabled.',
      barcode_lookup_provider_hint_off: 'Disables all OFF/OPF API requests.',
      barcode_lookup_enabled_label: 'Enable OFF/OPF API requests',
      barcode_lookup_enabled_hint: 'When disabled, no OFF/OPF call is sent.',
      barcode_lookup_auto_fallback_label: 'Auto-fallback to secondary provider',
      barcode_lookup_auto_fallback_hint: 'On error or empty result, automatically try the other provider.',
      barcode_lookup_status_saved: 'OFF/OPF settings saved: first {{provider}} | fallback {{fallback}} | API {{enabled}}.',
      barcode_lookup_enabled_yes: 'enabled',
      barcode_lookup_enabled_no: 'disabled',
      barcode_lookup_fallback_yes: 'enabled',
      barcode_lookup_fallback_no: 'disabled',
      facts_provider_disabled: 'OFF/OPF API is disabled in settings.',
      settings_section_facts_api_tests: 'OFF / OPF API tests',
      facts_api_test_hint: 'Quickly test API reachability for both providers.',
      facts_api_test_off_btn: 'Test OFF',
      facts_api_test_opf_btn: 'Test OPF',
      facts_api_test_active_btn: 'Test active order',
      facts_api_test_running: 'Testing {{provider}}...',
      facts_api_test_success: '{{provider}} OK (HTTP 200, {{count}} result(s), {{ms}} ms).',
      facts_api_test_error: '{{provider}} failed: {{msg}}.',
      facts_api_test_active_success: 'Active order validated: {{provider}} responded in {{ms}} ms.',
      facts_api_test_active_error: 'Active order failed: {{msg}}.',
      facts_provider_switch_note: 'Active order: {{order}}',
      settings_section_photo_search: 'Product photo search',
      photo_search_engine_label: 'Image search engine',
      photo_search_engine_google: 'Google Images',
      photo_search_engine_duckduckgo: 'DuckDuckGo Images',
      photo_search_engine_bing: 'Bing Images',
      photo_search_engine_hint_google: 'Image lookup via Google (images tab).',
      photo_search_engine_hint_duckduckgo: 'Image lookup via DuckDuckGo (images tab).',
      photo_search_engine_hint_bing: 'Image lookup via Bing Images.',
      photo_search_off_name_fallback_label: 'OFF/OPF: allow name fallback when barcode is not found',
      photo_search_status_saved: 'Photo settings saved.',
      photo_search_btn_png: 'PNG',
      photo_search_btn_jpg: 'JPG',
      photo_search_btn_off_title: 'Search on {{provider}}',
      photo_search_status_need_name: 'A product name is required.',
      photo_search_status_need_barcode: 'Barcode is required for {{provider}}.',
      photo_search_status_running_barcode: 'Searching {{provider}} by barcode...',
      photo_search_status_running_name: 'Barcode not found, trying {{provider}} by name...',
      photo_search_status_success_barcode: 'Opening {{provider}} via barcode {{barcode}}.',
      photo_search_status_success_name: 'Opening {{provider}} via product name.',
      photo_search_status_no_result_barcode: 'No {{provider}} product found for this barcode.',
      photo_search_status_no_result_name: 'No {{provider}} product found for this product name.',
      photo_search_status_api_error: '{{provider}} failed: {{msg}}.',
      photo_search_btn_facts_combined: 'Search OFF + OPF',
      photo_search_btn_facts_openfoodfacts: 'Search OFF',
      photo_search_btn_facts_openproductsfacts: 'Search OPF',
      photo_search_status_need_barcode_or_name: 'Barcode required, or enable name fallback.',
      photo_search_status_running_images: 'Searching photos via {{providers}}...',
      photo_search_status_images_found: '{{count}} photo(s) found.',
      photo_search_status_images_none: 'No photo found via {{providers}}.',
      photo_search_status_image_download_error: 'Unable to download image: {{msg}}.',
      photo_search_status_image_saving: 'Saving {{provider}} photo...',
      photo_search_status_image_saved: 'Photo saved from {{provider}}.',
      photo_search_status_image_pending_refresh: 'Photo selected from {{provider}}. Click refresh to update preview.',
      photo_search_status_image_refreshed: 'Photo preview refreshed.',
      photo_search_status_keep_current: 'Current image kept. Search results cleared.',
      photo_search_status_image_save_error: 'Photo save failed: {{msg}}.',
      photo_search_card_source: 'Source: {{provider}}',
      photo_search_card_source_current: 'Source: current image',
      photo_search_card_choose: 'Choose for product photo',
      photo_search_card_keep_current: 'Keep current image',
      photo_search_card_choose_title: 'Click to apply this image to the product',
      photo_search_btn_refresh_preview: 'Refresh photo',
      photo_search_btn_refresh_preview_title: 'Refresh preview with selected photo',
      photo_search_error_need_saved_product: 'Save the product first (missing ID) to auto-save the picture.',
      barcode_autofill_assist_name: 'Instant assistant',
      barcode_autofill_assist_on_title: 'Instant assistant enabled (auto search on open).',
      barcode_autofill_assist_off_title: 'Instant assistant disabled.',
      barcode_autofill_assist_auto_run: 'Instant assistant: automatic search started.',
      barcode_header_open_off_title: 'Open OFF (OpenFoodFacts) for this product',
      barcode_header_open_opf_title: 'Open OPF (OpenProductsFacts) for this product',
      barcode_header_google_title: 'Search on Google + active provider',
      barcode_header_robot_title: 'Auto-create barcode (OFF/OPF -> Grocy)',
      barcode_header_robot_need_product_id: 'Product ID not found on this page.',
      barcode_header_robot_need_unit: 'Purchase unit not found. Check "Default quantity unit purchase".',
      barcode_header_robot_running: 'Robot: searching…',
      barcode_header_robot_exists: 'Barcode {{code}} already exists on this product.',
      barcode_header_robot_created: 'Robot: barcode {{code}} created ({{unit}} x{{amount}}).',
      barcode_header_robot_api_error: 'Robot: error {{msg}}.',
      lang_applied_instant: 'Language applied instantly: {{lang}}.',
    },
  };

  const norm = (v) => (v || '').toString().normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase().trim();
  const clean = (v) => (v || '').toString().replace(/\s+/g, ' ').trim();

  function isNoDueSentinelDateValue(value) {
    if (!value) return false;
    if (typeof value === 'string') {
      const text = clean(value);
      const normalized = text.length >= 10 ? text.slice(0, 10) : text;
      return normalized === NO_DUE_SENTINEL_DATE;
    }
    try {
      const d = new Date(value);
      if (Number.isNaN(d.getTime())) return false;
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}` === NO_DUE_SENTINEL_DATE;
    } catch (_err) {
      return false;
    }
  }

  function normalizeDueDateValue(value) {
    if (!value) return null;
    if (isNoDueSentinelDateValue(value)) return null;
    try {
      const d = new Date(value);
      if (Number.isNaN(d.getTime())) return null;
      if (isNoDueSentinelDateValue(d)) return null;
      return d;
    } catch (_err) {
      return null;
    }
  }

  function normalizeUiLanguageMode(value) {
    const mode = clean(value).toLowerCase();
    if (mode === 'fr' || mode === 'en') return mode;
    return 'auto';
  }

  function normalizeDueDateDisplayFormat(value) {
    const mode = clean(value).toLowerCase();
    if (mode === 'ymd' || mode === 'dmy' || mode === 'mdy') return mode;
    return 'auto';
  }

  function normalizeQtyMode(value) {
    const mode = clean(value).toLowerCase();
    if (mode === 'mass' || mode === 'volume') return mode;
    return 'auto';
  }

  function normalizeAiValidationMode(value) {
    const mode = clean(value).toLowerCase();
    return mode === 'fallback_chain' ? 'fallback_chain' : 'single';
  }

  function detectAutomaticUiLanguage() {
    const candidates = [];
    try {
      if (Array.isArray(navigator.languages)) candidates.push(...navigator.languages);
      if (navigator.language) candidates.push(navigator.language);
    } catch (_err) {}
    try {
      const htmlLang = document?.documentElement?.lang;
      if (htmlLang) candidates.push(htmlLang);
    } catch (_err) {}

    const all = candidates.join(' ').toLowerCase();
    return all.includes('fr') ? 'fr' : 'en';
  }

  function resolveUiLanguage(settingsInput) {
    const settings = normalizeAiSettings(settingsInput || S.aiSettings || defaultAiSettings());
    const mode = normalizeUiLanguageMode(settings.uiLanguageMode);
    if (mode === 'fr' || mode === 'en') return mode;
    return detectAutomaticUiLanguage();
  }

  function languageName(code, targetLang = '') {
    const lang = targetLang || resolveUiLanguage();
    const normalized = code === 'fr' ? 'fr' : 'en';
    return normalized === 'fr'
      ? (lang === 'fr' ? UI_TEXT.fr.lang_name_fr : UI_TEXT.en.lang_name_fr)
      : (lang === 'fr' ? UI_TEXT.fr.lang_name_en : UI_TEXT.en.lang_name_en);
  }

  function t(key, params = {}, langInput = '') {
    const lang = langInput || resolveUiLanguage();
    const dict = UI_TEXT[lang] || UI_TEXT.fr;
    let text = dict[key] || UI_TEXT.fr[key] || key;
    if (params && typeof params === 'object') {
      Object.entries(params).forEach(([name, value]) => {
        text = text.replace(new RegExp(`\\{\\{\\s*${name}\\s*\\}\\}`, 'g'), String(value));
      });
    }
    return text;
  }

  function langText(frText, enText, langInput = '') {
    const lang = langInput || resolveUiLanguage();
    return lang === 'en' ? enText : frText;
  }

  function aiProviderIds() {
    return AI_PROVIDER_DEFS.map((def) => def.id);
  }

  function aiProviderDef(providerId) {
    return AI_PROVIDER_DEF_MAP.get(providerId) || AI_PROVIDER_DEFS[0];
  }

  function normalizeProviderId(value) {
    const text = clean(value);
    return AI_PROVIDER_DEF_MAP.has(text) ? text : 'gemini';
  }

  function aiProviderLabel(providerId) {
    const def = aiProviderDef(normalizeProviderId(providerId));
    return def ? def.label : 'IA';
  }

  function normalizeAiFocusMode(value) {
    const text = clean(value).toLowerCase();
    return AI_FOCUS_MODE_IDS.includes(text) ? text : 'eco';
  }

  function aiFocusModeDef(modeInput) {
    const id = normalizeAiFocusMode(modeInput);
    return AI_FOCUS_MODE_DEFS[id] || AI_FOCUS_MODE_DEFS.eco;
  }

  function buildDefaultProviderSettings() {
    const out = {};
    AI_PROVIDER_DEFS.forEach((def) => {
      out[def.id] = { ...(def.defaults || {}) };
    });
    return out;
  }

  function defaultAiSettings() {
    return {
      enabled: true,
      activeProvider: 'gemini',
      useFallback: false,
      fallbackProviders: ['openai', 'anthropic'],
      focusMode: 'eco',
      validationMode: 'single',
      uiLanguageMode: 'auto',
      dueDateDisplayFormat: 'auto',
      temperature: 0.25,
      timeoutMs: 18000,
      providers: buildDefaultProviderSettings(),
    };
  }

  function clamp(v, min, max) {
    if (!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, v));
  }

  function sanitizeAiProviderConfig(providerId, rawConfig) {
    const def = aiProviderDef(providerId);
    const defaults = (def && def.defaults) ? def.defaults : {};
    const source = rawConfig && typeof rawConfig === 'object' ? rawConfig : {};
    const out = {};

    Object.keys(defaults).forEach((key) => {
      const fallbackValue = defaults[key];
      const value = Object.prototype.hasOwnProperty.call(source, key) ? source[key] : fallbackValue;
      if (typeof fallbackValue === 'number') {
        const n = num(value);
        out[key] = Number.isFinite(n) ? n : fallbackValue;
      } else if (key === 'extraHeaders') {
        out[key] = String(value || '').trim();
      } else {
        out[key] = clean(value || '');
      }
    });

    return out;
  }

  function normalizeAiSettings(rawSettings) {
    const fallback = defaultAiSettings();
    const raw = rawSettings && typeof rawSettings === 'object' ? rawSettings : {};

    const providers = buildDefaultProviderSettings();
    const rawProviders = raw.providers && typeof raw.providers === 'object' ? raw.providers : {};
    aiProviderIds().forEach((providerId) => {
      let providerSource = rawProviders[providerId];
      if ((!providerSource || typeof providerSource !== 'object') && providerId === 'gemini') {
        if (Object.prototype.hasOwnProperty.call(raw, 'apiKey') || Object.prototype.hasOwnProperty.call(raw, 'model')) {
          providerSource = { apiKey: raw.apiKey, model: raw.model };
        }
      }
      providers[providerId] = sanitizeAiProviderConfig(providerId, providerSource);
    });

    const activeProvider = normalizeProviderId(raw.activeProvider || raw.provider || fallback.activeProvider);
    const fallbackInput = Array.isArray(raw.fallbackProviders) ? raw.fallbackProviders : fallback.fallbackProviders;
    const fallbackProviders = [];
    fallbackInput.forEach((entry) => {
      const id = normalizeProviderId(entry);
      if (!id || id === activeProvider) return;
      if (!fallbackProviders.includes(id)) fallbackProviders.push(id);
    });

    return {
      enabled: raw.enabled !== false,
      activeProvider,
      useFallback: raw.useFallback === true,
      fallbackProviders,
      focusMode: normalizeAiFocusMode(raw.focusMode || fallback.focusMode),
      validationMode: normalizeAiValidationMode(raw.validationMode || fallback.validationMode),
      uiLanguageMode: normalizeUiLanguageMode(raw.uiLanguageMode || fallback.uiLanguageMode),
      dueDateDisplayFormat: normalizeDueDateDisplayFormat(raw.dueDateDisplayFormat || fallback.dueDateDisplayFormat),
      temperature: clamp(num(Object.prototype.hasOwnProperty.call(raw, 'temperature') ? raw.temperature : fallback.temperature), 0, 1.2),
      timeoutMs: clamp(num(Object.prototype.hasOwnProperty.call(raw, 'timeoutMs') ? raw.timeoutMs : fallback.timeoutMs), 3000, 120000),
      providers,
    };
  }

  function loadAiSettings() {
    const fallback = defaultAiSettings();
    try {
      const raw = localStorage.getItem(AI_STORAGE_KEY);
      if (!raw) {
        S.aiSettings = fallback;
        return S.aiSettings;
      }
      const parsed = JSON.parse(raw);
      S.aiSettings = normalizeAiSettings(parsed);
      return S.aiSettings;
    } catch (_err) {
      S.aiSettings = fallback;
      return S.aiSettings;
    }
  }

  function saveAiSettings(nextSettings) {
    S.aiSettings = normalizeAiSettings(nextSettings || {});
    try {
      localStorage.setItem(AI_STORAGE_KEY, JSON.stringify(S.aiSettings));
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
    return S.aiSettings;
  }

  function normalizeBarcodeLookupProvider(value) {
    const provider = clean(value || '').toLowerCase();
    if (BARCODE_LOOKUP_PROVIDER_IDS.includes(provider)) return provider;
    return 'openfoodfacts';
  }

  function isLegacyBarcodeLookupDisabledValue(value) {
    const raw = clean(value || '').toLowerCase();
    return raw === 'off' || raw === 'disabled' || raw === 'none';
  }

  function alternateBarcodeLookupProvider(providerId) {
    return normalizeBarcodeLookupProvider(providerId) === 'openproductsfacts'
      ? 'openfoodfacts'
      : 'openproductsfacts';
  }

  function barcodeLookupProviderLabel(providerId, langInput = '') {
    const id = normalizeBarcodeLookupProvider(providerId);
    if (id === 'openproductsfacts') return t('barcode_lookup_provider_openproductsfacts', {}, langInput);
    return t('barcode_lookup_provider_openfoodfacts', {}, langInput);
  }

  function barcodeLookupProviderHint(providerId, langInput = '') {
    const id = normalizeBarcodeLookupProvider(providerId);
    if (id === 'openproductsfacts') return t('barcode_lookup_provider_hint_openproductsfacts', {}, langInput);
    return t('barcode_lookup_provider_hint_openfoodfacts', {}, langInput);
  }

  function defaultBarcodeLookupSettings() {
    return {
      provider: 'openfoodfacts',
      enabled: true,
      autoFallback: true,
    };
  }

  function normalizeBarcodeLookupSettings(rawSettings) {
    const fallback = defaultBarcodeLookupSettings();
    const raw = rawSettings && typeof rawSettings === 'object' ? rawSettings : {};
    const hasEnabled = Object.prototype.hasOwnProperty.call(raw, 'enabled');
    const hasFallback = Object.prototype.hasOwnProperty.call(raw, 'autoFallback');
    const legacyDisabled = isLegacyBarcodeLookupDisabledValue(raw.provider);
    const provider = legacyDisabled
      ? fallback.provider
      : normalizeBarcodeLookupProvider(raw.provider || fallback.provider);
    const enabled = hasEnabled ? boolish(raw.enabled) : !legacyDisabled;
    const autoFallback = hasFallback ? boolish(raw.autoFallback) : fallback.autoFallback;
    return {
      provider,
      enabled,
      autoFallback,
    };
  }

  function loadBarcodeLookupSettings() {
    const fallback = defaultBarcodeLookupSettings();
    try {
      const raw = localStorage.getItem(BARCODE_LOOKUP_SETTINGS_KEY);
      if (!raw) {
        S.barcodeLookupSettings = fallback;
        return S.barcodeLookupSettings;
      }
      const parsed = JSON.parse(raw);
      S.barcodeLookupSettings = normalizeBarcodeLookupSettings(parsed);
      return S.barcodeLookupSettings;
    } catch (_err) {
      S.barcodeLookupSettings = fallback;
      return S.barcodeLookupSettings;
    }
  }

  function saveBarcodeLookupSettings(nextSettings) {
    S.barcodeLookupSettings = normalizeBarcodeLookupSettings(nextSettings || {});
    try {
      localStorage.setItem(BARCODE_LOOKUP_SETTINGS_KEY, JSON.stringify(S.barcodeLookupSettings));
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
    return S.barcodeLookupSettings;
  }

  function barcodeLookupSettings() {
    return S.barcodeLookupSettings || loadBarcodeLookupSettings();
  }

  function defaultBarcodeAutofillUiSettings() {
    return {
      instantAssist: false,
    };
  }

  function normalizeBarcodeAutofillUiSettings(rawSettings) {
    const fallback = defaultBarcodeAutofillUiSettings();
    const raw = rawSettings && typeof rawSettings === 'object' ? rawSettings : {};
    return {
      instantAssist: boolish(raw.instantAssist),
    };
  }

  function loadBarcodeAutofillUiSettings() {
    const fallback = defaultBarcodeAutofillUiSettings();
    try {
      const raw = localStorage.getItem(BARCODE_AUTOFILL_UI_SETTINGS_KEY);
      if (!raw) {
        S.barcodeAutofillUiSettings = fallback;
        return S.barcodeAutofillUiSettings;
      }
      const parsed = JSON.parse(raw);
      S.barcodeAutofillUiSettings = normalizeBarcodeAutofillUiSettings(parsed);
      return S.barcodeAutofillUiSettings;
    } catch (_err) {
      S.barcodeAutofillUiSettings = fallback;
      return S.barcodeAutofillUiSettings;
    }
  }

  function saveBarcodeAutofillUiSettings(nextSettings) {
    S.barcodeAutofillUiSettings = normalizeBarcodeAutofillUiSettings(nextSettings || {});
    try {
      localStorage.setItem(BARCODE_AUTOFILL_UI_SETTINGS_KEY, JSON.stringify(S.barcodeAutofillUiSettings));
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
    return S.barcodeAutofillUiSettings;
  }

  function barcodeAutofillUiSettings() {
    return S.barcodeAutofillUiSettings || loadBarcodeAutofillUiSettings();
  }

  function barcodeLookupProviderOrder(settingsInput = null) {
    const settings = normalizeBarcodeLookupSettings(settingsInput || barcodeLookupSettings());
    const first = normalizeBarcodeLookupProvider(settings.provider);
    if (settings.autoFallback !== true) return [first];
    return [first, alternateBarcodeLookupProvider(first)];
  }

  function normalizePhotoSearchEngine(value) {
    const engine = clean(value || '').toLowerCase();
    return PHOTO_SEARCH_ENGINE_IDS.includes(engine) ? engine : 'google';
  }

  function photoSearchEngineLabel(engineId, langInput = '') {
    const id = normalizePhotoSearchEngine(engineId);
    if (id === 'duckduckgo') return t('photo_search_engine_duckduckgo', {}, langInput);
    if (id === 'bing') return t('photo_search_engine_bing', {}, langInput);
    return t('photo_search_engine_google', {}, langInput);
  }

  function photoSearchEngineHint(engineId, langInput = '') {
    const id = normalizePhotoSearchEngine(engineId);
    if (id === 'duckduckgo') return t('photo_search_engine_hint_duckduckgo', {}, langInput);
    if (id === 'bing') return t('photo_search_engine_hint_bing', {}, langInput);
    return t('photo_search_engine_hint_google', {}, langInput);
  }

  function defaultPhotoSearchSettings() {
    return {
      engine: 'google',
      offNameFallback: false,
    };
  }

  function normalizePhotoSearchSettings(rawSettings) {
    const fallback = defaultPhotoSearchSettings();
    const raw = rawSettings && typeof rawSettings === 'object' ? rawSettings : {};
    return {
      engine: normalizePhotoSearchEngine(raw.engine || fallback.engine),
      offNameFallback: boolish(raw.offNameFallback),
    };
  }

  function loadPhotoSearchSettings() {
    const fallback = defaultPhotoSearchSettings();
    try {
      const raw = localStorage.getItem(PHOTO_SEARCH_SETTINGS_KEY);
      if (!raw) {
        S.photoSearchSettings = fallback;
        return S.photoSearchSettings;
      }
      const parsed = JSON.parse(raw);
      S.photoSearchSettings = normalizePhotoSearchSettings(parsed);
      return S.photoSearchSettings;
    } catch (_err) {
      S.photoSearchSettings = fallback;
      return S.photoSearchSettings;
    }
  }

  function savePhotoSearchSettings(nextSettings) {
    S.photoSearchSettings = normalizePhotoSearchSettings(nextSettings || {});
    try {
      localStorage.setItem(PHOTO_SEARCH_SETTINGS_KEY, JSON.stringify(S.photoSearchSettings));
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
    return S.photoSearchSettings;
  }

  function photoSearchSettings() {
    return S.photoSearchSettings || loadPhotoSearchSettings();
  }

  function defaultPhotoSearchProgress() {
    return {
      pngClicked: false,
      jpgClicked: false,
    };
  }

  function normalizePhotoSearchProgress(rawValue) {
    const fallback = defaultPhotoSearchProgress();
    const raw = rawValue && typeof rawValue === 'object' ? rawValue : {};
    return {
      pngClicked: boolish(raw.pngClicked),
      jpgClicked: boolish(raw.jpgClicked),
    };
  }

  function loadPhotoSearchProgress() {
    try {
      const raw = localStorage.getItem(PHOTO_SEARCH_PROGRESS_KEY);
      if (!raw) {
        S.photoSearchProgress = defaultPhotoSearchProgress();
        return S.photoSearchProgress;
      }
      S.photoSearchProgress = normalizePhotoSearchProgress(JSON.parse(raw));
      return S.photoSearchProgress;
    } catch (_err) {
      S.photoSearchProgress = defaultPhotoSearchProgress();
      return S.photoSearchProgress;
    }
  }

  function savePhotoSearchProgress(nextValue) {
    S.photoSearchProgress = normalizePhotoSearchProgress(nextValue || {});
    try {
      localStorage.setItem(PHOTO_SEARCH_PROGRESS_KEY, JSON.stringify(S.photoSearchProgress));
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
    return S.photoSearchProgress;
  }

  function photoSearchProgress() {
    return S.photoSearchProgress || loadPhotoSearchProgress();
  }

  function loadAiCache(signature) {
    const sig = clean(signature || '');
    if (!sig) return false;
    try {
      const raw = localStorage.getItem(AI_CACHE_STORAGE_KEY);
      if (!raw) return false;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object' || parsed.signature !== sig || !Array.isArray(parsed.entries)) {
        return false;
      }
      S.aiCache = new Map(parsed.entries);
      S.aiCacheSignature = sig;
      return true;
    } catch (_err) {
      return false;
    }
  }

  function saveAiCache(signature) {
    const sig = clean(signature || '');
    if (!sig) return;
    const entries = Array.from(S.aiCache.entries()).slice(0, 80);
    try {
      localStorage.setItem(AI_CACHE_STORAGE_KEY, JSON.stringify({
        signature: sig,
        entries,
        savedAt: Date.now(),
      }));
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
  }

  function clearAiCache() {
    S.aiCache.clear();
    S.aiCacheSignature = '';
    try {
      localStorage.removeItem(AI_CACHE_STORAGE_KEY);
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
  }

  function aiProviderSettings(settingsInput, providerId) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const id = normalizeProviderId(providerId || settings.activeProvider);
    const current = settings.providers && settings.providers[id] ? settings.providers[id] : {};
    return sanitizeAiProviderConfig(id, current);
  }

  function aiProviderModelLabel(providerId, settingsInput) {
    const id = normalizeProviderId(providerId);
    const cfg = aiProviderSettings(settingsInput || aiSettings(), id);
    if (id === 'azure_openai') return clean(cfg.deployment || cfg.model || '');
    return clean(cfg.model || '');
  }

  function isAiProviderConfigured(settingsInput, providerId) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const id = normalizeProviderId(providerId || settings.activeProvider);
    const def = aiProviderDef(id);
    const cfg = aiProviderSettings(settings, id);

    const required = Array.isArray(def.required) ? def.required : [];
    for (const field of required) {
      if (!clean(cfg[field])) return false;
    }

    if (id === 'azure_openai') {
      const hasResource = !!clean(cfg.resource);
      const hasBaseUrl = !!clean(cfg.baseUrl);
      if (!hasResource && !hasBaseUrl) return false;
    }

    return true;
  }

  function activeAiProvider(settingsInput) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const id = normalizeProviderId(settings.activeProvider);
    return {
      id,
      def: aiProviderDef(id),
      config: aiProviderSettings(settings, id),
    };
  }

  function aiFocusPolicy(settingsInput, manual = false) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const modeId = normalizeAiFocusMode(settings.focusMode);
    const mode = aiFocusModeDef(modeId);
    const modeLabel = mode.id === 'performance'
      ? t('ai_mode_label_perf')
      : (mode.id === 'eco' ? t('ai_mode_label_eco') : t('ai_mode_label_cheapest'));
    const boundedTemperature = clamp(num(settings.temperature), 0, mode.temperatureCap);
    const boundedTimeout = Math.min(clamp(num(settings.timeoutMs), 3000, 120000), mode.timeoutMs);
    const allowFallback = manual ? mode.allowFallbackManual : mode.allowFallbackAuto;
    const maxOutputTokens = manual ? mode.manualMaxTokens : mode.autoMaxTokens;
    const autoAllowed = !manual ? mode.autoOnClick : true;

    return {
      id: mode.id,
      label: modeLabel,
      promptStyle: mode.promptStyle,
      autoAllowed,
      minIntervalMs: mode.minIntervalMs,
      maxAutoCallsPerOverlay: mode.maxAutoCallsPerOverlay,
      maxTotalCallsPerOverlay: mode.maxTotalCallsPerOverlay,
      temperature: boundedTemperature,
      timeoutMs: boundedTimeout,
      allowFallback,
      maxOutputTokens,
    };
  }

  function resetOverlayAiBudget() {
    S.aiOverlayAutoCalls = 0;
    S.aiOverlayTotalCalls = 0;
    S.aiOverlayLastCallAt = 0;
  }

  function chartDefaultLimit(chartId) {
    return Object.prototype.hasOwnProperty.call(CHART_DEFAULT_LIMITS, chartId) ? CHART_DEFAULT_LIMITS[chartId] : 0;
  }

  function chartSupportsLimit(chartId) {
    return chartDefaultLimit(chartId) > 0;
  }

  function chartTypeOptions(chartId) {
    const id = clean(chartId);
    if (!id) return [];
    if (id === 'risk') return ['donut', 'bar'];
    if (['g_val', 'g_qty', 'g_cal', 'brand_price', 'top_val', 'due'].includes(id)) return ['bar', 'donut'];
    if (id === 'brand_rel') return ['bubble', 'scatter'];
    if (id === 'price_val') return ['scatter', 'bubble'];
    return [];
  }

  function normalizeChartType(chartId, value) {
    const mode = clean(value).toLowerCase();
    const options = chartTypeOptions(chartId);
    if (!options.length) return '';
    if (options.includes(mode)) return mode;
    return options[0];
  }

  function chartSupportsIncludeZero(chartId) {
    return !['risk', 'due'].includes(chartId);
  }

  function chartSupportsQtyMode(chartId) {
    return clean(chartId) === 'g_qty';
  }

  function getChartPref(chartId) {
    const key = clean(chartId);
    if (!key) {
      return { sort: 'desc', limit: 0, includeZero: false, qtyMode: 'auto', chartType: '' };
    }

    const current = S.chartPrefs[key];
    if (!current) {
      const defaultType = normalizeChartType(key, '');
      const pref = {
        sort: 'desc',
        limit: chartDefaultLimit(key),
        includeZero: false,
        qtyMode: 'auto',
        chartType: defaultType,
      };
      S.chartPrefs[key] = pref;
      return pref;
    }

    current.sort = current.sort === 'asc' ? 'asc' : 'desc';
    current.limit = Number.isFinite(current.limit) && current.limit >= 0 ? Math.floor(current.limit) : chartDefaultLimit(key);
    current.includeZero = current.includeZero === true;
    current.qtyMode = normalizeQtyMode(current.qtyMode);
    current.chartType = normalizeChartType(key, current.chartType);
    return current;
  }

  function patchChartPref(chartId, patch) {
    const key = clean(chartId);
    const pref = getChartPref(key);
    if (patch && typeof patch === 'object') {
      if (Object.prototype.hasOwnProperty.call(patch, 'sort')) {
        pref.sort = patch.sort === 'asc' ? 'asc' : 'desc';
      }
      if (Object.prototype.hasOwnProperty.call(patch, 'limit')) {
        const limit = num(patch.limit);
        pref.limit = limit >= 0 ? Math.floor(limit) : chartDefaultLimit(key);
      }
      if (Object.prototype.hasOwnProperty.call(patch, 'includeZero')) {
        pref.includeZero = patch.includeZero === true;
      }
      if (Object.prototype.hasOwnProperty.call(patch, 'qtyMode')) {
        pref.qtyMode = normalizeQtyMode(patch.qtyMode);
      }
      if (Object.prototype.hasOwnProperty.call(patch, 'chartType')) {
        pref.chartType = normalizeChartType(key, patch.chartType);
      }
    }
    if (key) S.chartPrefs[key] = pref;
    scheduleUiStateSave();
    return pref;
  }

  function getOverlayLimitMode(chartId) {
    const key = clean(chartId);
    if (!key) return 'all';
    const current = S.overlayLimitModeByChart[key];
    return current === 'top' ? 'top' : 'all';
  }

  function setOverlayLimitMode(chartId, mode) {
    const key = clean(chartId);
    if (!key) return;
    S.overlayLimitModeByChart[key] = mode === 'top' ? 'top' : 'all';
    scheduleUiStateSave();
  }

  function overlayForceAllForChart(chartId) {
    if (!chartSupportsLimit(chartId)) return true;
    return getOverlayLimitMode(chartId) !== 'top';
  }

  function num(v) {
    if (typeof v === 'number' && Number.isFinite(v)) return v;
    let s = (v || '').toString().replace(/\u00a0/g, '').replace(/\s+/g, '').replace(/[^0-9,.-]/g, '');
    if (!s) return 0;
    if (s.includes(',') && s.includes('.')) {
      s = s.lastIndexOf(',') > s.lastIndexOf('.') ? s.replace(/\./g, '').replace(',', '.') : s.replace(/,/g, '');
    } else if (s.includes(',')) {
      s = s.replace(',', '.');
    }
    const n = Number(s);
    return Number.isFinite(n) ? n : 0;
  }

  const fmt = (v, d = 2) => (Number.isFinite(v) ? v : 0).toLocaleString(undefined, { minimumFractionDigits: d, maximumFractionDigits: d });
  const fmtMoney = (v, d = 2) => `${fmt(v, d)} €`;
  const currencySymbolForUi = () => (resolveUiLanguage() === 'en' ? '$' : '€');
  const fmtMoneyUi = (v, d = 2) => `${fmt(v, d)} ${currencySymbolForUi()}`;
  const fmtQty = (v, d = 2) => `${fmt(v, d)} ${t('unit_units')}`;
  const fmtProducts = (v, d = 0) => `${fmt(v, d)} ${t('unit_products')}`;
  const fmtBrands = (v, d = 0) => `${fmt(v, d)} ${t('unit_brands')}`;
  const fmtAlerts = (v, d = 0) => `${fmt(v, d)} ${t('unit_alerts')}`;
  const fmtKcal = (v, d = 0) => `${fmt(v, d)} kcal`;
  const fmtPercent = (v, d = 1) => `${fmt(v, d)} %`;
  const fmtDays = (v, d = 0) => `${fmt(v, d)} ${t('unit_days_short')}`;

  function cleanUnitLabel(value) {
    const text = clean(value || '');
    if (!text) return '';
    const banned = new Set(['stock', 'in stock', 'instock', 'amount', 'quantite', 'quantity']);
    if (banned.has(norm(text))) return '';
    return text;
  }

  function fmtQtyProduct(value, unitLabel, dec = 2) {
    const unit = cleanUnitLabel(unitLabel) || t('unit_units');
    return `${fmt(value, dec)} ${unit}`;
  }

  function unitFromFreeText(text) {
    const source = clean((text || '').replace(/\u00a0/g, ' '));
    if (!source) return '';

    let candidate = source
      .replace(/^[^0-9-+]*[-+]?\d[\d\s.,]*/u, '')
      .replace(/^[\s:;|/\\x×*.,-]+/u, '')
      .replace(/\(.*?\)/g, ' ')
      .trim();
    if (!candidate) return '';
    if (candidate.includes('|')) candidate = candidate.split('|')[0].trim();
    if (candidate.includes('\n')) candidate = candidate.split('\n')[0].trim();
    if (!candidate) return '';
    if (candidate.length > 32) return '';
    if (/\d/.test(candidate)) return '';
    return cleanUnitLabel(candidate);
  }

  function unitSuffixByMetricLabel(metricLabel) {
    const n = norm(metricLabel);
    if (!n) return '';
    if (n.includes('valeur') || n.includes('value')) return ' €';
    if (n.includes('prix') || n.includes('price')) return ' €';
    if (n.includes('quantite') || n.includes('quantity')) return ` ${t('unit_units')}`;
    if (n.includes('produit') || n.includes('product')) return ` ${t('unit_products')}`;
    if (n.includes('calor') || n.includes('kcal')) return ' kcal';
    return '';
  }

  function valueWithMetricUnit(value, metricLabel, dec = 2) {
    const suffix = unitSuffixByMetricLabel(metricLabel);
    return `${fmt(value, dec)}${suffix}`;
  }

  function qtyModeLabel(modeInput) {
    const mode = normalizeQtyMode(modeInput);
    if (mode === 'mass') return t('qty_mode_mass_label');
    if (mode === 'volume') return t('qty_mode_volume_label');
    return t('qty_mode_auto_label');
  }

  function qtyModeDisplayLabel(requestedInput, resolvedInput) {
    const requested = normalizeQtyMode(requestedInput);
    const resolved = normalizeQtyMode(resolvedInput);
    if (requested !== 'auto') return qtyModeLabel(requested);
    return `${qtyModeLabel('auto')} -> ${qtyModeLabel(resolved)}`;
  }

  function normalizedQuantityUnitText(unitLabel) {
    return norm(cleanUnitLabel(unitLabel || '')).replace(/[^a-z0-9]+/g, ' ').trim();
  }

  function unitTextHasAnyToken(unitText, tokens) {
    const text = clean(unitText || '');
    if (!text) return false;
    const padded = ` ${text} `;
    return tokens.some((token) => {
      const normalizedToken = clean(String(token || '').toLowerCase());
      if (!normalizedToken) return false;
      return padded.includes(` ${normalizedToken} `);
    });
  }

  function describeQuantityUnit(unitLabel) {
    const text = normalizedQuantityUnitText(unitLabel);
    if (!text) return { domain: '', factor: 0, raw: '' };

    if (unitTextHasAnyToken(text, ['kg', 'kgs', 'kilo', 'kilos', 'kilogram', 'kilograms', 'kilogramme', 'kilogrammes'])) {
      return { domain: 'mass', factor: 1000, raw: cleanUnitLabel(unitLabel || '') };
    }
    if (unitTextHasAnyToken(text, ['g', 'gr', 'gram', 'grams', 'gramme', 'grammes'])) {
      return { domain: 'mass', factor: 1, raw: cleanUnitLabel(unitLabel || '') };
    }
    if (unitTextHasAnyToken(text, ['mg', 'milligram', 'milligrams', 'milligramme', 'milligrammes'])) {
      return { domain: 'mass', factor: 0.001, raw: cleanUnitLabel(unitLabel || '') };
    }
    if (unitTextHasAnyToken(text, ['lb', 'lbs', 'livre', 'livres', 'pound', 'pounds'])) {
      return { domain: 'mass', factor: 453.59237, raw: cleanUnitLabel(unitLabel || '') };
    }
    if (unitTextHasAnyToken(text, ['oz', 'ounce', 'ounces', 'once', 'onces'])) {
      return { domain: 'mass', factor: 28.349523125, raw: cleanUnitLabel(unitLabel || '') };
    }

    if (unitTextHasAnyToken(text, ['ml', 'milliliter', 'milliliters', 'millilitre', 'millilitres'])) {
      return { domain: 'volume', factor: 1, raw: cleanUnitLabel(unitLabel || '') };
    }
    if (unitTextHasAnyToken(text, ['cl', 'centiliter', 'centiliters', 'centilitre', 'centilitres'])) {
      return { domain: 'volume', factor: 10, raw: cleanUnitLabel(unitLabel || '') };
    }
    if (unitTextHasAnyToken(text, ['dl', 'deciliter', 'deciliters', 'decilitre', 'decilitres'])) {
      return { domain: 'volume', factor: 100, raw: cleanUnitLabel(unitLabel || '') };
    }
    if (unitTextHasAnyToken(text, ['l', 'lt', 'lts', 'liter', 'liters', 'litre', 'litres', 'fl oz', 'fluid ounce', 'fluid ounces'])) {
      const factor = unitTextHasAnyToken(text, ['fl oz', 'fluid ounce', 'fluid ounces']) ? 29.5735295625 : 1000;
      return { domain: 'volume', factor, raw: cleanUnitLabel(unitLabel || '') };
    }

    if (unitTextHasAnyToken(text, [
      'u', 'unit', 'units', 'unite', 'unites', 'piece', 'pieces', 'pc', 'pcs', 'pce', 'ea', 'each',
      'item', 'items', 'gousse', 'gousses', 'clove', 'cloves', 'sachet', 'sachets', 'pack', 'packs',
      'paquet', 'paquets', 'bouteille', 'bouteilles', 'bottle', 'bottles', 'canette', 'canettes',
      'boite', 'boites', 'box', 'boxes', 'pot', 'pots', 'capsule', 'capsules', 'comprime', 'comprimes',
      'tablet', 'tablets', 'stick', 'sticks', 'tranche', 'tranches', 'slice', 'slices', 'rouleau', 'rouleaux',
      'feuille', 'feuilles',
    ])) {
      return { domain: 'count', factor: 1, raw: cleanUnitLabel(unitLabel || '') };
    }

    return { domain: '', factor: 0, raw: cleanUnitLabel(unitLabel || '') };
  }

  function quantityUnitIdsForLabel(unitLabelInput) {
    const index = S.apiQuantityUnitIdsByNorm instanceof Map ? S.apiQuantityUnitIdsByNorm : new Map();
    const normalized = norm(cleanUnitLabel(unitLabelInput || ''));
    if (!normalized || index.size === 0) return [];
    if (index.has(normalized)) return [...(index.get(normalized) || [])];
    if (normalized.length < 3) return [];

    const out = new Set();
    index.forEach((ids, key) => {
      if (!key) return;
      if (key.includes(normalized) || normalized.includes(key)) {
        (Array.isArray(ids) ? ids : []).forEach((id) => {
          const unitId = num(id);
          if (unitId > 0) out.add(unitId);
        });
      }
    });
    return Array.from(out).slice(0, 8);
  }

  function parseInlineQtyNumber(rawInput) {
    const text = clean(rawInput || '').replace(',', '.');
    if (!text) return 0;
    const value = Number(text);
    return Number.isFinite(value) ? value : 0;
  }

  function inlineQtyUnitInfo(tokenInput) {
    const token = clean(tokenInput || '').toLowerCase().replace(/\s+/g, '');
    if (!token) return null;
    if (token === 'kg') return { domain: 'mass', factor: 1000 };
    if (token === 'g') return { domain: 'mass', factor: 1 };
    if (token === 'mg') return { domain: 'mass', factor: 0.001 };
    if (token === 'l') return { domain: 'volume', factor: 1000 };
    if (token === 'dl') return { domain: 'volume', factor: 100 };
    if (token === 'cl') return { domain: 'volume', factor: 10 };
    if (token === 'ml') return { domain: 'volume', factor: 1 };
    return null;
  }

  function inferQtyCandidatesFromProductText(textInput) {
    const source = clean(textInput || '');
    if (!source) return [];
    const compact = source.toLowerCase();
    const out = [];

    const pushCandidate = (domain, factor, reason) => {
      const normalizedDomain = normalizeQtyMode(domain);
      const normalizedFactor = num(factor);
      if (!normalizedDomain || !(normalizedFactor > 0)) return;
      out.push({ domain: normalizedDomain, factor: normalizedFactor, reason: clean(reason || '') });
    };

    const multiPattern = /(\d+(?:[.,]\d+)?)\s*(?:x|×|\*)\s*(\d+(?:[.,]\d+)?)\s*(kg|g|mg|l|dl|cl|ml)\b/gi;
    let match = null;
    while ((match = multiPattern.exec(compact)) !== null) {
      const packs = parseInlineQtyNumber(match[1]);
      const unitAmount = parseInlineQtyNumber(match[2]);
      const unitInfo = inlineQtyUnitInfo(match[3]);
      if (!(packs > 0) || !(unitAmount > 0) || !unitInfo) continue;
      pushCandidate(unitInfo.domain, packs * unitAmount * unitInfo.factor, 'multipack');
    }

    const singlePattern = /(\d+(?:[.,]\d+)?)\s*(kg|g|mg|l|dl|cl|ml)\b/gi;
    while ((match = singlePattern.exec(compact)) !== null) {
      const amount = parseInlineQtyNumber(match[1]);
      const unitInfo = inlineQtyUnitInfo(match[2]);
      if (!(amount > 0) || !unitInfo) continue;
      pushCandidate(unitInfo.domain, amount * unitInfo.factor, 'single');
    }

    if (!out.length) return [];

    const bestByDomain = new Map();
    out.forEach((candidate) => {
      const key = candidate.domain;
      const current = bestByDomain.get(key);
      if (!current || num(candidate.factor) > num(current.factor)) {
        bestByDomain.set(key, candidate);
      }
    });

    return Array.from(bestByDomain.values());
  }

  function addQtyFactorCandidate(target, domainInput, factorInput, priorityInput = 0, pathLenInput = 0) {
    const domain = normalizeQtyMode(domainInput);
    if (!['mass', 'volume'].includes(domain)) return;
    const factor = num(factorInput);
    if (!Number.isFinite(factor) || !(factor > 0)) return;
    const priority = num(priorityInput);
    const pathLen = conversionPathLength(pathLenInput);
    const current = target[domain];
    if (!current) {
      target[domain] = { factor, priority, pathLen };
      return;
    }
    if (priority > current.priority) {
      target[domain] = { factor, priority, pathLen };
      return;
    }
    if (priority < current.priority) return;

    if (pathLen > 0 && (current.pathLen <= 0 || pathLen < current.pathLen)) {
      target[domain] = { factor, priority, pathLen };
      return;
    }
    if (pathLen > 0 && current.pathLen > 0 && pathLen === current.pathLen && Math.abs(Math.log10(factor)) < Math.abs(Math.log10(current.factor))) {
      target[domain] = { factor, priority, pathLen };
    }
  }

  function addQtyConversionCandidatesFromBucket(target, bucket, priority = 0) {
    if (!bucket || typeof bucket !== 'object') return;
    ['mass', 'volume'].forEach((domain) => {
      const candidate = bucket[domain];
      if (!candidate || typeof candidate !== 'object') return;
      addQtyFactorCandidate(target, domain, candidate.factor, priority, candidate.pathLen || 0);
    });
  }

  function normalizeManualQtyOverrideEntry(entryInput = null) {
    const entry = entryInput && typeof entryInput === 'object' ? entryInput : {};
    const mass = num(entry.mass);
    const volume = num(entry.volume);
    return {
      mass: mass > 0 ? mass : 0,
      volume: volume > 0 ? volume : 0,
      providerId: normalizeBarcodeLookupProvider(entry.providerId || ''),
      providerLabel: clean(entry.providerLabel || ''),
      basis: clean(entry.basis || ''),
      via: clean(entry.via || ''),
      updatedAt: num(entry.updatedAt) > 0 ? num(entry.updatedAt) : Date.now(),
    };
  }

  function loadQtyConversionOverrides() {
    const map = new Map();
    try {
      const raw = localStorage.getItem(QTY_CONVERSION_OVERRIDE_KEY);
      if (!raw) {
        S.manualQtyFactorByProductId = map;
        return map;
      }
      const parsed = JSON.parse(raw);
      const list = Array.isArray(parsed) ? parsed : [];
      list.forEach((entry) => {
        const productId = num(entry && entry.productId);
        if (!(productId > 0)) return;
        const normalized = normalizeManualQtyOverrideEntry(entry);
        if (!(normalized.mass > 0) && !(normalized.volume > 0)) return;
        map.set(productId, normalized);
      });
    } catch (_err) {
      // Ignore invalid localStorage payloads.
    }
    S.manualQtyFactorByProductId = map;
    return map;
  }

  function saveQtyConversionOverrides() {
    try {
      const payload = Array.from((S.manualQtyFactorByProductId instanceof Map ? S.manualQtyFactorByProductId : new Map()).entries())
        .map(([productIdInput, entryInput]) => {
          const productId = num(productIdInput);
          if (!(productId > 0)) return null;
          const entry = normalizeManualQtyOverrideEntry(entryInput);
          if (!(entry.mass > 0) && !(entry.volume > 0)) return null;
          return {
            productId,
            mass: entry.mass > 0 ? entry.mass : 0,
            volume: entry.volume > 0 ? entry.volume : 0,
            providerId: entry.providerId,
            providerLabel: entry.providerLabel,
            basis: entry.basis,
            via: entry.via,
            updatedAt: entry.updatedAt,
          };
        })
        .filter((row) => !!row);
      localStorage.setItem(QTY_CONVERSION_OVERRIDE_KEY, JSON.stringify(payload));
      return payload.length;
    } catch (_err) {
      return 0;
    }
  }

  function manualQtyOverrideForProduct(productIdInput = 0) {
    const productId = num(productIdInput);
    if (!(productId > 0)) return null;
    if (!(S.manualQtyFactorByProductId instanceof Map)) {
      S.manualQtyFactorByProductId = new Map();
    }
    const entry = S.manualQtyFactorByProductId.get(productId);
    if (!entry) return null;
    return normalizeManualQtyOverrideEntry(entry);
  }

  function setManualQtyOverrideForProduct(productIdInput = 0, domainInput = '', factorInput = 0, metaInput = null) {
    const productId = num(productIdInput);
    const domain = normalizeQtyMode(domainInput);
    const factor = num(factorInput);
    if (!(productId > 0)) return null;
    if (!['mass', 'volume'].includes(domain)) return null;
    if (!(factor > 0)) return null;

    const current = manualQtyOverrideForProduct(productId) || normalizeManualQtyOverrideEntry({});
    current[domain] = factor;
    const meta = metaInput && typeof metaInput === 'object' ? metaInput : {};
    current.providerId = normalizeBarcodeLookupProvider(meta.providerId || current.providerId || '');
    current.providerLabel = clean(meta.providerLabel || current.providerLabel || '');
    current.basis = clean(meta.basis || current.basis || '');
    current.via = clean(meta.via || current.via || '');
    current.updatedAt = Date.now();

    S.manualQtyFactorByProductId.set(productId, current);
    saveQtyConversionOverrides();
    return current;
  }

  function quantityFactorCandidatesForRow(rowInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const candidates = { mass: null, volume: null };
    const unitLabel = cleanUnitLabel(row.stockUnitName || '');
    const productName = clean(row.name || '');
    const productId = num(row.id);
    const stockUnitId = num(row.stockUnitId);

    const manualOverride = manualQtyOverrideForProduct(productId);
    if (manualOverride) {
      if (manualOverride.mass > 0) {
        addQtyFactorCandidate(candidates, 'mass', manualOverride.mass, 120, 1);
      }
      if (manualOverride.volume > 0) {
        addQtyFactorCandidate(candidates, 'volume', manualOverride.volume, 120, 1);
      }
    }

    const textInfo = describeQuantityUnit(unitLabel);
    if (textInfo.domain && textInfo.factor > 0) {
      addQtyFactorCandidate(candidates, textInfo.domain, textInfo.factor, 10, 0);
    }

    const idsFromLabel = quantityUnitIdsForLabel(unitLabel);
    const unitIdCandidates = new Set();
    if (stockUnitId > 0) unitIdCandidates.add(stockUnitId);
    idsFromLabel.forEach((id) => {
      const unitId = num(id);
      if (unitId > 0) unitIdCandidates.add(unitId);
    });

    unitIdCandidates.forEach((unitId) => {
      const unitName = cleanUnitLabel(S.apiQuantityUnitById.get(unitId) || '');
      const info = describeQuantityUnit(unitName);
      if (info.domain && info.factor > 0) {
        addQtyFactorCandidate(candidates, info.domain, info.factor, 20, 0);
      }
    });

    if (unitIdCandidates.size > 0) {
      const productMap = productId > 0 ? S.apiQuantityConversionsByProductId.get(productId) : null;
      unitIdCandidates.forEach((unitId) => {
        if (productMap instanceof Map) {
          addQtyConversionCandidatesFromBucket(candidates, productMap.get(unitId), 60);
        }
        addQtyConversionCandidatesFromBucket(candidates, S.apiQuantityConversionsGlobalByUnitId.get(unitId), 50);
      });
    }

    // Fallback: infer package quantity from product name (ex: "140g", "3x125g", "50cl").
    // This helps classify items even when API conversion rows are incomplete/missing.
    const inferAllowed = !textInfo.domain || textInfo.domain === 'count';
    if (inferAllowed && productName) {
      const inferred = inferQtyCandidatesFromProductText(productName);
      inferred.forEach((candidate) => {
        addQtyFactorCandidate(candidates, candidate.domain, candidate.factor, 45, 1);
      });
    }

    return {
      mass: candidates.mass ? num(candidates.mass.factor) : 0,
      volume: candidates.volume ? num(candidates.volume.factor) : 0,
    };
  }

  function chooseAutoQtyMode(preparedRows) {
    const stats = {
      mass: { count: 0, sum: 0 },
      volume: { count: 0, sum: 0 },
    };
    (Array.isArray(preparedRows) ? preparedRows : []).forEach((entry) => {
      const amount = num(entry && entry.amount);
      if (!(amount > 0)) return;
      const factors = entry && entry.factors && typeof entry.factors === 'object' ? entry.factors : {};
      Object.keys(stats).forEach((mode) => {
        const factor = num(factors[mode]);
        if (!(factor > 0)) return;
        stats[mode].count += 1;
        stats[mode].sum += Math.abs(amount * factor);
      });
    });

    const ranked = Object.entries(stats)
      .sort((a, b) => {
        if (b[1].count !== a[1].count) return b[1].count - a[1].count;
        return b[1].sum - a[1].sum;
      });
    if (ranked.length === 0 || ranked[0][1].count <= 0) return 'mass';
    return ranked[0][0];
  }

  function qtyScaleDecimals(maxValue, fallback = 2) {
    const n = Math.abs(num(maxValue));
    if (!Number.isFinite(n) || n <= 0) return fallback;
    if (n >= 100) return 0;
    if (n >= 10) return 1;
    return 2;
  }

  function qtyDisplaySpec(domainInput, maxBaseValue = 0) {
    const domain = normalizeQtyMode(domainInput);
    const maxBase = Math.abs(num(maxBaseValue));
    if (domain === 'mass') {
      if (maxBase >= 1000) {
        const maxDisplay = maxBase / 1000;
        return { domain: 'mass', divisor: 1000, unit: 'kg', decimals: qtyScaleDecimals(maxDisplay, 2) };
      }
      if (maxBase >= 1) {
        return { domain: 'mass', divisor: 1, unit: 'g', decimals: qtyScaleDecimals(maxBase, 1) };
      }
      const maxDisplay = maxBase * 1000;
      return { domain: 'mass', divisor: 0.001, unit: 'mg', decimals: qtyScaleDecimals(maxDisplay, 0) };
    }
    if (domain === 'volume') {
      if (maxBase >= 1000) {
        const maxDisplay = maxBase / 1000;
        return { domain: 'volume', divisor: 1000, unit: 'L', decimals: qtyScaleDecimals(maxDisplay, 2) };
      }
      return { domain: 'volume', divisor: 1, unit: 'ml', decimals: qtyScaleDecimals(maxBase, 0) };
    }
    return { domain: 'mass', divisor: 1, unit: 'g', decimals: qtyScaleDecimals(maxBase, 1) };
  }

  function fmtQtyWithDisplay(value, displaySpec, dec = null) {
    const n = num(value);
    const spec = displaySpec && typeof displaySpec === 'object' ? displaySpec : null;
    if (!spec) return fmtQty(n, Number.isFinite(dec) ? dec : 2);
    const decimals = Number.isFinite(dec) ? dec : (Number.isFinite(spec.decimals) ? spec.decimals : 2);
    return `${fmt(n, decimals)} ${clean(spec.unit || t('unit_units'))}`;
  }

  function fmtQtyWithCurrentMode(value, dec = null) {
    return fmtQtyWithDisplay(value, S.lastGroupQtyState ? S.lastGroupQtyState.displaySpec : null, dec);
  }

  function fmtQtyByChart(chartId, value, dec = null) {
    if (clean(chartId) === 'g_qty') return fmtQtyWithCurrentMode(value, dec);
    return fmtQty(num(value), Number.isFinite(dec) ? dec : 2);
  }

  function buildGroupQtyState(rowsInput, chartId = 'g_qty') {
    const rows = Array.isArray(rowsInput) ? rowsInput : [];
    const pref = getChartPref(chartId);
    const requestedMode = normalizeQtyMode(pref.qtyMode);
    const prepared = rows.map((row) => {
      const amount = num(row && row.amount);
      const unitLabel = cleanUnitLabel(row && row.stockUnitName ? row.stockUnitName : '');
      return {
        row,
        amount,
        unitLabel,
        factors: quantityFactorCandidatesForRow(row),
      };
    });

    const resolvedMode = requestedMode === 'auto' ? chooseAutoQtyMode(prepared) : requestedMode;
    const byGroupBase = new Map();
    const byProductBase = [];
    const unclassified = [];

    prepared.forEach((entry) => {
      const row = entry.row || {};
      const amount = num(entry.amount);
      if (!Number.isFinite(amount) || amount < 0) return;
      if (!pref.includeZero && amount <= 0) return;

      const group = clean(row.group || '') || defaultNoGroupLabel();
      const productName = clean(row.name || '') || `${t('default_product')} ${fmt(num(row.id), 0)}`;
      const unitLabel = clean(entry.unitLabel || '');
      const factors = entry.factors && typeof entry.factors === 'object' ? entry.factors : {};
      const factor = num(factors[resolvedMode]);

      if (amount === 0 && factor > 0) {
        if (!byGroupBase.has(group)) byGroupBase.set(group, 0);
        return;
      }

      if (amount > 0 && factor > 0) {
        const amountBase = amount * factor;
        add(byGroupBase, group, amountBase);
        byProductBase.push({
          id: num(row.id),
          name: productName,
          group,
          stockUnitName: unitLabel,
          amountRaw: amount,
          amountBase,
        });
        return;
      }

      if (amount > 0) {
        unclassified.push({
          id: num(row.id),
          name: productName,
          qtyText: fmtQtyProduct(amount, unitLabel || t('unit_units')),
          unitLabel: unitLabel || t('default_na'),
          stockUnitName: unitLabel || t('unit_units'),
          stockUnitId: num(row.stockUnitId),
          isParent: boolish(row.isParent),
        });
      }
    });

    const maxGroupBase = Array.from(byGroupBase.values()).reduce((acc, value) => Math.max(acc, Math.abs(num(value))), 0);
    const maxProductBase = byProductBase.reduce((acc, item) => Math.max(acc, Math.abs(num(item && item.amountBase))), 0);
    const maxBase = Math.max(maxGroupBase, maxProductBase);
    const displaySpec = qtyDisplaySpec(resolvedMode, maxBase);
    const byGroupDisplay = new Map();
    const divisor = num(displaySpec.divisor || 1) || 1;
    byGroupBase.forEach((value, group) => {
      byGroupDisplay.set(group, num(value) / divisor);
    });
    const totalBase = Array.from(byGroupBase.values()).reduce((sum, value) => sum + num(value), 0);
    const totalDisplay = totalBase / divisor;
    const byProductDisplay = byProductBase.map((item) => ({
      ...item,
      amountDisplay: num(item.amountBase) / divisor,
    }));

    const modeLabel = qtyModeDisplayLabel(requestedMode, resolvedMode);
    return {
      requestedMode,
      resolvedMode,
      modeLabel,
      displaySpec,
      byGroupBase,
      byGroupDisplay,
      totalBase,
      totalDisplay,
      byProductBase,
      byProductDisplay,
      unclassified,
      unitBadgeText: t('chart_qty_unit_badge', { unit: displaySpec.unit, mode: modeLabel }),
    };
  }

  function groupQtyEntries(state, forceAll = false, chartId = 'g_qty') {
    const map = state && state.byGroupDisplay instanceof Map ? state.byGroupDisplay : new Map();
    return applyPairLimit(mapPairs(map), chartDefaultLimit(chartId), true, forceAll, chartId);
  }

  function groupQtyUnclassifiedHtml(state, maxItems = 8) {
    const current = state && typeof state === 'object' ? state : null;
    const items = current && Array.isArray(current.unclassified) ? current.unclassified : [];
    const title = t('chart_qty_unclassified_title');
    const badge = clean(current && current.unitBadgeText ? current.unitBadgeText : '');

    if (items.length === 0) {
      return `
        <div class="dash-qty-unclassified">
          <div class="dash-qty-unclassified-head">${escapeHtml(title)}</div>
          ${badge ? `<div class="dash-qty-unclassified-mode">${escapeHtml(badge)}</div>` : ''}
          <div class="text-muted">${escapeHtml(t('chart_qty_unclassified_none'))}</div>
        </div>
      `;
    }

    const rows = items.slice(0, Math.max(1, maxItems)).map((item) => {
      const productId = num(item && item.id);
      const canLink = productId > 0 && boolish(item && item.isParent) !== true;
      const actionHtml = canLink
        ? `<button
            type="button"
            class="dash-qty-unclassified-action"
            data-qty-convert-link="1"
            data-product-id="${escapeHtml(String(productId))}"
            title="${escapeHtml(t('chart_qty_unclassified_fix_link_title'))}"
          >${escapeHtml(t('chart_qty_unclassified_fix_link'))}</button>`
        : '';
      return `
        <li class="dash-qty-unclassified-item">
          <span class="dash-qty-unclassified-name">${escapeHtml(item.name || t('default_product'))}</span>
          ${actionHtml}
          <span class="dash-qty-unclassified-meta">${escapeHtml(item.qtyText || item.unitLabel || t('default_na'))}</span>
        </li>
      `;
    }).join('');
    const more = items.length > maxItems
      ? `<li class="dash-qty-unclassified-more">${escapeHtml(t('chart_qty_unclassified_more', { count: fmt(items.length - maxItems, 0) }))}</li>`
      : '';

    return `
      <div class="dash-qty-unclassified">
        <div class="dash-qty-unclassified-head">${escapeHtml(title)}</div>
        ${badge ? `<div class="dash-qty-unclassified-mode">${escapeHtml(badge)}</div>` : ''}
        <ul class="dash-qty-unclassified-list mb-0">
          ${rows}
          ${more}
        </ul>
      </div>
    `;
  }

  function renderGroupQtyUnclassified(state) {
    const host = document.getElementById('g_qty_unclassified');
    if (!host) return;
    if (!state) {
      host.innerHTML = '';
      return;
    }
    host.innerHTML = groupQtyUnclassifiedHtml(state, 7);
  }

  function isNoGroupLabel(value) {
    const n = norm(value);
    return n === 'sans groupe' || n === 'no group';
  }

  function isNoBrandLabel(value) {
    const n = norm(value);
    return n === 'sans marque' || n === 'no brand';
  }

  function defaultNoGroupLabel() {
    return t('default_no_group');
  }

  function defaultNoBrandLabel() {
    return t('default_no_brand');
  }

  function add(map, k, v) {
    const key = clean(k || '') || defaultNoGroupLabel();
    map.set(key, num(map.get(key) || 0) + num(v));
  }

  function findGroup(select, tokens) {
    for (const o of Array.from(select.options)) {
      if (!o.value || o.value === 'all') continue;
      const t = norm(o.textContent);
      if (tokens.some((x) => t.includes(x))) return { value: o.value, label: clean(o.textContent), key: t };
    }
    return null;
  }

  function findGroupByPriority(select, strictTokens, fallbackTokens) {
    const options = Array.from(select.options).filter((o) => o.value && o.value !== 'all');
    for (const option of options) {
      const t = norm(option.textContent);
      if (strictTokens.some((token) => t.includes(token))) {
        return { value: option.value, label: clean(option.textContent), key: t };
      }
    }
    return findGroup(select, fallbackTokens);
  }

  function dt() {
    if (S.dt) return S.dt;
    if (!window.jQuery || !window.jQuery.fn || !window.jQuery.fn.dataTable) return null;
    const $ = window.jQuery;
    if (!$.fn.dataTable.isDataTable('#stock-overview-table')) return null;
    S.dt = $('#stock-overview-table').DataTable();
    return S.dt;
  }

  function setActive(id) {
    if (!S.tabs) return;
    Object.entries(S.tabs).forEach(([k, el]) => {
      const on = k === id;
      el.classList.toggle('active', on);
      el.setAttribute('aria-selected', String(on));
    });
  }

  function registerFoodFilter() {
    if (S.foodFilterRegistered || !window.jQuery || !window.jQuery.fn || !window.jQuery.fn.dataTable) return;
    const $ = window.jQuery;
    $.fn.dataTable.ext.search.push((settings, data) => {
      if (!settings.nTable || settings.nTable.id !== 'stock-overview-table') return true;
      if (S.active !== 'food') return true;
      const g = norm((data[2] || '').replace(/<[^>]*>/g, ''));
      return !g || !S.excludedFood.has(g);
    });
    S.foodFilterRegistered = true;
  }

  function normalizeFacetType(value) {
    const type = clean(value).toLowerCase();
    if (type === 'brand' || type === 'group') return type;
    return '';
  }

  function setRowMetaForProduct(row) {
    const id = num(row && row.id);
    if (id <= 0) return null;
    const group = clean(row && row.group ? row.group : defaultNoGroupLabel()) || defaultNoGroupLabel();
    const brand = clean(row && row.brand ? row.brand : defaultNoBrandLabel()) || defaultNoBrandLabel();
    const isParent = boolish(row && row.isParent);
    const meta = {
      group,
      groupNorm: norm(group),
      brand,
      brandNorm: norm(brand),
      isParent,
    };
    S.rowMetaByProductId.set(id, meta);
    return meta;
  }

  function rebuildRowMetaIndex(rows) {
    const map = new Map();
    (Array.isArray(rows) ? rows : []).forEach((row) => {
      const id = num(row && row.id);
      if (id <= 0) return;
      const group = clean(row && row.group ? row.group : defaultNoGroupLabel()) || defaultNoGroupLabel();
      const brand = clean(row && row.brand ? row.brand : defaultNoBrandLabel()) || defaultNoBrandLabel();
      const isParent = boolish(row && row.isParent);
      map.set(id, {
        group,
        groupNorm: norm(group),
        brand,
        brandNorm: norm(brand),
        isParent,
      });
    });
    S.rowMetaByProductId = map;
  }

  function rowMetaForProduct(productId, fallbackRowNode = null) {
    const id = num(productId);
    if (id <= 0) return null;

    const cached = S.rowMetaByProductId.get(id);
    if (cached) return cached;

    const knownRow = findProductRowById(id);
    if (knownRow) return setRowMetaForProduct(knownRow);

    if (fallbackRowNode) {
      const parsed = parseRow(fallbackRowNode, 0, getColumnMap());
      if (parsed) return setRowMetaForProduct(parsed);
    }
    return null;
  }

  function rowMatchesActiveFacet(meta) {
    if (!S.stockFacetType || !S.stockFacetValueNorm) return true;
    if (!meta) return false;
    if (S.stockFacetType === 'brand') return norm(meta.brand || '') === S.stockFacetValueNorm;
    if (S.stockFacetType === 'group') return norm(meta.group || '') === S.stockFacetValueNorm;
    return true;
  }

  function registerFacetFilter() {
    if (S.facetFilterRegistered || !window.jQuery || !window.jQuery.fn || !window.jQuery.fn.dataTable) return;
    const $ = window.jQuery;
    $.fn.dataTable.ext.search.push((settings, _data, dataIndex) => {
      if (!settings.nTable || settings.nTable.id !== 'stock-overview-table') return true;
      if (!S.stockFacetType || !S.stockFacetValueNorm) return true;

      const rowNode = settings.aoData && settings.aoData[dataIndex] ? settings.aoData[dataIndex].nTr : null;
      const productId = rowProductId(rowNode);
      if (productId <= 0) return true;

      const meta = rowMetaForProduct(productId, rowNode);
      return rowMatchesActiveFacet(meta);
    });
    S.facetFilterRegistered = true;
  }

  function clearStockFacetFilter(redraw = true) {
    const hadFacet = !!S.stockFacetType;
    S.stockFacetType = '';
    S.stockFacetValue = '';
    S.stockFacetValueNorm = '';
    if (!redraw || !hadFacet) return;
    const d = dt();
    if (d) d.draw();
    scheduleRender();
  }

  function setDashboardCollapsed(collapsed, options = {}) {
    const body = document.getElementById('dash_body');
    const toggle = document.getElementById('dash_toggle');
    const normalized = collapsed === true;
    if (!body || !toggle) {
      S.dashboardOpen = !normalized;
      return;
    }

    body.classList.toggle('d-none', normalized);
    S.dashboardOpen = !normalized;
    toggle.innerHTML = normalized
      ? `<i class="fa-solid fa-chevron-down"></i> ${t('dash_show')}`
      : `<i class="fa-solid fa-chevron-up"></i> ${t('dash_hide')}`;

    if (normalized) {
      clearCharts();
      hideChartHoverPreview();
      closeChartOverlay();
      scheduleUiStateSave();
      return;
    }

    if (options && options.ensureReady === true) {
      ensureDashboardReady(false).finally(() => {
        scheduleRender();
      });
    } else {
      scheduleRender();
    }
    scheduleUiStateSave();
  }

  function openStockFacetView(type, value) {
    const facetType = normalizeFacetType(type);
    const facetValue = clean(value || '');
    if (!facetType || !facetValue) return;

    registerFacetFilter();
    S.stockFacetType = facetType;
    S.stockFacetValue = facetValue;
    S.stockFacetValueNorm = norm(facetValue);

    const searchInput = document.getElementById('search');
    const groupFilter = document.getElementById('product-group-filter');
    const statusFilter = document.getElementById('status-filter');

    S.applying = true;
    if (searchInput && searchInput.value) {
      searchInput.value = '';
      searchInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
    if (groupFilter && groupFilter.value !== 'all') {
      groupFilter.value = 'all';
      groupFilter.dispatchEvent(new Event('change', { bubbles: true }));
    }
    if (statusFilter && statusFilter.value !== 'all') {
      statusFilter.value = 'all';
      statusFilter.dispatchEvent(new Event('change', { bubbles: true }));
    }
    S.applying = false;

    S.active = 'all';
    setActive('all');
    closeChartOverlay();
    // On targeted stock views (brand/category), collapse analytics to keep results focused.
    setDashboardCollapsed(true);

    const d = dt();
    if (d) {
      d.search('');
      d.draw();
    }
    scheduleRender();
  }

  function setFilters(groupFilter, statusFilter, g, s) {
    if (groupFilter.value !== g) {
      groupFilter.value = g;
      groupFilter.dispatchEvent(new Event('change', { bubbles: true }));
    }
    if (statusFilter.value !== s) {
      statusFilter.value = s;
      statusFilter.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }

  function scheduleRender() {
    clearTimeout(S.timer);
    S.timer = setTimeout(renderDashboard, 220);
  }

  function computeDataSignature(rows) {
    const list = Array.isArray(rows) ? rows : [];
    let valueSum = 0;
    let amountSum = 0;
    let calSum = 0;
    let maxDue = 0;
    let withDue = 0;
    let withBrand = 0;
    const groups = new Set();
    list.forEach((row) => {
      valueSum += num(row.value);
      amountSum += num(row.amount);
      calSum += num(row.calories);
      if (row.due && row.due instanceof Date) {
        const t = row.due.getTime();
        if (!Number.isNaN(t)) {
          maxDue = Math.max(maxDue, t);
          withDue += 1;
        }
      }
      const brand = clean(row.brand || '');
      if (brand && !isNoBrandLabel(brand)) withBrand += 1;
      groups.add(clean(row.group || defaultNoGroupLabel()));
    });
    return [
      list.length,
      fmt(valueSum, 2),
      fmt(amountSum, 3),
      fmt(calSum, 2),
      maxDue,
      withDue,
      withBrand,
      groups.size,
    ].join('|');
  }

  function syncAiCacheOnRender(signature, signatureMatches) {
    const sig = clean(signature || '');
    if (!sig) return;
    if (!signatureMatches) clearAiCache();
    if (S.aiCacheSignature !== sig) {
      loadAiCache(sig);
      S.aiCacheSignature = sig;
    }
  }

  function syncDashboardViewButtons() {
    const statsBtn = document.getElementById('dash_view_stats');
    const rankBtn = document.getElementById('dash_view_rankings');
    if (statsBtn) statsBtn.classList.toggle('active', S.dashboardView === 'stats');
    if (rankBtn) rankBtn.classList.toggle('active', S.dashboardView === 'rankings');
  }

  function setDashboardView(viewMode) {
    S.dashboardView = viewMode === 'rankings' ? 'rankings' : 'stats';
    const body = document.getElementById('dash_body');
    const chartsSection = document.getElementById('dash_section_charts');
    const rankingsSection = document.getElementById('dash_section_rankings');
    if (body) {
      body.classList.toggle('dash-view-rankings', S.dashboardView === 'rankings');
      body.classList.toggle('dash-view-stats', S.dashboardView !== 'rankings');
    }
    if (chartsSection) chartsSection.classList.toggle('d-none', S.dashboardView !== 'stats');
    if (rankingsSection) rankingsSection.classList.toggle('d-none', S.dashboardView !== 'rankings');
    syncDashboardViewButtons();
    scheduleUiStateSave();
  }

  function initTabs() {
    const table = document.getElementById('stock-overview-table');
    const row = document.getElementById('table-filter-row');
    const groupFilter = document.getElementById('product-group-filter');
    const statusFilter = document.getElementById('status-filter');
    if (!table || !row || !groupFilter || !statusFilter || document.getElementById('stock-overview-custom-tabs')) return;

    const med = findGroup(groupFilter, ['medicament', 'medication', 'medicine', 'drug', 'pharma']);
    const hyg = findGroup(groupFilter, ['hygiene', 'soin personnel', 'soins personnels', 'personal care']);
    const house = findGroupByPriority(
      groupFilter,
      ['entretien & maison', 'entretien et maison', 'entretien'],
      ['house', 'clean']
    );

    S.excludedFood = new Set();
    [med, hyg, house].forEach((g) => { if (g && g.key) S.excludedFood.add(g.key); });
    S.groupOptionsByNorm = new Map();
    Array.from(groupFilter.options)
      .filter((o) => o.value && o.value !== 'all')
      .forEach((o) => S.groupOptionsByNorm.set(norm(o.textContent), clean(o.textContent)));
    registerFoodFilter();
    registerFacetFilter();

    const allLabel = clean(groupFilter.querySelector('option[value="all"]')?.textContent || (resolveUiLanguage() === 'fr' ? 'Tout' : 'All'));
    const html = `
      <div class="col">
        <ul class="nav nav-tabs grocy-tabs flex-wrap">
          <li class="nav-item"><a id="tab_all" class="nav-link active" href="#">${allLabel}</a></li>
          <li class="nav-item"><a id="tab_food" class="nav-link" href="#">${t('tab_food')}</a></li>
          <li class="nav-item"><a id="tab_med" class="nav-link" href="#">${med?.label || t('tab_meds_default')}</a></li>
          <li class="nav-item"><a id="tab_hyg" class="nav-link" href="#">${hyg?.label || t('tab_hyg_default')}</a></li>
          <li class="nav-item"><a id="tab_house" class="nav-link" href="#">${house?.label || t('tab_home_default')}</a></li>
        </ul>
      </div>`;

    const tabsRow = document.createElement('div');
    tabsRow.className = 'row mt-2';
    tabsRow.id = 'stock-overview-custom-tabs';
    tabsRow.innerHTML = html;
    row.parentNode.insertBefore(tabsRow, row);

    S.tabs = {
      all: document.getElementById('tab_all'),
      food: document.getElementById('tab_food'),
      med: document.getElementById('tab_med'),
      hyg: document.getElementById('tab_hyg'),
      house: document.getElementById('tab_house'),
    };

    if (!med) { S.tabs.med.classList.add('disabled'); S.tabs.med.setAttribute('aria-disabled', 'true'); }
    if (!hyg) { S.tabs.hyg.classList.add('disabled'); S.tabs.hyg.setAttribute('aria-disabled', 'true'); }
    if (!house) { S.tabs.house.classList.add('disabled'); S.tabs.house.setAttribute('aria-disabled', 'true'); }

    function apply(cat) {
      S.active = cat;
      setActive(cat);
      S.applying = true;
      if (cat === 'all' || cat === 'food') setFilters(groupFilter, statusFilter, 'all', 'all');
      else if (cat === 'med' && med) setFilters(groupFilter, statusFilter, med.value, 'all');
      else if (cat === 'hyg' && hyg) setFilters(groupFilter, statusFilter, hyg.value, 'all');
      else if (cat === 'house' && house) setFilters(groupFilter, statusFilter, house.value, 'all');
      S.applying = false;
      const d = dt();
      if (d) d.draw();
      scheduleRender();
    }

    function onManualChange() {
      if (S.applying) return;
      S.active = 'all';
      setActive('all');
      const d = dt();
      if (d) d.draw();
      scheduleRender();
    }

    S.tabs.all.addEventListener('click', (e) => { e.preventDefault(); apply('all'); });
    S.tabs.food.addEventListener('click', (e) => { e.preventDefault(); apply('food'); });
    S.tabs.med.addEventListener('click', (e) => { e.preventDefault(); if (!S.tabs.med.classList.contains('disabled')) apply('med'); });
    S.tabs.hyg.addEventListener('click', (e) => { e.preventDefault(); if (!S.tabs.hyg.classList.contains('disabled')) apply('hyg'); });
    S.tabs.house.addEventListener('click', (e) => { e.preventDefault(); if (!S.tabs.house.classList.contains('disabled')) apply('house'); });

    groupFilter.addEventListener('change', onManualChange);
    statusFilter.addEventListener('change', onManualChange);
  }

  function initDashboard() {
    const table = document.getElementById('stock-overview-table');
    if (!table || document.getElementById('stock-analytics-dashboard')) return;
    initDashboardStyles();

    const row = table.closest('.row');
    if (!row) return;

    const block = document.createElement('div');
    block.className = 'row mt-3';
    block.id = 'stock-analytics-dashboard';
    block.innerHTML = `
      <div class="col">
        <div class="card">
          <div class="card-header d-flex justify-content-between align-items-center flex-wrap">
            <div class="font-weight-bold"><i class="fa-solid fa-chart-line"></i> ${t('dash_title')}</div>
            <div class="d-flex align-items-center flex-wrap mt-2 mt-sm-0">
              <div class="btn-group btn-group-sm mr-2">
                <button id="dash_view_stats" class="btn btn-outline-secondary" type="button">${t('dash_view_stats')}</button>
                <button id="dash_view_rankings" class="btn btn-outline-secondary" type="button">${t('dash_view_rankings')}</button>
              </div>
              <div class="btn-group btn-group-sm">
                <button id="dash_refresh" class="btn btn-outline-secondary" type="button"><i class="fa-solid fa-rotate"></i> ${t('dash_refresh')}</button>
                <button id="dash_toggle" class="btn btn-outline-secondary" type="button"><i class="fa-solid fa-chevron-down"></i> ${t('dash_show')}</button>
              </div>
              <div class="btn-group btn-group-sm ml-2">
                <button id="dash_ai_settings_open" class="btn btn-outline-secondary" type="button" title="${t('ai_settings_title')}">
                  <i class="fa-solid fa-gear"></i>
                </button>
              </div>
            </div>
          </div>
          <div id="dash_body" class="card-body d-none dash-view-stats">
            <div id="dash_sections_root" class="d-flex flex-column">
            <section id="dash_section_charts">
            <p id="dash_context" class="text-muted mb-2">${t('dash_context_default')}</p>
            <div id="dash_brand_logo_banner_host" class="mb-2"></div>
            <div id="dash_addon_compat_banner_host" class="mb-2 d-none"></div>

            <div class="row">
              <div class="col-6 col-lg-2 mb-2"><div class="border rounded p-2 h-100"><div class="small text-muted">${t('kpi_products')}</div><div id="k_products" class="h5 mb-0">0</div></div></div>
              <div class="col-6 col-lg-2 mb-2">
                <div class="border rounded p-2 h-100 dash-kpi-card dash-kpi-card-fun" id="k_value_card">
                  <div class="small text-muted">${t('kpi_total_value')}</div>
                  <div id="k_value" class="h5 mb-0">0</div>
                </div>
              </div>
              <div class="col-6 col-lg-2 mb-2"><div class="border rounded p-2 h-100"><div class="small text-muted">${t('kpi_avg_price')}</div><div id="k_price" class="h5 mb-0">0</div></div></div>
              <div class="col-6 col-lg-2 mb-2">
                <div class="border rounded p-2 h-100 dash-kpi-card dash-kpi-card-fun" id="k_cal_card">
                  <div class="small text-muted">${t('kpi_calories')}</div>
                  <div id="k_cal" class="h5 mb-0">0</div>
                </div>
              </div>
              <div class="col-6 col-lg-2 mb-2"><div class="border rounded p-2 h-100"><div class="small text-muted">${t('kpi_alerts')}</div><div id="k_alert" class="h5 mb-0">0</div></div></div>
              <div class="col-6 col-lg-2 mb-2"><div class="border rounded p-2 h-100"><div class="small text-muted">${t('kpi_brands')}</div><div id="k_brand" class="h5 mb-0">0</div></div></div>
            </div>
            <div class="row">
              <div class="col-12 mb-2">
                <div class="d-flex align-items-center justify-content-between flex-wrap">
                  <div class="d-flex align-items-center flex-wrap">
                    <button id="dash_kpi_fun_toggle" type="button" class="dash-kpi-fun-link">${t('rank_cal_fun_prefix')}</button>
                  </div>
                </div>
                <div id="dash_kpi_fun_zone" class="dash-kpi-fun-zone d-none mt-2">
                  <div class="row">
                    <div class="col-12 col-xl-6 mb-2">
                      <div id="k_value_fun_stack" class="dash-kpi-fun-stack d-none">
                        <div id="k_value_fun_stock" class="dash-kpi-fun-panel"></div>
                        <div id="k_value_fun_lifetime" class="dash-kpi-fun-panel"></div>
                      </div>
                    </div>
                    <div class="col-12 col-xl-6 mb-2">
                      <div id="k_cal_fun_stack" class="dash-kpi-fun-stack d-none">
                        <div id="k_cal_fun_stock" class="dash-kpi-fun-panel"></div>
                        <div id="k_cal_fun_lifetime" class="dash-kpi-fun-panel"></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="alert alert-light border mt-3 mb-3">
              <div class="font-weight-bold mb-2">${t('quick_read_title')}</div>
              <ul id="dash_insights" class="mb-0 pl-3"></ul>
            </div>

            <div class="row align-items-start">
              <div class="col-12 col-xl-6 mb-4"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_group_value_title')}</div><div style="height:320px"><canvas id="g_val"></canvas></div><p class="small text-muted mt-2 mb-0">${t('chart_group_value_sub')}</p></div></div>
              <div class="col-12 col-xl-6 mb-4"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_group_qty_title')}</div><div style="height:320px"><canvas id="g_qty"></canvas></div><div id="g_qty_unclassified" class="small text-muted mt-2"></div><p class="small text-muted mt-2 mb-0">${t('chart_group_qty_sub')}</p></div></div>
            </div>

            <div class="row align-items-start">
              <div class="col-12 col-xl-6 mb-4"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_risk_title')}</div><div style="height:320px"><canvas id="risk"></canvas></div><p class="small text-muted mt-2 mb-0">${t('chart_risk_sub')}</p></div></div>
              <div class="col-12 col-xl-6 mb-4"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_due_title')}</div><div style="height:320px"><canvas id="due"></canvas></div><p class="small text-muted mt-2 mb-0">${t('chart_due_sub')}</p></div></div>
            </div>

            <div class="row align-items-start">
              <div class="col-12 col-xl-6 mb-4"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_brand_price_title')}</div><div style="height:320px"><canvas id="brand_price"></canvas></div><p class="small text-muted mt-2 mb-0">${t('chart_brand_price_sub')}</p></div></div>
              <div class="col-12 col-xl-6 mb-4"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_brand_rel_title')}</div><div style="height:320px"><canvas id="brand_rel"></canvas></div><div id="brand_rel_labels" class="small text-muted mt-2"></div><p class="small text-muted mt-2 mb-0">${t('chart_brand_rel_sub')}</p></div></div>
            </div>

            <div class="row align-items-start">
              <div class="col-12 col-xl-6 mb-4"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_top_value_title')}</div><div style="height:320px"><canvas id="top_val"></canvas></div><p class="small text-muted mt-2 mb-0">${t('chart_top_value_sub')}</p></div></div>
              <div class="col-12 col-xl-6 mb-4"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_price_vs_value_title')}</div><div style="height:320px"><canvas id="price_val"></canvas></div><p class="small text-muted mt-2 mb-0">${t('chart_price_vs_value_sub')}</p></div></div>
            </div>

            <div class="row">
              <div class="col-12 mb-2"><div class="border rounded p-2 dash-chart-card"><div class="font-weight-bold mb-2">${t('chart_group_cal_title')}</div><div style="height:320px"><canvas id="g_cal"></canvas></div><div id="g_cal_fun_note" class="dash-calorie-fun-note mt-2 d-none"></div><p class="small text-muted mt-2 mb-0">${t('chart_group_cal_sub')}</p></div></div>
            </div>

            <div class="row mt-2">
              <div class="col-12">
                <div id="dash_global_conclusions" class="dash-global-conclusions-box p-3">
                  <div class="dash-global-conclusions-title mb-2">${t('global_conclusions_title')}</div>
                  <div id="dash_global_conclusions_body" class="small"></div>
                </div>
              </div>
            </div>
            </section>
            <section id="dash_section_rankings" class="mt-4">
              <div class="dash-rankings-box p-3">
                <div class="d-flex justify-content-between align-items-center flex-wrap">
                  <div class="dash-rankings-title">${t('rankings_title')}</div>
                  <div id="dash_rankings_context" class="small text-muted">${t('rankings_context')}</div>
                </div>
                <div id="dash_rankings_categories" class="dash-rankings-categories mt-3"></div>

                <div class="dash-rankings-podium-wrap mt-3">
                  <div class="dash-rankings-subtitle">${t('rankings_podium_title')}</div>
                  <div class="small text-muted mb-2">${t('rankings_podium_sub')}</div>
                  <div id="dash_rankings_podium_grid" class="row"></div>
                </div>

                <div id="dash_rankings_full_section" class="dash-rankings-full mt-3">
                  <div class="d-flex justify-content-between align-items-center flex-wrap">
                    <div>
                      <div class="dash-rankings-subtitle">${t('rankings_full_title')}</div>
                      <div class="small text-muted">${t('rankings_full_sub')}</div>
                    </div>
                    <button id="dash_rankings_full_toggle" class="btn btn-sm btn-outline-secondary dash-rankings-full-toggle" type="button"></button>
                  </div>
                  <div id="dash_rankings_full_wrap" class="mt-2 d-none">
                    <div id="dash_rankings_grid" class="row"></div>
                  </div>
                </div>
              </div>
            </section>
            </div>
          </div>
        </div>
      </div>`;

    row.parentNode.insertBefore(block, row);
    initChartOverlay();
    attachChartExpandButtons();

    const viewStats = document.getElementById('dash_view_stats');
    const viewRankings = document.getElementById('dash_view_rankings');
    const aiSettingsOpen = document.getElementById('dash_ai_settings_open');
    const refresh = document.getElementById('dash_refresh');
    const toggle = document.getElementById('dash_toggle');
    const body = document.getElementById('dash_body');
    const kpiFunToggle = document.getElementById('dash_kpi_fun_toggle');
    const kpiFunZone = document.getElementById('dash_kpi_fun_zone');

    const syncKpiFunToggle = () => {
      if (!kpiFunToggle || !kpiFunZone) return;
      kpiFunZone.classList.toggle('d-none', S.kpiFunOpen !== true);
      kpiFunToggle.textContent = S.kpiFunOpen ? t('kpi_fun_toggle_hide') : t('kpi_fun_toggle_show');
      kpiFunToggle.setAttribute('aria-expanded', S.kpiFunOpen ? 'true' : 'false');
    };

    if (viewStats) {
      viewStats.addEventListener('click', () => {
        setDashboardView('stats');
      });
    }
    if (viewRankings) {
      viewRankings.addEventListener('click', () => {
        setDashboardView('rankings');
      });
    }
    if (aiSettingsOpen) {
      aiSettingsOpen.addEventListener('click', () => {
        openAiSettingsOverlay();
      });
    }
    if (body) {
      body.addEventListener('click', (event) => {
        const target = event.target;
        if (!target || typeof target.closest !== 'function') return;
        if (handleStockFacetElementClick(target, event)) return;
        if (handleFunPanelRandomizeClick(target, event)) return;

        const categoryBtn = target.closest('[data-rankings-category]');
        if (categoryBtn) {
          event.preventDefault();
          const category = clean(categoryBtn.getAttribute('data-rankings-category') || '');
          setRankingsCategory(category);
          refreshRankingsSection();
          return;
        }

        const qtyModeBtn = target.closest('[data-rank-qty-mode]');
        if (qtyModeBtn) {
          event.preventDefault();
          const mode = normalizeQtyMode(qtyModeBtn.getAttribute('data-rank-qty-mode') || '');
          patchChartPref('g_qty', { qtyMode: mode });
          refreshSingleChart('g_qty');
          refreshRankingsSection();
          return;
        }

        const podiumModeBtn = target.closest('[data-rank-podium-mode]');
        if (podiumModeBtn) {
          event.preventDefault();
          const cardId = clean(podiumModeBtn.getAttribute('data-rank-card-id') || '');
          const mode = clean(podiumModeBtn.getAttribute('data-rank-podium-mode') || '');
          setRankingPodiumMode(cardId, mode);
          refreshRankingsSection();
          return;
        }

        const seeMoreBtn = target.closest('[data-rank-see-more]');
        if (seeMoreBtn) {
          event.preventDefault();
          const cardId = clean(seeMoreBtn.getAttribute('data-rank-see-more') || '');
          if (cardId) {
            S.rankingsFocusedCardId = cardId;
            setRankingsDetailsExpanded(true);
            refreshRankingsSection();
            focusRankingCard(cardId, true);
          }
          return;
        }

        const podiumItem = target.closest('.dash-podium-item');
        if (podiumItem && !target.closest('.dash-product-link') && !target.closest('.dash-stock-facet-link')) {
          const cardId = clean(podiumItem.closest('[data-rank-card-id]')?.getAttribute('data-rank-card-id') || '');
          if (cardId) {
            event.preventDefault();
            S.rankingsFocusedCardId = cardId;
            setRankingsDetailsExpanded(true);
            refreshRankingsSection();
            focusRankingCard(cardId, true);
            return;
          }
        }

        if (target.closest('#dash_rankings_full_toggle')) {
          event.preventDefault();
          setRankingsDetailsExpanded(!S.rankingsDetailsExpanded);
          return;
        }

        const btn = target.closest('.dash-product-link');
        if (!btn) return;
        const productId = num(btn.getAttribute('data-product-id') || '0');
        if (productId > 0) {
          event.preventDefault();
          openProduct(productId);
        }
      });
      bindEntityHoverPreviewHandlers(body);
    }

    setDashboardView(S.dashboardView || 'stats');
    setRankingsDetailsExpanded(S.rankingsDetailsExpanded === true);
    syncAiSettingsButton();
    renderAddonCompatibilityBanner();
    refreshAddonCompatibilityScan({ render: true });
    setDashboardCollapsed(!S.dashboardOpen, { ensureReady: S.dashboardOpen === true });
    scheduleUiStateSave();

    refresh.addEventListener('click', () => {
      ensureDashboardReady(true).finally(() => {
        scheduleRender();
      });
    });
    toggle.addEventListener('click', () => {
      setDashboardCollapsed(S.dashboardOpen, { ensureReady: true });
    });
    if (kpiFunToggle) {
      kpiFunToggle.addEventListener('click', () => {
        S.kpiFunOpen = !S.kpiFunOpen;
        syncKpiFunToggle();
      });
      syncKpiFunToggle();
    }
  }

  function ensureDashboardReady(force = false) {
    if (!force && S.dashboardReady) return Promise.resolve(true);
    if (force) {
      S.dashboardReady = false;
    }
    return Promise.all([refreshApiData(force), ensureChartJsLoaded()]).then(() => {
      S.dashboardReady = true;
      return true;
    });
  }

  function initDashboardStyles() {
    if (document.getElementById('dash-custom-styles')) return;
    const style = document.createElement('style');
    style.id = 'dash-custom-styles';
    style.textContent = `
      #stock-analytics-dashboard .card {
        border: 1px solid rgba(255,255,255,0.12);
        box-shadow: 0 10px 24px rgba(0,0,0,0.22);
      }
      #stock-analytics-dashboard .card-header {
        background: linear-gradient(120deg, rgba(13,110,253,0.15), rgba(32,201,151,0.14));
        border-bottom: 1px solid rgba(255,255,255,0.12);
      }
      #stock-analytics-dashboard .border.rounded {
        border-color: rgba(255,255,255,0.18) !important;
        background: linear-gradient(160deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      }
      #stock-analytics-dashboard .dash-kpi-card {
        position: relative;
      }
      #stock-analytics-dashboard .dash-kpi-card-fun {
        z-index: 1;
      }
      #stock-analytics-dashboard .dash-kpi-fun-link {
        appearance: none;
        border: 0;
        background: transparent;
        color: #58d1ff;
        font-weight: 600;
        font-size: 0.86rem;
        text-decoration: underline;
        text-underline-offset: 0.16rem;
        padding: 0;
        cursor: pointer;
      }
      #stock-analytics-dashboard .dash-kpi-fun-link:hover,
      #stock-analytics-dashboard .dash-kpi-fun-link:focus {
        color: #9be7ff;
        outline: none;
      }
      #stock-analytics-dashboard .dash-kpi-fun-zone {
        border: 1px dashed rgba(118, 186, 255, 0.35);
        border-radius: 0.6rem;
        padding: 0.52rem 0.6rem 0.25rem;
        background: linear-gradient(155deg, rgba(17, 24, 35, 0.6), rgba(12, 19, 30, 0.45));
      }
      #stock-analytics-dashboard .dash-kpi-fun-stack {
        display: grid;
        gap: 0.38rem;
        margin-top: 0;
      }
      #stock-analytics-dashboard .dash-kpi-fun-panel {
        position: relative;
        z-index: 3;
        border: 1px solid rgba(77, 184, 255, 0.42);
        border-radius: 0.58rem;
        padding: 0.38rem 0.46rem;
        background: linear-gradient(154deg, rgba(9, 22, 41, 0.82), rgba(10, 28, 51, 0.68));
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.24);
        transform: translateY(8px) scale(0.992);
        opacity: 0;
        animation: dash-kpi-fun-in 440ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      }
      #stock-analytics-dashboard .dash-kpi-fun-panel:nth-child(2) {
        animation-delay: 70ms;
      }
      #stock-analytics-dashboard .dash-kpi-fun-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.42rem;
      }
      #stock-analytics-dashboard .dash-kpi-fun-head-right,
      #dash_chart_overlay .dash-kpi-fun-head-right {
        display: inline-flex;
        align-items: center;
        justify-content: flex-end;
        gap: 0.34rem;
        flex-wrap: wrap;
      }
      #stock-analytics-dashboard .dash-kpi-fun-title {
        font-size: 0.7rem;
        line-height: 1.15;
        font-weight: 700;
        color: rgba(184, 224, 255, 0.96);
        letter-spacing: 0.012em;
        text-transform: uppercase;
      }
      #stock-analytics-dashboard .dash-kpi-fun-total {
        font-size: 0.71rem;
        line-height: 1.1;
        font-weight: 700;
        color: rgba(221, 238, 255, 0.97);
        white-space: nowrap;
      }
      #stock-analytics-dashboard .dash-kpi-fun-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.62rem;
        font-weight: 700;
        line-height: 1;
        padding: 0.12rem 0.28rem;
        border-radius: 999px;
        border: 1px solid rgba(32, 201, 151, 0.58);
        color: rgba(198, 248, 232, 0.98);
        background: rgba(32, 201, 151, 0.14);
        white-space: nowrap;
      }
      #stock-analytics-dashboard .dash-kpi-fun-main {
        margin-top: 0.24rem;
        font-size: 0.82rem;
        line-height: 1.22;
        font-weight: 600;
        color: rgba(233, 245, 255, 0.96);
      }
      #stock-analytics-dashboard .dash-kpi-fun-main strong {
        color: rgba(255, 255, 255, 0.99);
      }
      #stock-analytics-dashboard .dash-kpi-fun-pills {
        margin-top: 0.28rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.22rem;
      }
      #stock-analytics-dashboard .dash-kpi-fun-categories,
      #dash_chart_overlay .dash-kpi-fun-categories {
        margin-top: 0.3rem;
        display: grid;
        gap: 0.24rem;
      }
      #stock-analytics-dashboard .dash-kpi-fun-category-row,
      #dash_chart_overlay .dash-kpi-fun-category-row {
        display: grid;
        grid-template-columns: minmax(0, auto) 1fr;
        gap: 0.36rem;
        align-items: start;
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.44rem;
        padding: 0.2rem 0.34rem;
        background: linear-gradient(160deg, rgba(255,255,255,0.07), rgba(255,255,255,0.02));
      }
      #stock-analytics-dashboard .dash-kpi-fun-category-name,
      #dash_chart_overlay .dash-kpi-fun-category-name {
        font-size: 0.64rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.01em;
        color: rgba(144, 212, 255, 0.96);
        white-space: nowrap;
      }
      #stock-analytics-dashboard .dash-kpi-fun-category-value,
      #dash_chart_overlay .dash-kpi-fun-category-value {
        font-size: 0.74rem;
        line-height: 1.25;
        color: rgba(220, 236, 252, 0.97);
      }
      #stock-analytics-dashboard .dash-kpi-fun-category-value strong,
      #dash_chart_overlay .dash-kpi-fun-category-value strong {
        color: rgba(255,255,255,0.99);
      }
      #stock-analytics-dashboard .dash-kpi-fun-random-btn,
      #dash_chart_overlay .dash-kpi-fun-random-btn {
        min-height: 1.42rem;
        border-color: rgba(94, 192, 255, 0.52);
        color: rgba(180, 231, 255, 0.98);
        background: linear-gradient(150deg, rgba(13,110,253,0.19), rgba(32,201,151,0.12));
        font-size: 0.66rem;
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-kpi-fun-random-btn:hover,
      #stock-analytics-dashboard .dash-kpi-fun-random-btn:focus,
      #dash_chart_overlay .dash-kpi-fun-random-btn:hover,
      #dash_chart_overlay .dash-kpi-fun-random-btn:focus {
        border-color: rgba(126, 219, 255, 0.9);
        color: #e6f6ff;
        background: linear-gradient(150deg, rgba(13,110,253,0.28), rgba(32,201,151,0.18));
      }
      #stock-analytics-dashboard .dash-kpi-fun-pill {
        display: inline-flex;
        align-items: center;
        max-width: 100%;
        border: 1px solid rgba(255,255,255,0.19);
        border-radius: 999px;
        padding: 0.08rem 0.36rem;
        font-size: 0.64rem;
        line-height: 1.18;
        color: rgba(206, 226, 247, 0.95);
        background: rgba(255,255,255,0.07);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      #stock-analytics-dashboard .dash-kpi-fun-empty {
        margin-top: 0.22rem;
        font-size: 0.72rem;
        color: rgba(193, 208, 223, 0.86);
      }
      #stock-analytics-dashboard .dash-kpi-fun-main-wrap,
      #dash_chart_overlay .dash-kpi-fun-main-wrap {
        margin-top: 0.22rem;
        display: grid;
        grid-template-columns: auto minmax(0, 1fr);
        gap: 0.46rem;
        align-items: start;
      }
      #stock-analytics-dashboard .dash-kpi-fun-main-wrap.is-no-thumb,
      #dash_chart_overlay .dash-kpi-fun-main-wrap.is-no-thumb {
        grid-template-columns: minmax(0, 1fr);
      }
      #stock-analytics-dashboard .dash-kpi-fun-main-lines,
      #dash_chart_overlay .dash-kpi-fun-main-lines {
        min-width: 0;
      }
      #stock-analytics-dashboard .dash-kpi-fun-main-wrap .dash-kpi-fun-empty,
      #dash_chart_overlay .dash-kpi-fun-main-wrap .dash-kpi-fun-empty {
        margin-top: 0;
      }
      #stock-analytics-dashboard .dash-kpi-fun-empty-secondary,
      #dash_chart_overlay .dash-kpi-fun-empty-secondary {
        font-size: .72rem;
        opacity: .92;
        margin-top: .14rem;
      }
      #stock-analytics-dashboard .dash-kpi-fun-thumb,
      #dash_chart_overlay .dash-kpi-fun-thumb {
        position: relative;
        width: 2.1rem;
        height: 2.1rem;
        border-radius: 0.46rem;
        border: 1px solid rgba(255,255,255,0.28);
        background: linear-gradient(150deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
        overflow: visible;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        box-shadow: 0 6px 14px rgba(0,0,0,0.22);
      }
      #stock-analytics-dashboard .dash-kpi-fun-thumb img,
      #dash_chart_overlay .dash-kpi-fun-thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 0.4rem;
        display: block;
      }
      #stock-analytics-dashboard .dash-kpi-fun-thumb-preview,
      #dash_chart_overlay .dash-kpi-fun-thumb-preview {
        position: absolute;
        top: -0.15rem;
        left: calc(100% + 0.5rem);
        width: 8.6rem;
        border-radius: 0.56rem;
        border: 1px solid rgba(126, 211, 255, 0.58);
        background: linear-gradient(160deg, rgba(8,20,39,0.96), rgba(11,27,52,0.94));
        box-shadow: 0 14px 24px rgba(0,0,0,0.34);
        padding: 0.26rem;
        opacity: 0;
        pointer-events: none;
        transform: translateY(3px) scale(0.96);
        transition: opacity 0.16s ease, transform 0.16s ease;
        z-index: 50;
      }
      #stock-analytics-dashboard .dash-kpi-fun-thumb-preview img,
      #dash_chart_overlay .dash-kpi-fun-thumb-preview img {
        width: 100%;
        height: auto;
        max-height: 8.1rem;
        object-fit: contain;
        border-radius: 0.42rem;
        background: rgba(255,255,255,0.04);
      }
      #stock-analytics-dashboard .dash-kpi-fun-thumb:hover .dash-kpi-fun-thumb-preview,
      #stock-analytics-dashboard .dash-kpi-fun-thumb:focus-within .dash-kpi-fun-thumb-preview,
      #dash_chart_overlay .dash-kpi-fun-thumb:hover .dash-kpi-fun-thumb-preview,
      #dash_chart_overlay .dash-kpi-fun-thumb:focus-within .dash-kpi-fun-thumb-preview {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      #stock-analytics-dashboard .dash-kpi-fun-thumb-caption,
      #dash_chart_overlay .dash-kpi-fun-thumb-caption {
        margin-top: 0.28rem;
        font-size: 0.64rem;
        line-height: 1.2;
        color: rgba(220,239,255,0.95);
        word-break: break-word;
      }
      #stock-analytics-dashboard .dash-kpi-fun-thumb-hint,
      #dash_chart_overlay .dash-kpi-fun-thumb-hint {
        display: inline-block;
        margin-top: 0.2rem;
        padding: 0.08rem 0.28rem;
        border-radius: 999px;
        font-size: 0.58rem;
        font-weight: 600;
        color: rgba(170, 227, 255, 0.97);
        border: 1px solid rgba(94, 192, 255, 0.42);
        background: rgba(13,110,253,0.2);
      }
      #dash_chart_overlay .dash-kpi-fun-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.42rem;
      }
      #dash_chart_overlay .dash-kpi-fun-title {
        font-size: 0.7rem;
        line-height: 1.15;
        font-weight: 700;
        color: rgba(184, 224, 255, 0.96);
        letter-spacing: 0.012em;
        text-transform: uppercase;
      }
      #dash_chart_overlay .dash-kpi-fun-total {
        font-size: 0.71rem;
        line-height: 1.1;
        font-weight: 700;
        color: rgba(221, 238, 255, 0.97);
        white-space: nowrap;
      }
      #dash_chart_overlay .dash-kpi-fun-empty {
        margin-top: 0.22rem;
        font-size: 0.72rem;
        color: rgba(193, 208, 223, 0.86);
      }
      @keyframes dash-kpi-fun-in {
        0% {
          opacity: 0;
          transform: translateY(8px) scale(0.992);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      @media (max-width: 1199.98px) {
        #stock-analytics-dashboard .dash-kpi-fun-title {
          font-size: 0.66rem;
        }
        #stock-analytics-dashboard .dash-kpi-fun-total {
          font-size: 0.68rem;
        }
        #stock-analytics-dashboard .dash-kpi-fun-main {
          font-size: 0.76rem;
        }
      }
      #stock-analytics-dashboard .dash-chart-card {
        height: auto;
      }
      #stock-analytics-dashboard .row.align-items-start > [class*="col-"] {
        align-self: flex-start;
      }
      #stock-analytics-dashboard .font-weight-bold > button[data-chart-expand] {
        border-color: rgba(255,255,255,0.24);
      }
      #stock-analytics-dashboard .font-weight-bold > button[data-chart-expand]:hover {
        border-color: rgba(13,110,253,0.7);
        color: #0d6efd;
      }
      #stock-analytics-dashboard .dash-chart-head {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        align-items: start;
        gap: 0.42rem 0.62rem;
        padding-top: 0.05rem;
      }
      #stock-analytics-dashboard .dash-chart-title-label {
        min-width: 0;
        width: auto;
        line-height: 1.14;
        margin: 0;
      }
      #stock-analytics-dashboard .dash-chart-actions {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        width: max-content;
        max-width: 100%;
        justify-self: end;
        gap: 0.28rem;
        margin: 0;
      }
      #stock-analytics-dashboard .dash-chart-actions-row {
        display: flex;
        width: auto;
        max-width: 100%;
        align-items: center;
        justify-content: flex-end;
        align-content: center;
        flex-wrap: wrap;
        gap: 0.28rem;
      }
      #stock-analytics-dashboard .dash-chart-actions-row-top {
        min-height: 1.72rem;
        flex-wrap: nowrap;
      }
      #stock-analytics-dashboard .dash-chart-actions-row-bottom {
        min-height: 1.72rem;
        justify-content: flex-end;
      }
      #stock-analytics-dashboard .dash-chart-actions .btn-group,
      #stock-analytics-dashboard .dash-chart-actions .dash-chart-type-group {
        margin: 0;
        border-radius: 0.44rem;
        box-shadow: 0 3px 8px rgba(0,0,0,0.16);
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-qty-mode-wrap {
        margin: 0;
        display: inline-flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.26rem;
        padding: 0.14rem 0.2rem;
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.5rem;
        background: linear-gradient(145deg, rgba(255,255,255,0.04), rgba(255,255,255,0.015));
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-qty-mode-wrap .btn-group {
        margin: 0;
        box-shadow: none;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-qty-total-chip {
        min-height: 1.72rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.12rem 0.5rem;
        border-radius: 0.4rem;
        border: 1px solid rgba(32,201,151,0.56);
        background: linear-gradient(145deg, rgba(32,201,151,0.2), rgba(13,110,253,0.14));
        color: rgba(212,246,237,0.98);
        font-weight: 600;
        font-size: 0.75rem;
        line-height: 1.1;
        white-space: nowrap;
        box-shadow: 0 5px 12px rgba(0,0,0,0.16);
      }
      #stock-analytics-dashboard .dash-chart-actions .btn {
        border-color: rgba(255,255,255,0.24);
        min-height: 1.72rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.12rem 0.44rem;
        font-size: 0.84rem;
        line-height: 1.1;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-chart-type-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 2.32rem;
        padding-left: 0.4rem;
        padding-right: 0.4rem;
        gap: 0.25rem;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-chart-type-btn i {
        font-size: 0.8rem;
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-chart-type-btn .dash-chart-type-label {
        display: none;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-chart-icon-btn {
        min-width: 2.32rem;
        min-height: 1.72rem;
        padding-left: 0.4rem;
        padding-right: 0.4rem;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-sort-btn {
        min-width: 2.32rem;
        min-height: 1.72rem;
        padding-left: 0.4rem;
        padding-right: 0.4rem;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-sort-btn i {
        font-size: 0.8rem;
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-qty-mode-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.24rem;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-qty-mode-btn i {
        font-size: 0.78rem;
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-chart-actions .dash-qty-mode-btn .dash-qty-mode-label {
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-chart-actions .btn.chart-ctl-active {
        background: rgba(13,110,253,0.24);
        border-color: rgba(13,110,253,0.78);
        color: #9ec5fe;
      }
      #stock-analytics-dashboard .dash-chart-actions .btn.chart-ctl-active:hover {
        color: #cfe2ff;
      }
      @media (max-width: 1199.98px) {
        #stock-analytics-dashboard .dash-chart-head {
          grid-template-columns: 1fr;
          gap: 0.36rem;
        }
        #stock-analytics-dashboard .dash-chart-actions {
          width: 100%;
          max-width: none;
          align-items: flex-start;
        }
        #stock-analytics-dashboard .dash-chart-actions-row {
          justify-content: flex-start;
        }
      }
      #stock-analytics-dashboard #dash_view_stats.active,
      #stock-analytics-dashboard #dash_view_rankings.active {
        background: rgba(13,110,253,0.24);
        border-color: rgba(13,110,253,0.78);
        color: #cfe2ff;
      }
      #stock-analytics-dashboard .border.rounded > p.small {
        max-height: 2.6em;
        overflow: hidden;
      }
      #stock-analytics-dashboard .alert-light {
        background: rgba(255,255,255,0.88);
      }
      #stock-analytics-dashboard .dash-global-conclusions-box {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.75rem;
        background: linear-gradient(150deg, rgba(13,110,253,0.15), rgba(25,135,84,0.11));
        box-shadow: 0 12px 24px rgba(0,0,0,0.2);
      }
      #stock-analytics-dashboard .dash-global-conclusions-title {
        font-size: 1rem;
        font-weight: 600;
        letter-spacing: 0.01em;
      }
      #stock-analytics-dashboard #dash_global_conclusions_body ul {
        margin-bottom: 0;
      }
      #stock-analytics-dashboard #dash_sections_root {
        display: flex;
        flex-direction: column;
      }
      #stock-analytics-dashboard #dash_section_charts {
        order: 1;
      }
      #stock-analytics-dashboard #dash_section_rankings {
        order: 2;
      }
      #stock-analytics-dashboard #dash_body.dash-view-rankings #dash_section_rankings {
        order: 1;
      }
      #stock-analytics-dashboard #dash_body.dash-view-rankings #dash_section_charts {
        order: 2;
      }
      #stock-analytics-dashboard .dash-rankings-box {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.75rem;
        background: linear-gradient(150deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        box-shadow: 0 12px 24px rgba(0,0,0,0.2);
      }
      #stock-analytics-dashboard .dash-rankings-title {
        font-weight: 600;
        font-size: 1.02rem;
        letter-spacing: 0.01em;
      }
      #stock-analytics-dashboard .dash-rankings-subtitle {
        font-weight: 600;
        font-size: 0.92rem;
        letter-spacing: 0.01em;
      }
      #stock-analytics-dashboard .dash-rankings-categories {
        display: flex;
        flex-wrap: wrap;
        gap: 0.42rem;
      }
      #stock-analytics-dashboard .dash-rankings-cat-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        border: 1px solid rgba(255,255,255,0.22);
        border-radius: 999px;
        background: rgba(255,255,255,0.03);
        color: rgba(230,234,239,0.96);
        padding: 0.24rem 0.7rem;
        font-size: 0.82rem;
        font-weight: 600;
        line-height: 1.2;
        transition: border-color 0.15s ease, background 0.15s ease, transform 0.15s ease, box-shadow 0.15s ease;
      }
      #stock-analytics-dashboard .dash-rankings-cat-btn .dash-rankings-cat-count {
        border-radius: 999px;
        background: rgba(255,255,255,0.1);
        padding: 0.04rem 0.34rem;
        font-size: 0.74rem;
        line-height: 1.1;
      }
      #stock-analytics-dashboard .dash-rankings-cat-btn:hover,
      #stock-analytics-dashboard .dash-rankings-cat-btn:focus {
        border-color: rgba(13,110,253,0.76);
        transform: translateY(-1px);
      }
      #stock-analytics-dashboard .dash-rankings-cat-btn.is-active {
        border-color: rgba(13,110,253,0.86);
        background: linear-gradient(145deg, rgba(13,110,253,0.4), rgba(13,110,253,0.2));
        color: #d8e8ff;
        box-shadow: 0 8px 18px rgba(13,110,253,0.2);
      }
      #stock-analytics-dashboard .dash-rankings-podium-wrap {
        border: 1px solid rgba(255,255,255,0.14);
        border-radius: 0.72rem;
        background: linear-gradient(150deg, rgba(13,110,253,0.06), rgba(255,255,255,0.018));
        padding: 0.7rem;
      }
      #stock-analytics-dashboard .dash-podium-card {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.72rem;
        background: linear-gradient(155deg, rgba(13,110,253,0.14), rgba(255,255,255,0.02));
        height: auto;
        box-shadow: 0 10px 22px rgba(0,0,0,0.18);
        transition: transform 0.16s ease, box-shadow 0.16s ease, border-color 0.16s ease;
      }
      #stock-analytics-dashboard .dash-podium-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 14px 28px rgba(0,0,0,0.24);
        border-color: rgba(13,110,253,0.5);
      }
      #stock-analytics-dashboard .dash-podium-head {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 0.5rem;
      }
      #stock-analytics-dashboard .dash-podium-title {
        font-weight: 700;
        font-size: 0.9rem;
        line-height: 1.2;
      }
      #stock-analytics-dashboard .dash-podium-subtitle {
        font-size: 0.78rem;
        opacity: 0.82;
        line-height: 1.2;
        margin-top: 0.18rem;
      }
      #stock-analytics-dashboard .dash-ranking-qty-controls {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0.22rem;
        margin-top: 0.35rem;
      }
      #stock-analytics-dashboard .dash-ranking-qty-controls .btn {
        border-radius: 999px;
        border-color: rgba(255,255,255,0.24);
        color: rgba(224,233,244,0.9);
        font-size: 0.74rem;
        font-weight: 600;
        line-height: 1.1;
        padding: 0.14rem 0.52rem;
      }
      #stock-analytics-dashboard .dash-ranking-qty-controls .dash-qty-mode-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.28rem;
      }
      #stock-analytics-dashboard .dash-ranking-qty-controls .dash-qty-mode-btn i {
        font-size: 0.75rem;
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-ranking-qty-controls .dash-qty-mode-btn .dash-qty-mode-label {
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-ranking-qty-controls .btn:hover,
      #stock-analytics-dashboard .dash-ranking-qty-controls .btn:focus {
        border-color: rgba(13,110,253,0.74);
        color: #d8e8ff;
        background: rgba(13,110,253,0.18);
      }
      #stock-analytics-dashboard .dash-ranking-qty-controls .btn.is-active {
        border-color: rgba(13,110,253,0.8);
        background: rgba(13,110,253,0.26);
        color: #d8e8ff;
        box-shadow: 0 5px 14px rgba(13,110,253,0.2);
      }
      #stock-analytics-dashboard .dash-ranking-qty-controls-compact .btn {
        font-size: 0.72rem;
        padding: 0.12rem 0.45rem;
      }
      #stock-analytics-dashboard .dash-podium-see-more {
        border-radius: 999px;
        border-color: rgba(13,110,253,0.66);
        font-size: 0.76rem;
        font-weight: 600;
        padding: 0.14rem 0.58rem;
      }
      #stock-analytics-dashboard .dash-podium-mode {
        display: inline-flex;
        gap: 0.24rem;
        margin-top: 0.55rem;
      }
      #stock-analytics-dashboard .dash-podium-mode .btn {
        border-radius: 999px;
        border-color: rgba(255,255,255,0.24);
        color: rgba(227,233,240,0.9);
        font-size: 0.76rem;
        font-weight: 600;
        line-height: 1.1;
        padding: 0.14rem 0.56rem;
      }
      #stock-analytics-dashboard .dash-podium-mode .btn.is-active {
        border-color: rgba(13,110,253,0.78);
        background: rgba(13,110,253,0.24);
        color: #d8e8ff;
        box-shadow: 0 5px 14px rgba(13,110,253,0.2);
      }
      #stock-analytics-dashboard .dash-podium-list {
        list-style: none;
        margin: 0.7rem 0 0;
        padding: 0;
      }
      #stock-analytics-dashboard .dash-podium-item {
        display: flex;
        align-items: flex-start;
        gap: 0.55rem;
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.62rem;
        padding: 0.38rem 0.48rem;
        margin-bottom: 0.38rem;
        background: rgba(255,255,255,0.03);
        transition: border-color 0.16s ease, background 0.16s ease, transform 0.16s ease, box-shadow 0.16s ease;
      }
      #stock-analytics-dashboard .dash-podium-item:hover,
      #stock-analytics-dashboard .dash-podium-item:focus-within {
        border-color: rgba(13,110,253,0.76);
        background: rgba(13,110,253,0.14);
        transform: translateX(2px);
        box-shadow: 0 8px 18px rgba(13,110,253,0.18);
      }
      #stock-analytics-dashboard .dash-podium-item:last-child {
        margin-bottom: 0;
      }
      #stock-analytics-dashboard .dash-podium-medal {
        flex: 0 0 auto;
        min-width: 2.1rem;
        height: 1.45rem;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.15rem;
        padding: 0 0.38rem;
        font-size: 0.72rem;
        font-weight: 700;
        color: rgba(18,22,26,0.98);
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.3);
      }
      #stock-analytics-dashboard .dash-podium-item.rank-1 .dash-podium-medal {
        background: linear-gradient(150deg, #f9d776, #f1b300);
      }
      #stock-analytics-dashboard .dash-podium-item.rank-2 .dash-podium-medal {
        background: linear-gradient(150deg, #d9e2ef, #aab8c8);
      }
      #stock-analytics-dashboard .dash-podium-item.rank-3 .dash-podium-medal {
        background: linear-gradient(150deg, #edb086, #c97a3a);
      }
      #stock-analytics-dashboard .dash-podium-item.rank-1.rank-bottom .dash-podium-medal {
        background: linear-gradient(150deg, #4a2416, #2a120b);
        color: #f6e6dd;
      }
      #stock-analytics-dashboard .dash-podium-item.rank-2.rank-bottom .dash-podium-medal {
        background: linear-gradient(150deg, #7a301b, #b8432a);
        color: #ffe7de;
      }
      #stock-analytics-dashboard .dash-podium-item.rank-3.rank-bottom .dash-podium-medal {
        background: linear-gradient(150deg, #b01f1a, #e0352b);
        color: #ffe6e3;
      }
      #stock-analytics-dashboard .dash-rank-crown {
        font-size: 0.68rem;
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-rank-crown.is-gold {
        color: #f2bf1b;
      }
      #stock-analytics-dashboard .dash-rank-crown.is-silver {
        color: #d4dde9;
      }
      #stock-analytics-dashboard .dash-rank-crown.is-bronze {
        color: #d6925d;
      }
      #stock-analytics-dashboard .dash-rank-num {
        font-size: 0.72rem;
        font-weight: 700;
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-podium-main {
        flex: 1 1 auto;
        min-width: 0;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: flex-start;
        gap: 0.2rem;
      }
      #stock-analytics-dashboard .dash-podium-value {
        font-size: 0.78rem;
        color: rgba(213,224,237,0.93);
        font-weight: 600;
        white-space: normal;
        line-height: 1.2;
      }
      #stock-analytics-dashboard .dash-podium-card .dash-product-link,
      #stock-analytics-dashboard .dash-podium-card .dash-stock-facet-link {
        max-width: 100%;
        text-align: left;
        line-height: 1.25;
      }
      #stock-analytics-dashboard .dash-ranking-fun-note {
        margin-top: 0.32rem;
        font-size: 0.74rem;
        color: rgba(173,214,255,0.9);
        line-height: 1.25;
      }
      #stock-analytics-dashboard .dash-calorie-fun-note {
        display: flex;
        justify-content: flex-start;
      }
      #stock-analytics-dashboard .dash-calorie-fun-box {
        display: inline-flex;
        flex-direction: column;
        gap: 0.24rem;
        max-width: min(100%, 32rem);
        border: 1px solid rgba(61, 178, 255, 0.45);
        border-radius: 0.58rem;
        padding: 0.42rem 0.56rem;
        background: linear-gradient(148deg, rgba(14, 33, 55, 0.72), rgba(12, 26, 45, 0.6));
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.22);
      }
      #stock-analytics-dashboard .dash-calorie-fun-title {
        font-size: 0.73rem;
        font-weight: 700;
        letter-spacing: 0.015em;
        color: rgba(183, 227, 255, 0.96);
        text-transform: uppercase;
      }
      #stock-analytics-dashboard .dash-calorie-fun-text {
        font-size: 0.83rem;
        line-height: 1.25;
        color: rgba(219, 238, 255, 0.97);
      }
      #stock-analytics-dashboard .dash-ranking-fun-note strong {
        color: rgba(205,230,255,0.98);
      }
      #stock-analytics-dashboard .dash-podium-empty,
      #stock-analytics-dashboard .dash-ranking-empty {
        color: rgba(200,206,214,0.86);
        font-size: 0.84rem;
      }
      #stock-analytics-dashboard .dash-rankings-full {
        border: 1px solid rgba(255,255,255,0.14);
        border-radius: 0.72rem;
        background: linear-gradient(155deg, rgba(255,255,255,0.045), rgba(255,255,255,0.012));
        padding: 0.7rem;
      }
      #stock-analytics-dashboard .dash-rankings-full-toggle {
        border-radius: 999px;
        border-color: rgba(13,110,253,0.64);
        font-size: 0.78rem;
        font-weight: 600;
        min-width: 7.2rem;
      }
      #stock-analytics-dashboard .dash-rankings-full-toggle.is-expanded {
        border-color: rgba(13,110,253,0.82);
        background: rgba(13,110,253,0.22);
        color: #d8e8ff;
      }
      #stock-analytics-dashboard #dash_rankings_full_wrap {
        max-height: 72vh;
        overflow: auto;
        padding-right: 0.1rem;
      }
      #stock-analytics-dashboard .dash-ranking-card {
        border: 1px solid rgba(255,255,255,0.14);
        border-radius: 0.68rem;
        background: linear-gradient(155deg, rgba(13,110,253,0.1), rgba(255,255,255,0.018));
        height: auto;
        transition: box-shadow 0.16s ease, border-color 0.16s ease, transform 0.16s ease;
      }
      #stock-analytics-dashboard #dash_rankings_podium_grid,
      #stock-analytics-dashboard #dash_rankings_grid {
        display: grid;
        align-items: start;
        margin: 0;
        gap: 0.85rem;
        grid-auto-flow: row;
      }
      #stock-analytics-dashboard #dash_rankings_podium_grid {
        grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      }
      #stock-analytics-dashboard #dash_rankings_grid {
        grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
      }
      #stock-analytics-dashboard #dash_rankings_podium_grid > [class*="col-"],
      #stock-analytics-dashboard #dash_rankings_grid > [class*="col-"] {
        display: block;
        flex: none;
        width: 100%;
        max-width: none;
        padding: 0;
        margin: 0 !important;
        break-inside: auto;
        page-break-inside: auto;
      }
      #stock-analytics-dashboard #dash_rankings_podium_grid > [class*="col-"] .dash-podium-card,
      #stock-analytics-dashboard #dash_rankings_grid > [class*="col-"] .dash-ranking-card {
        margin: 0;
      }
      @media (max-width: 1599.98px) {
        #stock-analytics-dashboard #dash_rankings_podium_grid {
          grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
        }
      }
      @media (max-width: 1199.98px) {
        #stock-analytics-dashboard #dash_rankings_podium_grid,
        #stock-analytics-dashboard #dash_rankings_grid {
          grid-template-columns: 1fr;
        }
      }
      #stock-analytics-dashboard .dash-ranking-card:hover {
        border-color: rgba(13,110,253,0.48);
        box-shadow: 0 12px 22px rgba(0,0,0,0.2);
        transform: translateY(-1px);
      }
      #stock-analytics-dashboard .dash-ranking-card.is-focused {
        border-color: rgba(13,110,253,0.86);
        box-shadow: 0 0 0 2px rgba(13,110,253,0.42), 0 12px 24px rgba(13,110,253,0.22);
        background: linear-gradient(150deg, rgba(13,110,253,0.24), rgba(255,255,255,0.035));
      }
      #stock-analytics-dashboard .dash-ranking-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 0.55rem;
      }
      #stock-analytics-dashboard .dash-ranking-title {
        font-weight: 600;
        font-size: 0.92rem;
      }
      #stock-analytics-dashboard .dash-ranking-subtitle {
        opacity: 0.8;
        font-size: 0.78rem;
        line-height: 1.2;
      }
      #stock-analytics-dashboard .dash-ranking-mode-chip {
        display: inline-flex;
        align-items: center;
        gap: 0.32rem;
        cursor: pointer;
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.24);
        border-radius: 999px;
        padding: 0.1rem 0.5rem;
        font-size: 0.72rem;
        color: rgba(210,220,232,0.88);
        white-space: nowrap;
      }
      #stock-analytics-dashboard .dash-ranking-mode-chip:hover,
      #stock-analytics-dashboard .dash-ranking-mode-chip:focus {
        border-color: rgba(13,110,253,0.78);
        color: #d8e8ff;
        background: rgba(13,110,253,0.2);
        box-shadow: 0 6px 14px rgba(13,110,253,0.18);
      }
      #stock-analytics-dashboard .dash-ranking-mode-chip i {
        font-size: 0.72rem;
        line-height: 1;
      }
      #stock-analytics-dashboard .dash-ranking-list {
        list-style: none;
        margin-bottom: 0;
        padding-left: 0;
        margin-top: 0.5rem;
        max-height: 45vh;
        overflow: auto;
      }
      #stock-analytics-dashboard .dash-ranking-row {
        margin-bottom: 0.26rem;
        display: flex;
        align-items: center;
        gap: 0.46rem;
      }
      #stock-analytics-dashboard .dash-ranking-rank {
        flex: 0 0 auto;
        min-width: 2.25rem;
        height: 1.45rem;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.15rem;
        padding: 0 0.4rem;
        background: linear-gradient(150deg, rgba(255,255,255,0.2), rgba(255,255,255,0.08));
        border: 1px solid rgba(255,255,255,0.26);
        color: rgba(226,234,245,0.96);
      }
      #stock-analytics-dashboard .dash-ranking-rank.rank-1 {
        background: linear-gradient(150deg, #f9d776, #f1b300);
        color: rgba(30,20,8,0.98);
      }
      #stock-analytics-dashboard .dash-ranking-rank.rank-2 {
        background: linear-gradient(150deg, #d9e2ef, #aab8c8);
        color: rgba(18,24,34,0.96);
      }
      #stock-analytics-dashboard .dash-ranking-rank.rank-3 {
        background: linear-gradient(150deg, #edb086, #c97a3a);
        color: rgba(28,16,8,0.96);
      }
      #stock-analytics-dashboard .dash-ranking-main {
        flex: 1 1 auto;
        min-width: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.46rem;
      }
      #stock-analytics-dashboard .dash-ranking-value {
        opacity: 0.84;
        font-size: 0.8rem;
        white-space: nowrap;
      }
      #stock-analytics-dashboard .dash-stock-facet-link-podium {
        padding: 0.12rem 0.5rem;
        font-size: 0.76rem;
      }
      #stock-analytics-dashboard .dash-product-link {
        color: #9ec5fe;
        text-decoration: none;
      }
      #stock-analytics-dashboard .dash-product-link:hover {
        color: #cfe2ff;
        text-decoration: underline;
      }
      #stock-analytics-dashboard .dash-stock-facet-link,
      #dash_chart_overlay .dash-stock-facet-link {
        display: inline-flex;
        align-items: center;
        gap: 0.28rem;
        border: 1px solid rgba(13,110,253,0.58);
        border-radius: 999px;
        background: linear-gradient(145deg, rgba(13,110,253,0.3), rgba(13,110,253,0.14));
        color: #cfe2ff;
        text-decoration: none;
        padding: 0.16rem 0.56rem;
        font-weight: 600;
        font-size: 0.82rem;
        line-height: 1.2;
        transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
      }
      #stock-analytics-dashboard .dash-stock-facet-link .dash-brand-logo-inline,
      #dash_chart_overlay .dash-stock-facet-link .dash-brand-logo-inline {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.38);
        background: rgba(255,255,255,0.08);
      }
      #stock-analytics-dashboard .dash-stock-facet-link .dash-brand-logo-inline img,
      #dash_chart_overlay .dash-stock-facet-link .dash-brand-logo-inline img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      #stock-analytics-dashboard .dash-brand-logo-banner {
        border: 1px solid rgba(255,255,255,0.18);
        border-radius: 0.65rem;
        background: linear-gradient(150deg, rgba(13,110,253,0.16), rgba(32,201,151,0.1));
        box-shadow: 0 10px 20px rgba(0,0,0,0.18);
      }
      #stock-analytics-dashboard .dash-brand-logo-banner .dash-brand-logo-banner-text {
        font-size: 0.88rem;
        line-height: 1.35;
      }
      #stock-analytics-dashboard .dash-stock-facet-link:hover,
      #stock-analytics-dashboard .dash-stock-facet-link:focus,
      #dash_chart_overlay .dash-stock-facet-link:hover,
      #dash_chart_overlay .dash-stock-facet-link:focus {
        color: #ffffff;
        border-color: rgba(110,168,254,0.95);
        background: linear-gradient(145deg, rgba(13,110,253,0.52), rgba(13,110,253,0.25));
        box-shadow: 0 7px 16px rgba(0,0,0,0.2);
        transform: translateY(-1px);
        outline: none;
      }
      #stock-analytics-dashboard #brand_rel_labels .dash-brand-rel-item {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.36rem;
        margin-bottom: 0.34rem;
      }
      #stock-analytics-dashboard #brand_rel_labels .dash-brand-rel-rank {
        color: rgba(255,255,255,0.72);
        min-width: 1.3rem;
        text-align: right;
      }
      #stock-analytics-dashboard #brand_rel_labels .dash-brand-rel-metrics {
        opacity: 0.85;
      }
      #stock-analytics-dashboard #brand_rel_labels .dash-brand-rel-more {
        margin-top: 0.2rem;
      }
      #stock-analytics-dashboard .dash-qty-unclassified,
      #dash_chart_overlay .dash-qty-unclassified {
        border: 1px dashed rgba(255,255,255,0.2);
        border-radius: 0.55rem;
        padding: 0.42rem 0.5rem;
        background: linear-gradient(150deg, rgba(255,255,255,0.04), rgba(255,255,255,0.012));
      }
      #stock-analytics-dashboard .dash-qty-unclassified-head,
      #dash_chart_overlay .dash-qty-unclassified-head {
        font-weight: 600;
        margin-bottom: 0.14rem;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-mode,
      #dash_chart_overlay .dash-qty-unclassified-mode {
        font-size: 0.77rem;
        color: rgba(182,207,255,0.92);
        margin-bottom: 0.3rem;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-list,
      #dash_chart_overlay .dash-qty-unclassified-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.2rem;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-item,
      #dash_chart_overlay .dash-qty-unclassified-item {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 0.4rem;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-name,
      #dash_chart_overlay .dash-qty-unclassified-name {
        flex: 1;
        min-width: 0;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-meta,
      #dash_chart_overlay .dash-qty-unclassified-meta {
        flex-shrink: 0;
        opacity: 0.78;
        font-size: 0.76rem;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-action,
      #dash_chart_overlay .dash-qty-unclassified-action {
        appearance: none;
        border: 0;
        background: transparent;
        color: #35c5ff;
        font-size: 0.76rem;
        text-decoration: underline;
        text-underline-offset: 0.14rem;
        padding: 0;
        line-height: 1.2;
        cursor: pointer;
        opacity: 0.96;
        transition: color 150ms ease, opacity 150ms ease;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-action:hover,
      #stock-analytics-dashboard .dash-qty-unclassified-action:focus,
      #dash_chart_overlay .dash-qty-unclassified-action:hover,
      #dash_chart_overlay .dash-qty-unclassified-action:focus {
        color: #8ce6ff;
        opacity: 1;
        outline: none;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-action.is-busy,
      #dash_chart_overlay .dash-qty-unclassified-action.is-busy {
        color: rgba(141, 166, 196, 0.95);
        pointer-events: none;
      }
      #stock-analytics-dashboard .dash-qty-unclassified-more,
      #dash_chart_overlay .dash-qty-unclassified-more {
        font-size: 0.76rem;
        opacity: 0.78;
      }
      #dash_qty_lookup_picker {
        position: fixed;
        inset: 0;
        z-index: 2650;
        background: rgba(7, 10, 14, 0.64);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1rem;
      }
      #dash_qty_lookup_picker .dash-qty-lookup-card {
        width: min(780px, 96vw);
        max-height: 86vh;
        overflow: auto;
        border: 1px solid rgba(116, 178, 255, 0.36);
        border-radius: 0.72rem;
        background: linear-gradient(162deg, rgba(17, 23, 33, 0.96), rgba(14, 20, 30, 0.94));
        box-shadow: 0 28px 60px rgba(0, 0, 0, 0.42);
      }
      #dash_qty_lookup_picker .dash-qty-lookup-head {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.7rem;
        padding: 0.82rem 0.95rem 0.48rem;
        border-bottom: 1px solid rgba(255,255,255,0.1);
      }
      #dash_qty_lookup_picker .dash-qty-lookup-title {
        font-weight: 700;
        font-size: 1rem;
        line-height: 1.2;
      }
      #dash_qty_lookup_picker .dash-qty-lookup-sub {
        margin-top: 0.2rem;
        color: rgba(188, 208, 236, 0.92);
        font-size: 0.86rem;
      }
      #dash_qty_lookup_picker .dash-qty-lookup-body {
        padding: 0.72rem 0.9rem 0.92rem;
        display: grid;
        gap: 0.54rem;
      }
      #dash_qty_lookup_picker .dash-qty-lookup-item {
        border: 1px solid rgba(131, 178, 245, 0.24);
        border-radius: 0.56rem;
        padding: 0.58rem 0.65rem;
        background: rgba(255,255,255,0.03);
      }
      #dash_qty_lookup_picker .dash-qty-lookup-main {
        font-size: 0.92rem;
        font-weight: 600;
        color: rgba(236, 246, 255, 0.95);
      }
      #dash_qty_lookup_picker .dash-qty-lookup-meta {
        margin-top: 0.18rem;
        color: rgba(174, 198, 230, 0.94);
        font-size: 0.78rem;
      }
      #dash_qty_lookup_picker .dash-qty-lookup-basis {
        margin-top: 0.18rem;
        color: rgba(149, 171, 199, 0.9);
        font-size: 0.76rem;
      }
      #dash_qty_lookup_picker .dash-qty-lookup-actions {
        margin-top: 0.4rem;
      }
      #dash_qty_lookup_picker .dash-qty-lookup-actions .btn {
        min-width: 108px;
      }
      #dash_chart_overlay_focus_local .dash-focus-links-title {
        font-weight: 600;
        margin-bottom: 0.3rem;
        opacity: 0.95;
      }
      #dash_chart_overlay_focus_local .dash-focus-links-wrap {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.42rem;
      }
      #dash_chart_overlay .dash-focus-local {
        display: grid;
        grid-template-columns: minmax(86px, 124px) minmax(0, 1fr);
        gap: 0.75rem;
        align-items: start;
      }
      #dash_chart_overlay .dash-focus-local-left {
        display: grid;
        gap: 0.46rem;
        align-self: start;
      }
      #dash_chart_overlay .dash-focus-local-logo {
        width: 100%;
        min-height: 90px;
        max-height: 150px;
        border-radius: 0.6rem;
        border: 1px solid rgba(255,255,255,0.18);
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(13,18,24,0.5);
        overflow: hidden;
      }
      #dash_chart_overlay .dash-focus-local-logo.is-clickable {
        cursor: pointer;
        box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        transition: border-color 0.16s ease, box-shadow 0.16s ease, transform 0.16s ease;
      }
      #dash_chart_overlay .dash-focus-local-logo.is-clickable:hover,
      #dash_chart_overlay .dash-focus-local-logo.is-clickable:focus {
        border-color: rgba(13,110,253,0.76);
        box-shadow: 0 10px 20px rgba(13,110,253,0.2);
        transform: translateY(-1px);
      }
      #dash_chart_overlay .dash-focus-local-logo img {
        max-width: 100%;
        max-height: 140px;
        object-fit: contain;
        display: block;
      }
      #dash_chart_overlay .dash-focus-local-logo .dash-focus-local-fallback {
        font-weight: 700;
        font-size: 1.2rem;
        color: rgba(220,235,255,0.85);
      }
      #dash_chart_overlay .dash-focus-local-products {
        max-height: 0;
        opacity: 0;
        transform: translateY(-10px);
        overflow: hidden;
        transition: max-height 0.28s ease, opacity 0.24s ease, transform 0.24s ease;
      }
      #dash_chart_overlay .dash-focus-local-products.is-open {
        max-height: 28rem;
        opacity: 1;
        transform: translateY(0);
      }
      #dash_chart_overlay .dash-focus-bucket-list {
        display: grid;
        gap: 0.32rem;
      }
      #dash_chart_overlay .dash-focus-bucket-list.is-scrollable {
        max-height: 22rem;
        overflow-y: auto;
        overflow-x: hidden;
        padding-right: 0.14rem;
      }
      #dash_chart_overlay .dash-focus-bucket-item {
        position: relative;
        border: 1px solid rgba(255,255,255,0.18);
        border-radius: 0.46rem;
        background: linear-gradient(150deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        box-shadow: 0 6px 14px rgba(0,0,0,0.16);
        transition: border-color 0.16s ease, background 0.16s ease, box-shadow 0.16s ease, transform 0.16s ease;
      }
      #dash_chart_overlay .dash-focus-bucket-item.is-cascade {
        animation: dashFocusBucketCascade 0.28s ease both;
        animation-delay: var(--dash-cascade-delay, 0ms);
      }
      #dash_chart_overlay .dash-focus-bucket-item.is-selected {
        border-color: rgba(13,110,253,0.82);
        background: linear-gradient(150deg, rgba(13,110,253,0.3), rgba(13,110,253,0.12));
        box-shadow: 0 8px 18px rgba(13,110,253,0.2);
      }
      #dash_chart_overlay .dash-focus-bucket-product-btn {
        width: 100%;
        margin: 0;
        padding: 0.2rem;
        border: 0;
        border-radius: 0.46rem;
        background: transparent;
        color: inherit;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        gap: 0.24rem;
        text-align: center;
      }
      #dash_chart_overlay .dash-focus-bucket-product-btn:hover,
      #dash_chart_overlay .dash-focus-bucket-product-btn:focus {
        outline: none;
      }
      #dash_chart_overlay .dash-focus-bucket-product-btn:not(:disabled):hover,
      #dash_chart_overlay .dash-focus-bucket-product-btn:not(:disabled):focus {
        border-color: rgba(13,110,253,0.75);
        background: linear-gradient(150deg, rgba(13,110,253,0.26), rgba(13,110,253,0.09));
        box-shadow: 0 8px 18px rgba(13,110,253,0.2);
        transform: translateY(-1px);
        cursor: pointer;
      }
      #dash_chart_overlay .dash-focus-bucket-product-btn:disabled {
        cursor: default;
      }
      #dash_chart_overlay .dash-focus-bucket-thumb {
        width: 100%;
        height: 2.6rem;
        border-radius: 0.36rem;
        border: 1px solid rgba(255,255,255,0.28);
        overflow: hidden;
        flex-shrink: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(145deg, rgba(53,61,78,0.95), rgba(22,28,41,0.95));
      }
      #dash_chart_overlay .dash-focus-bucket-thumb img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }
      #dash_chart_overlay .dash-focus-bucket-thumb-fallback {
        font-weight: 700;
        font-size: 0.86rem;
        color: rgba(221,236,255,0.92);
        text-transform: uppercase;
      }
      #dash_chart_overlay .dash-focus-bucket-main {
        min-width: 0;
        flex: 0 0 auto;
        display: flex;
        flex-direction: column;
        gap: 0;
        border-top: 1px solid rgba(255,255,255,0.1);
        padding-top: 0.2rem;
      }
      #dash_chart_overlay .dash-focus-bucket-name {
        display: block;
        font-weight: 600;
        font-size: 0.58rem;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      #dash_chart_overlay .dash-focus-bucket-meta {
        display: none;
      }
      #dash_chart_overlay .dash-focus-bucket-item.has-expand::before {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 0.52rem;
        background: rgba(12,18,26,0.44);
        opacity: 0;
        transition: opacity 0.16s ease;
        pointer-events: none;
      }
      #dash_chart_overlay .dash-focus-bucket-item.has-expand:hover::before,
      #dash_chart_overlay .dash-focus-bucket-item.has-expand:focus-within::before {
        opacity: 1;
      }
      #dash_chart_overlay .dash-focus-bucket-see-more {
        position: absolute;
        right: 0.42rem;
        bottom: 0.36rem;
        border: 1px solid rgba(13,110,253,0.74);
        border-radius: 999px;
        background: linear-gradient(145deg, rgba(13,110,253,0.46), rgba(13,110,253,0.22));
        color: #e7f0ff;
        font-size: 0.72rem;
        font-weight: 700;
        line-height: 1.05;
        padding: 0.14rem 0.46rem;
        opacity: 0;
        transform: translateY(3px);
        transition: opacity 0.16s ease, transform 0.16s ease;
      }
      #dash_chart_overlay .dash-focus-bucket-item.has-expand:hover .dash-focus-bucket-see-more,
      #dash_chart_overlay .dash-focus-bucket-item.has-expand:focus-within .dash-focus-bucket-see-more {
        opacity: 1;
        transform: translateY(0);
      }
      #dash_chart_overlay .dash-focus-bucket-show-all {
        position: absolute;
        right: 0.34rem;
        bottom: 0.28rem;
        border: 1px solid rgba(32,201,151,0.72);
        border-radius: 999px;
        background: linear-gradient(145deg, rgba(32,201,151,0.38), rgba(13,110,253,0.16));
        color: rgba(226,251,243,0.98);
        font-size: 0.7rem;
        font-weight: 700;
        line-height: 1.05;
        padding: 0.14rem 0.44rem;
        opacity: 0;
        transform: translateY(2px);
        transition: opacity 0.15s ease, transform 0.15s ease;
      }
      #dash_chart_overlay .dash-focus-bucket-item:hover .dash-focus-bucket-show-all,
      #dash_chart_overlay .dash-focus-bucket-item:focus-within .dash-focus-bucket-show-all {
        opacity: 1;
        transform: translateY(0);
      }
      @keyframes dashFocusBucketCascade {
        from {
          opacity: 0;
          transform: translateY(-8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      #dash_chart_overlay .dash-focus-local-stats {
        display: grid;
        gap: 0.25rem;
      }
      #dash_chart_overlay .dash-focus-local-stat {
        display: grid;
        grid-template-columns: minmax(120px, 1fr) minmax(0, 1.7fr);
        align-items: center;
        gap: 0.55rem;
        border-bottom: 1px dashed rgba(255,255,255,0.08);
        padding-bottom: 0.2rem;
      }
      #dash_chart_overlay .dash-focus-local-stat-key {
        opacity: 0.75;
        min-width: 0;
      }
      #dash_chart_overlay .dash-focus-local-stat-tail {
        display: inline-flex;
        flex-wrap: wrap;
        align-items: flex-end;
        justify-content: flex-end;
        gap: 0.34rem;
        min-width: 0;
      }
      #dash_chart_overlay .dash-focus-local-stat-tail strong {
        text-align: right;
        line-height: 1.15;
      }
      #dash_chart_overlay .dash-focus-local-stat-qty .dash-focus-local-stat-tail {
        align-items: center;
      }
      #dash_chart_overlay .dash-focus-qty-controls {
        display: inline-flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 0.24rem;
      }
      #dash_chart_overlay .dash-focus-qty-controls .btn {
        border-color: rgba(255,255,255,0.26);
        min-height: 1.78rem;
      }
      #dash_chart_overlay .dash-focus-qty-controls .dash-qty-mode-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.3rem;
      }
      #dash_chart_overlay .dash-focus-qty-controls .dash-qty-mode-btn i {
        font-size: 0.8rem;
        line-height: 1;
      }
      #dash_chart_overlay .dash-focus-qty-controls .dash-qty-mode-btn .dash-qty-mode-label {
        line-height: 1;
      }
      #dash_chart_overlay .dash-focus-qty-controls .btn.chart-ctl-active,
      #dash_chart_overlay .dash-focus-qty-controls .btn.is-active {
        background: rgba(13,110,253,0.28);
        border-color: rgba(13,110,253,0.8);
        color: #d8e8ff;
        box-shadow: 0 6px 14px rgba(13,110,253,0.18);
      }
      #dash_chart_overlay .dash-focus-local-stat-anchor .dash-focus-local-stat-tail strong {
        color: rgba(219,241,255,0.96);
        font-weight: 600;
      }
      #dash_chart_overlay .dash-focus-random-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.28rem;
        border-color: rgba(255,255,255,0.26);
        min-height: 1.72rem;
      }
      #dash_chart_overlay .dash-focus-random-btn i {
        font-size: 0.78rem;
        line-height: 1;
      }
      #dash_chart_overlay .dash-focus-random-btn:hover,
      #dash_chart_overlay .dash-focus-random-btn:focus {
        border-color: rgba(13,110,253,0.78);
        color: #d8e8ff;
        background: rgba(13,110,253,0.2);
      }
      #dash_chart_overlay .dash-focus-local-stat:last-child {
        border-bottom: none;
      }
      #dash_chart_overlay .dash-focus-ai-actions {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
      }
      #dash_chart_overlay_focus_ai.is-collapsed #dash_chart_overlay_focus_ai_body {
        display: none;
      }
      @media (max-width: 767.98px) {
        #dash_chart_overlay .dash-focus-local {
          grid-template-columns: 1fr;
        }
        #dash_chart_overlay .dash-focus-local-logo {
          max-width: 180px;
        }
        #dash_chart_overlay .dash-focus-local-products.is-open {
          max-height: 16rem;
        }
        #dash_chart_overlay .dash-focus-local-stat {
          grid-template-columns: 1fr;
          gap: 0.32rem;
        }
        #dash_chart_overlay .dash-focus-local-stat-tail {
          width: 100%;
          justify-content: flex-end;
        }
        #dash_chart_overlay .dash-focus-qty-controls {
          justify-content: flex-end;
        }
      }
      #dash_chart_overlay .card {
        border: 1px solid rgba(255,255,255,0.15);
        height: calc(100vh - 2rem);
        max-height: calc(100vh - 2rem);
      }
      #dash_chart_overlay .card-header {
        border-bottom: 1px solid rgba(255,255,255,0.14);
        background: linear-gradient(125deg, rgba(13,110,253,0.2), rgba(32,201,151,0.15), rgba(255,255,255,0.03));
      }
      #dash_chart_overlay_title {
        display: inline-flex;
        align-items: center;
        gap: 0.62rem;
        min-width: 0;
        max-width: calc(100% - 7.2rem);
        word-break: break-word;
        margin: 0;
        padding: 0.02rem 0.02rem 0.06rem;
        font-size: 1.34rem;
        font-weight: 800;
        line-height: 1.18;
        letter-spacing: 0.012em;
        color: rgba(236, 245, 255, 0.99);
        text-shadow: 0 1px 0 rgba(0,0,0,0.32);
      }
      #dash_chart_overlay_title::before {
        content: '';
        width: 0.34rem;
        height: 1.56rem;
        border-radius: 999px;
        background: linear-gradient(180deg, rgba(13,110,253,0.95), rgba(32,201,151,0.88));
        box-shadow: 0 0 0 1px rgba(255,255,255,0.14), 0 8px 16px rgba(0,0,0,0.22);
        flex: 0 0 auto;
      }
      #dash_chart_overlay .card-header .btn {
        border-color: rgba(255,255,255,0.26);
        min-height: 2.02rem;
        padding: 0.2rem 0.72rem;
        font-weight: 600;
      }
      #dash_chart_overlay .card-header .btn:hover,
      #dash_chart_overlay .card-header .btn:focus {
        border-color: rgba(13,110,253,0.74);
        background: rgba(13,110,253,0.18);
        color: #d9e8ff;
      }
      @media (max-width: 991.98px) {
        #dash_chart_overlay_title {
          font-size: 1.14rem;
        }
        #dash_chart_overlay_title::before {
          height: 1.3rem;
        }
      }
      body.dash-overlay-open {
        overflow: hidden !important;
      }
      #dash_chart_overlay {
        overscroll-behavior: contain;
        overflow: hidden;
      }
      #dash_chart_overlay .card-body {
        overflow-y: auto;
        overflow-x: hidden;
        min-height: 0;
        overscroll-behavior: contain;
      }
      #dash_chart_overlay .dash-overlay-box {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.6rem;
        background: linear-gradient(160deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        box-shadow: 0 12px 26px rgba(0,0,0,0.2);
      }
      #dash_chart_overlay .dash-overlay-box-title {
        font-weight: 600;
        font-size: 0.95rem;
        letter-spacing: 0.01em;
      }
      #dash_chart_overlay .dash-overlay-section-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.55rem;
      }
      #dash_chart_overlay .dash-overlay-toggle-btn {
        border-color: rgba(255,255,255,0.24);
        min-width: 8.3rem;
      }
      #dash_chart_overlay .dash-overlay-toggle-btn:hover,
      #dash_chart_overlay .dash-overlay-toggle-btn:focus {
        border-color: rgba(13,110,253,0.78);
        color: #cfe2ff;
        background: rgba(13,110,253,0.2);
      }
      #dash_chart_overlay .dash-overlay-controls {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.32rem;
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.55rem;
        padding: 0.38rem 0.42rem;
        background: linear-gradient(150deg, rgba(13,110,253,0.14), rgba(255,255,255,0.025));
        box-shadow: 0 8px 18px rgba(0,0,0,0.17);
      }
      #dash_chart_overlay .dash-overlay-controls-label {
        font-size: 0.82rem;
        font-weight: 600;
        color: rgba(207,226,255,0.88);
        margin-right: 0.2rem;
      }
      #dash_chart_overlay .dash-overlay-controls .btn-group {
        box-shadow: 0 3px 8px rgba(0,0,0,0.16);
        border-radius: 0.45rem;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-qty-mode-wrap {
        display: inline-flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.26rem;
        padding: 0.14rem 0.2rem;
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.5rem;
        background: linear-gradient(145deg, rgba(255,255,255,0.04), rgba(255,255,255,0.015));
      }
      #dash_chart_overlay .dash-overlay-controls .dash-qty-mode-wrap .btn-group {
        box-shadow: none;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-qty-total-chip {
        min-height: 1.72rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.12rem 0.52rem;
        border-radius: 0.4rem;
        border: 1px solid rgba(32,201,151,0.58);
        background: linear-gradient(145deg, rgba(32,201,151,0.21), rgba(13,110,253,0.17));
        color: rgba(214,247,239,0.98);
        font-weight: 600;
        font-size: 0.76rem;
        line-height: 1.1;
        white-space: nowrap;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-chart-type-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.32rem;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-chart-type-btn .dash-chart-type-label {
        display: inline;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-sort-btn {
        min-width: 2.32rem;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-sort-btn i {
        font-size: 0.8rem;
        line-height: 1;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-qty-mode-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.34rem;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-qty-mode-btn i {
        font-size: 0.86rem;
        line-height: 1;
      }
      #dash_chart_overlay .dash-overlay-controls .dash-qty-mode-btn .dash-qty-mode-label {
        line-height: 1;
      }
      #dash_chart_overlay .dash-overlay-controls .btn {
        border-color: rgba(255,255,255,0.24);
        min-height: 1.72rem;
        font-weight: 600;
        letter-spacing: 0;
        font-size: 0.84rem;
        line-height: 1.1;
        padding: 0.12rem 0.44rem;
      }
      #dash_chart_overlay .dash-overlay-controls .btn.chart-ctl-active {
        background: rgba(13,110,253,0.34);
        border-color: rgba(13,110,253,0.82);
        color: #d9e8ff;
      }
      #dash_chart_overlay .dash-overlay-controls .btn.chart-ctl-active:hover,
      #dash_chart_overlay .dash-overlay-controls .btn.chart-ctl-active:focus {
        color: #ffffff;
        border-color: rgba(110,168,254,0.95);
      }
      #dash_chart_overlay .dash-overlay-controls .btn:hover,
      #dash_chart_overlay .dash-overlay-controls .btn:focus {
        border-color: rgba(13,110,253,0.72);
        color: #cfe2ff;
        background: rgba(13,110,253,0.2);
      }
      #dash_chart_overlay .dash-overlay-box-body {
        max-height: 21vh;
        overflow: auto;
      }
      #dash_chart_overlay .dash-overlay-insight-list {
        display: grid;
        gap: 0.36rem;
      }
      #dash_chart_overlay .dash-overlay-insight-item {
        display: flex;
        align-items: flex-start;
        gap: 0.42rem;
        padding: 0.28rem 0.34rem;
        border-radius: 0.45rem;
        border: 1px solid transparent;
        transition: border-color 0.14s ease, background 0.14s ease, box-shadow 0.14s ease;
      }
      #dash_chart_overlay .dash-overlay-insight-item[data-detail-index] {
        cursor: pointer;
      }
      #dash_chart_overlay .dash-overlay-insight-item[data-detail-index]:hover,
      #dash_chart_overlay .dash-overlay-insight-item[data-detail-index]:focus,
      #dash_chart_overlay .dash-overlay-insight-item.is-active {
        border-color: var(--dash-active-color, rgba(13,110,253,0.55));
        background: linear-gradient(150deg, var(--dash-active-color-faint, rgba(13,110,253,0.18)), rgba(255,255,255,0.02));
        box-shadow: 0 0 0 1px var(--dash-active-color-soft, rgba(13,110,253,0.24)) inset, 0 6px 14px rgba(0,0,0,0.2);
        outline: none;
      }
      #dash_chart_overlay .dash-overlay-insight-bullet {
        color: #9ec5fe;
        opacity: 0.9;
        margin-top: 0.02rem;
      }
      #dash_chart_overlay .dash-overlay-insight-text {
        flex: 1;
        line-height: 1.32;
      }
      #dash_chart_overlay .dash-overlay-chart-wrap {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.6rem;
        background: linear-gradient(160deg, rgba(255,255,255,0.035), rgba(255,255,255,0.01));
      }
      #dash_chart_overlay .dash-overlay-legend-item {
        display: flex;
        align-items: flex-start;
        margin-bottom: 0.45rem;
        border: 1px solid transparent;
        border-radius: 0.45rem;
        padding: 0.22rem 0.3rem;
        transition: border-color 0.14s ease, background 0.14s ease;
      }
      #dash_chart_overlay .dash-overlay-legend-item[data-detail-index] {
        cursor: pointer;
      }
      #dash_chart_overlay .dash-overlay-legend-item[data-detail-index]:hover,
      #dash_chart_overlay .dash-overlay-legend-item[data-detail-index]:focus,
      #dash_chart_overlay .dash-overlay-legend-item.is-active {
        border-color: var(--dash-active-color, rgba(13,110,253,0.55));
        background: linear-gradient(150deg, var(--dash-active-color-faint, rgba(13,110,253,0.18)), rgba(255,255,255,0.02));
        box-shadow: 0 0 0 1px var(--dash-active-color-soft, rgba(13,110,253,0.22)) inset, 0 6px 14px rgba(0,0,0,0.18);
      }
      #dash_chart_overlay .dash-overlay-legend-dot {
        width: 0.75rem;
        height: 0.75rem;
        border-radius: 0.2rem;
        margin-right: 0.5rem;
        margin-top: 0.18rem;
        flex-shrink: 0;
      }
      #dash_chart_overlay .dash-overlay-legend-main {
        line-height: 1.25;
      }
      #dash_chart_overlay .dash-overlay-legend-value {
        opacity: 0.88;
        font-size: 0.86rem;
      }
      #dash_chart_overlay_details {
        white-space: normal;
        line-height: 1.35;
        padding: 0.1rem;
        transition: max-height 0.2s ease;
      }
      #dash_chart_overlay .dash-detail-list {
        display: grid;
        gap: 0.45rem;
        padding: 0.05rem;
      }
      #dash_chart_overlay .dash-detail-item {
        display: flex;
        align-items: flex-start;
        gap: 0.55rem;
        padding: 0.45rem 0.55rem;
        border: 1px solid rgba(255,255,255,0.13);
        border-radius: 0.55rem;
        background: linear-gradient(150deg, rgba(255,255,255,0.05), rgba(255,255,255,0.015));
        transition: border-color 0.16s ease, box-shadow 0.16s ease, background 0.16s ease;
        cursor: pointer;
      }
      #dash_chart_overlay .dash-detail-item:hover,
      #dash_chart_overlay .dash-detail-item:focus,
      #dash_chart_overlay .dash-detail-item.is-active {
        border-color: var(--dash-active-color, rgba(13,110,253,0.72));
        background: linear-gradient(150deg, var(--dash-active-color-faint, rgba(13,110,253,0.2)), rgba(255,255,255,0.03));
        box-shadow: 0 0 0 1px var(--dash-active-color-soft, rgba(13,110,253,0.24)) inset, 0 8px 16px rgba(0,0,0,0.24);
      }
      #dash_chart_overlay .dash-detail-item:focus {
        outline: none;
      }
      #dash_chart_overlay .dash-overlay-fun-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 0.52rem;
      }
      #dash_chart_overlay .dash-overlay-fun-card {
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 0.58rem;
        padding: 0.08rem;
        background: linear-gradient(155deg, rgba(13,110,253,0.12), rgba(255,255,255,0.02));
        box-shadow: 0 10px 18px rgba(0,0,0,0.2);
      }
      #dash_chart_overlay .dash-overlay-fun-empty {
        font-size: 0.86rem;
        color: rgba(201,216,232,0.88);
      }
      #dash_chart_overlay .dash-overlay-fun-card .dash-kpi-fun-panel {
        border-color: rgba(91, 197, 255, 0.52);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.2);
        animation-duration: 360ms;
      }
      #dash_chart_overlay .dash-detail-dot {
        width: 0.62rem;
        height: 0.62rem;
        border-radius: 50%;
        margin-top: 0.32rem;
        flex-shrink: 0;
        border: 1px solid rgba(255,255,255,0.3);
      }
      #dash_chart_overlay .dash-detail-rank {
        min-width: 1.5rem;
        text-align: right;
        font-weight: 700;
        color: #9ec5fe;
        opacity: 0.95;
      }
      #dash_chart_overlay .dash-detail-main {
        flex: 1;
        min-width: 0;
      }
      #dash_chart_overlay .dash-detail-text {
        line-height: 1.34;
        display: block;
      }
      #dash_chart_overlay .dash-detail-thumbs {
        margin-left: auto;
        display: inline-flex;
        align-items: center;
        padding-left: 0.45rem;
      }
      #dash_chart_overlay .dash-detail-thumb {
        width: 1.55rem;
        height: 1.55rem;
        border-radius: 0.38rem;
        overflow: hidden;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-left: -0.32rem;
        border: 1px solid rgba(255,255,255,0.3);
        background: linear-gradient(145deg, rgba(53,61,78,0.95), rgba(22,28,41,0.95));
        color: #deebff;
        font-size: 0.74rem;
        font-weight: 700;
        box-shadow: 0 2px 7px rgba(0,0,0,0.28);
      }
      #dash_chart_overlay .dash-detail-thumb:first-child {
        margin-left: 0;
      }
      #dash_chart_overlay .dash-detail-thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      #dash_chart_overlay .dash-detail-thumb-fallback {
        text-transform: uppercase;
      }
      #dash_chart_overlay .dash-detail-item.is-active .dash-detail-dot,
      #dash_chart_overlay .dash-overlay-legend-item.is-active .dash-overlay-legend-dot {
        border-color: var(--dash-active-color, rgba(13,110,253,0.85));
        box-shadow: 0 0 0 2px var(--dash-active-color-soft, rgba(13,110,253,0.3)), 0 0 12px var(--dash-active-color-soft, rgba(13,110,253,0.3));
      }
      #dash_chart_overlay .dash-detail-item.is-active .dash-detail-rank {
        color: var(--dash-active-color, #9ec5fe);
        text-shadow: 0 0 10px var(--dash-active-color-soft, rgba(13,110,253,0.3));
      }
      #dash_chart_overlay .dash-focus-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      #dash_chart_overlay .dash-focus-kv {
        display: inline-block;
        margin-right: 0.7rem;
        margin-bottom: 0.35rem;
      }
      #dash_chart_overlay .dash-focus-k {
        opacity: 0.78;
        margin-right: 0.25rem;
      }
      #dash_chart_overlay_focus_ai {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.55rem;
        background: linear-gradient(160deg, rgba(13,110,253,0.1), rgba(255,255,255,0.02));
        padding: 0.6rem;
      }
      #dash_hover_preview {
        position: fixed;
        z-index: 2810;
        width: min(460px, calc(100vw - 1.6rem));
        border: 1px solid rgba(255,255,255,0.22);
        border-radius: 0.65rem;
        background: linear-gradient(150deg, rgba(23,28,34,0.98), rgba(33,39,46,0.98));
        box-shadow: 0 14px 28px rgba(0,0,0,0.36);
        padding: 0.56rem;
        color: rgba(233,238,245,0.97);
        font-size: 0.8rem;
        line-height: 1.25;
        pointer-events: none;
        user-select: none;
        backdrop-filter: blur(2px);
      }
      #dash_hover_preview .dash-hover-preview-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.42rem;
        margin-bottom: 0.38rem;
      }
      #dash_hover_preview .dash-hover-preview-title {
        font-weight: 700;
        color: #e8f1ff;
        letter-spacing: 0.01em;
      }
      #dash_hover_preview .dash-hover-preview-count {
        font-size: 0.74rem;
        color: rgba(191,207,224,0.9);
      }
      #dash_hover_preview .dash-hover-preview-section-title {
        margin: 0.16rem 0 0.34rem;
        font-size: 0.69rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: rgba(160,205,255,0.95);
        font-weight: 700;
      }
      #dash_hover_preview .dash-hover-preview-list {
        display: grid;
        gap: 0.3rem;
      }
      #dash_hover_preview .dash-hover-preview-item {
        display: flex;
        align-items: center;
        gap: 0.45rem;
        padding: 0.24rem 0.28rem;
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 0.45rem;
        background: linear-gradient(155deg, rgba(255,255,255,0.06), rgba(255,255,255,0.018));
      }
      #dash_hover_preview .dash-hover-preview-item.dash-hover-preview-item-tight {
        padding: 0.2rem 0.24rem;
      }
      #dash_hover_preview .dash-hover-preview-thumb {
        flex: 0 0 auto;
        width: 2rem;
        height: 2rem;
        border-radius: 0.45rem;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.08);
      }
      #dash_hover_preview .dash-hover-preview-thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      #dash_hover_preview .dash-hover-preview-thumb-fallback {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: #e8f1ff;
        font-size: 0.82rem;
        font-weight: 700;
      }
      #dash_hover_preview .dash-hover-preview-logo {
        flex: 0 0 auto;
        width: 2.35rem;
        height: 2.35rem;
        border-radius: 0.55rem;
        border: 1px solid rgba(255,255,255,0.24);
        background: rgba(255,255,255,0.08);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      #dash_hover_preview .dash-hover-preview-logo img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
        background: rgba(255,255,255,0.04);
      }
      #dash_hover_preview .dash-hover-preview-main {
        flex: 1 1 auto;
        min-width: 0;
      }
      #dash_hover_preview .dash-hover-preview-name {
        font-weight: 600;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      #dash_hover_preview .dash-hover-preview-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.24rem;
        margin-top: 0.16rem;
      }
      #dash_hover_preview .dash-hover-preview-chip {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
        padding: 0.1rem 0.3rem;
        border-radius: 0.35rem;
        border: 1px solid rgba(255,255,255,0.15);
        background: rgba(255,255,255,0.045);
        color: rgba(218,229,241,0.95);
        font-size: 0.7rem;
        line-height: 1.1;
      }
      #dash_hover_preview .dash-hover-preview-recipes {
        margin-top: 0.16rem;
        color: rgba(200,217,235,0.92);
        font-size: 0.7rem;
      }
      #dash_hover_preview .dash-hover-preview-recipes strong {
        color: rgba(233,244,255,0.98);
      }
      #dash_hover_preview .dash-hover-preview-range {
        margin-top: 0.16rem;
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        padding: 0.08rem 0.28rem;
        border-radius: 0.34rem;
        border: 1px solid rgba(255,255,255,0.15);
        background: rgba(255,255,255,0.045);
        color: rgba(226,237,248,0.98);
        font-size: 0.71rem;
      }
      #dash_hover_preview .dash-hover-preview-range .fa-arrow-down {
        color: rgba(102,181,255,0.98);
      }
      #dash_hover_preview .dash-hover-preview-range .fa-arrow-up {
        color: rgba(255,153,115,0.98);
      }
      #dash_hover_preview .dash-hover-preview-range-currency {
        margin-left: 0.1rem;
        font-weight: 700;
        color: rgba(183,223,255,0.98);
      }
      #dash_hover_preview .dash-hover-preview-due {
        font-size: 0.74rem;
        color: rgba(196,210,226,0.9);
      }
      #dash_hover_preview .dash-hover-preview-more,
      #dash_hover_preview .dash-hover-preview-empty {
        margin-top: 0.36rem;
        font-size: 0.74rem;
        color: rgba(185,202,220,0.88);
      }
      #dash_hover_preview .dash-hover-preview-fun-block {
        margin-top: 0.42rem;
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 0.5rem;
        padding: 0.3rem 0.38rem;
        background: linear-gradient(145deg, rgba(13,110,253,0.12), rgba(255,255,255,0.015));
      }
      #dash_hover_preview .dash-hover-preview-fun-title {
        font-size: 0.69rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.045em;
        color: rgba(183,223,255,0.96);
        margin-bottom: 0.18rem;
      }
      #dash_hover_preview .dash-hover-preview-fun-list {
        margin: 0;
        padding-left: 1.05rem;
        display: grid;
        gap: 0.1rem;
      }
      #dash_hover_preview .dash-hover-preview-fun-list li {
        font-size: 0.72rem;
        color: rgba(220,231,243,0.95);
      }
      #dash_hover_preview .dash-hover-preview-fun-list li strong {
        color: #d6ebff;
        margin-right: 0.15rem;
      }
      #dash_hover_preview .dash-hover-preview-fun-note {
        margin-top: 0.2rem;
        font-size: 0.71rem;
        color: rgba(196,221,244,0.94);
        border-top: 1px solid rgba(255,255,255,0.12);
        padding-top: 0.18rem;
      }
      #dash_ai_settings_overlay {
        position: fixed;
        inset: 0;
        z-index: 2700;
        background: rgba(0,0,0,0.64);
        padding: 1rem;
      }
      #dash_ai_settings_overlay .dash-ai-settings-card {
        max-width: 1020px;
        max-height: calc(100vh - 2rem);
        margin: 0 auto;
        border: 1px solid rgba(255,255,255,0.17);
        border-radius: 0.75rem;
        box-shadow: 0 14px 28px rgba(0,0,0,0.34);
        display: flex;
        flex-direction: column;
      }
      #dash_ai_settings_overlay .dash-ai-settings-card .card-header {
        background: linear-gradient(145deg, rgba(13,110,253,0.2), rgba(32,201,151,0.15));
      }
      #dash_ai_settings_overlay .dash-ai-settings-card .card-body {
        overflow: auto;
      }
      #dash_ai_settings_overlay .dash-settings-section {
        border: 1px solid rgba(255,255,255,0.14);
        border-radius: 0.62rem;
        background: linear-gradient(155deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      }
      #dash_ai_settings_overlay .dash-ai-settings-hint {
        opacity: 0.85;
      }
      #dash_ai_settings_overlay #dash_ai_fallback_section.d-none {
        display: none !important;
      }
      #dash_ai_settings_overlay .dash-lang-switch .btn {
        flex: 1 1 auto;
        border: 0;
        border-right: 1px solid rgba(255,255,255,0.18);
        border-radius: 0;
        background: rgba(255,255,255,0.03);
        color: rgba(255,255,255,0.9);
        min-height: 2.2rem;
        font-weight: 600;
        letter-spacing: 0.01em;
        transition: background 0.16s ease, color 0.16s ease, border-color 0.16s ease;
      }
      #dash_ai_settings_overlay .dash-lang-switch .btn:last-child {
        border-right: 0;
      }
      #dash_ai_settings_overlay .dash-lang-switch {
        border: 1px solid rgba(255,255,255,0.24);
        border-radius: 0.5rem;
        overflow: hidden;
        background: rgba(255,255,255,0.02);
      }
      #dash_ai_settings_overlay .dash-lang-switch .btn:hover {
        background: rgba(13,110,253,0.16);
        color: #cfe2ff;
      }
      #dash_ai_settings_overlay .dash-lang-switch .btn.is-active {
        background: linear-gradient(150deg, rgba(13,110,253,0.86), rgba(13,110,253,0.68));
        border-color: rgba(13,110,253,0.9);
        color: #ffffff;
        box-shadow: inset 0 -1px 0 rgba(255,255,255,0.2);
      }
      #dash_ai_settings_overlay .dash-lang-switch .btn:focus {
        outline: none;
        box-shadow: inset 0 0 0 1px rgba(207,226,255,0.65);
      }
      #dash_ai_provider_forms {
        max-height: 42vh;
        overflow: auto;
        padding-right: 0.2rem;
      }
      #dash_ai_settings_overlay .dash-ai-provider-card {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.6rem;
        background: linear-gradient(155deg, rgba(255,255,255,0.05), rgba(255,255,255,0.015));
        padding: 0.55rem 0.65rem;
      }
      #dash_ai_settings_overlay .dash-ai-provider-card + .dash-ai-provider-card {
        margin-top: 0.6rem;
      }
      #dash_ai_settings_overlay .dash-ai-provider-card summary {
        cursor: pointer;
        list-style: none;
        outline: none;
      }
      #dash_ai_settings_overlay .dash-ai-provider-card summary::-webkit-details-marker {
        display: none;
      }
      #dash_ai_settings_overlay .dash-ai-provider-summary {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.6rem;
        font-weight: 600;
      }
      #dash_ai_settings_overlay .badge-warning {
        background: linear-gradient(150deg, #f3c969, #e7a73a);
        color: #2d1b0f;
      }
      #dash_ai_settings_overlay .dash-ai-provider-links {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        align-items: center;
        margin: 0.35rem 0 0.55rem;
      }
      #dash_ai_settings_overlay .dash-ai-provider-links-title {
        opacity: 0.72;
        margin-right: 0.2rem;
      }
      #dash_ai_settings_overlay .dash-ai-provider-links-items {
        display: inline-flex;
        gap: 0.35rem;
        flex-wrap: wrap;
      }
      #dash_ai_settings_overlay .dash-ai-provider-link {
        border: 1px solid rgba(255,255,255,0.18);
        border-radius: 999px;
        padding: 0.12rem 0.55rem;
        color: rgba(214,228,246,0.95);
        text-decoration: none;
        font-size: 0.74rem;
        background: rgba(15,23,32,0.35);
      }
      #dash_ai_settings_overlay .dash-ai-provider-link:hover {
        text-decoration: none;
        border-color: rgba(255,255,255,0.35);
        background: rgba(35,48,66,0.55);
      }
      #dash_ai_settings_overlay .dash-ai-provider-active {
        border-color: rgba(13,110,253,0.72);
        box-shadow: 0 0 0 1px rgba(13,110,253,0.25) inset;
      }
      #dash_ai_settings_overlay .dash-ai-provider-fields .form-group {
        margin-bottom: 0.5rem;
      }
      #dash_ai_settings_overlay .form-control.is-invalid {
        border-color: rgba(220,53,69,0.75);
        box-shadow: 0 0 0 1px rgba(220,53,69,0.2);
      }
      #dash_ai_settings_overlay .dash-ai-provider-help {
        opacity: 0.82;
      }
      #dash_ai_settings_overlay .dash-ai-provider-card.dash-ai-provider-rejected {
        border-color: rgba(220,53,69,0.72);
        box-shadow: 0 0 0 1px rgba(220,53,69,0.24) inset;
      }
      #dash_ai_settings_overlay .dash-ai-provider-card.dash-ai-provider-validated {
        border-color: rgba(25,135,84,0.72);
        box-shadow: 0 0 0 1px rgba(25,135,84,0.24) inset;
      }
      #dash_ai_settings_overlay .dash-ai-provider-validation-msg {
        margin-top: 0.35rem;
        font-size: 0.82rem;
      }
      #dash_ai_settings_overlay .dash-ai-provider-validation-msg.text-danger {
        color: #f8b2bc !important;
      }
      #dash_ai_settings_overlay .dash-ai-provider-validation-msg.text-success {
        color: #b2f2d8 !important;
      }
      #dash_ai_settings_overlay .dash-ai-field-error {
        min-height: 1.05rem;
      }
      #dash_ai_settings_overlay .dash-validation-switch .btn {
        flex: 1 1 auto;
      }
      #dash_ai_settings_overlay .dash-brand-logo-settings {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.62rem;
        background: linear-gradient(155deg, rgba(13,110,253,0.08), rgba(255,255,255,0.015));
      }
      #dash_ai_settings_overlay .dash-brand-logo-preview {
        border: 1px dashed rgba(255,255,255,0.24);
        border-radius: 0.5rem;
        min-height: 2.1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      #dash_ai_settings_overlay .dash-brand-logo-preview .dash-brand-logo-inline {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 1.35rem;
        height: 1.35rem;
        border-radius: 50%;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.35);
      }
      #dash_ai_settings_overlay .dash-brand-logo-preview .dash-brand-logo-inline img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      #dash_ai_settings_overlay .dash-brand-logo-combo {
        position: relative;
      }
      #dash_ai_settings_overlay .dash-brand-logo-combo .input-group .btn {
        border-color: rgba(255,255,255,0.24);
      }
      #dash_ai_settings_overlay .dash-brand-logo-combo .input-group .btn.is-open {
        border-color: rgba(13,110,253,0.78);
        background: rgba(13,110,253,0.22);
        color: #d8e8ff;
      }
      #dash_ai_settings_overlay .dash-brand-logo-menu {
        position: absolute;
        z-index: 35;
        top: calc(100% + 0.28rem);
        left: 0;
        right: 0;
        max-height: 13.5rem;
        overflow: auto;
        border: 1px solid rgba(255,255,255,0.22);
        border-radius: 0.52rem;
        background: linear-gradient(160deg, rgba(24,28,32,0.98), rgba(35,40,46,0.98));
        box-shadow: 0 14px 28px rgba(0,0,0,0.34);
        padding: 0.2rem;
      }
      #dash_ai_settings_overlay .dash-brand-logo-menu .dash-brand-logo-menu-item {
        width: 100%;
        text-align: left;
        border: 1px solid transparent;
        border-radius: 0.44rem;
        background: transparent;
        color: #dfe7f2;
        padding: 0.34rem 0.5rem;
        font-size: 0.83rem;
        line-height: 1.2;
        transition: border-color 0.14s ease, background 0.14s ease, color 0.14s ease;
      }
      #dash_ai_settings_overlay .dash-brand-logo-menu .dash-brand-logo-menu-item:hover,
      #dash_ai_settings_overlay .dash-brand-logo-menu .dash-brand-logo-menu-item:focus {
        border-color: rgba(13,110,253,0.72);
        background: rgba(13,110,253,0.2);
        color: #e5efff;
      }
      #dash_ai_settings_overlay .dash-brand-logo-menu-empty {
        color: rgba(209,216,226,0.84);
        padding: 0.28rem 0.45rem;
        font-size: 0.82rem;
      }
      #dash_ai_settings_overlay .dash-brand-logo-preview-open {
        width: 100%;
        border: 0;
        background: transparent;
        color: inherit;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        text-align: left;
        padding: 0;
        cursor: zoom-in;
      }
      #dash_ai_settings_overlay .dash-brand-logo-preview-open:hover .dash-brand-logo-preview-name {
        color: #dbeafe;
      }
      #dash_ai_settings_overlay .dash-brand-logo-preview-name {
        font-weight: 600;
      }
      #dash_ai_settings_overlay .dash-brand-logo-preview-source {
        opacity: 0.84;
      }
      #dash_ai_settings_overlay #dash_brand_logo_zoom {
        border-radius: 999px;
      }
      #dash_brand_logo_lightbox {
        position: fixed;
        inset: 0;
        z-index: 4000;
        background: rgba(0,0,0,0.76);
        padding: 1.2rem;
      }
      #dash_brand_logo_lightbox .dash-brand-logo-lightbox-card {
        max-width: 880px;
        margin: 0 auto;
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 0.72rem;
        background: linear-gradient(150deg, rgba(28,34,41,0.98), rgba(22,27,33,0.98));
        box-shadow: 0 20px 44px rgba(0,0,0,0.38);
      }
      #dash_brand_logo_lightbox .dash-brand-logo-lightbox-preview {
        min-height: 220px;
        max-height: 66vh;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(255,255,255,0.14);
        border-radius: 0.62rem;
        background: rgba(255,255,255,0.02);
        overflow: hidden;
      }
      #dash_brand_logo_lightbox .dash-brand-logo-lightbox-preview img {
        max-width: 100%;
        max-height: 64vh;
        object-fit: contain;
        display: block;
      }
      #dash_brand_logo_lightbox .dash-brand-logo-lightbox-meta {
        font-size: 0.86rem;
        opacity: 0.9;
      }
      #dash_addon_compat_mapping_modal {
        position: fixed;
        inset: 0;
        z-index: 4100;
        background: rgba(0,0,0,0.72);
        padding: 1.1rem;
        overflow-y: auto;
      }
      #dash_addon_compat_mapping_modal .dash-addon-compat-mapping-card {
        max-width: 860px;
        margin: 0 auto;
        border: 1px solid rgba(255,255,255,0.18);
        border-radius: 0.72rem;
        background: linear-gradient(150deg, rgba(28,34,41,0.98), rgba(22,27,33,0.98));
        box-shadow: 0 20px 44px rgba(0,0,0,0.38);
      }
      #dash_addon_compat_mapping_modal .dash-addon-compat-mapping-card .card-body {
        max-height: 68vh;
        overflow-y: auto;
      }
      #dash_ai_settings_overlay #dash_donne_settings_tabs {
        position: sticky;
        top: 0;
        z-index: 3;
        background: rgba(24,29,35,0.95);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 0.5rem;
        padding: 0.4rem 0.45rem 0.3rem;
        backdrop-filter: blur(4px);
      }
      #dash_ai_settings_overlay .dash-donne-group {
        border: 1px solid rgba(255,255,255,0.12);
        border-radius: 0.55rem;
        background: linear-gradient(160deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      }
      #dash_ai_settings_overlay .dash-donne-group > summary {
        list-style: none;
        cursor: pointer;
        padding: 0.55rem 0.75rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid transparent;
      }
      #dash_ai_settings_overlay .dash-donne-group > summary::-webkit-details-marker {
        display: none;
      }
      #dash_ai_settings_overlay .dash-donne-group[open] > summary {
        border-bottom-color: rgba(255,255,255,0.09);
      }
      #dash_ai_settings_overlay .dash-donne-group .dash-donne-group-title {
        font-weight: 600;
      }
      #dash_ai_settings_overlay .dash-donne-group .dash-donne-group-when-open {
        display: none;
      }
      #dash_ai_settings_overlay .dash-donne-group[open] .dash-donne-group-when-open {
        display: inline;
      }
      #dash_ai_settings_overlay .dash-donne-group[open] .dash-donne-group-when-closed {
        display: none;
      }
      #dash_ai_settings_overlay .dash-donne-group .dash-donne-group-body {
        padding: 0.45rem 0.65rem 0.65rem;
      }
      #dash_ai_settings_overlay .dash-donne-group .dash-settings-section {
        margin-top: 0 !important;
      }
      #dash_ai_settings_overlay .dash-donne-group .dash-settings-section + .dash-settings-section {
        margin-top: 0.75rem !important;
      }
      #dash_ai_settings_overlay #dash_addon_update_release_choices .btn {
        text-align: left;
      }
      #dash_ai_settings_overlay .dash-addon-update-changelog {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.42rem;
        background: rgba(255,255,255,0.04);
        color: rgba(228,236,245,0.98);
        padding: 0.55rem;
        max-height: 12rem;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 0.78rem;
        line-height: 1.35;
      }
      #dash_ai_settings_overlay .custom-control.custom-switch {
        position: relative;
        display: flex;
        align-items: center;
        min-height: 2rem;
        padding-left: 0;
      }
      #dash_ai_settings_overlay .custom-control.custom-switch .custom-control-input {
        position: absolute;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
        clip: rect(0, 0, 0, 0);
      }
      #dash_ai_settings_overlay .custom-control.custom-switch .custom-control-label {
        position: relative;
        display: inline-flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        padding-left: 3rem;
        margin-bottom: 0;
        min-height: 1.4rem;
      }
      #dash_ai_settings_overlay .custom-control.custom-switch .custom-control-label::before {
        content: '';
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 2.35rem;
        height: 1.2rem;
        border-radius: 999px;
        background: rgba(108,117,125,0.46);
        border: 1px solid rgba(255,255,255,0.34);
        transition: all .18s ease;
      }
      #dash_ai_settings_overlay .custom-control.custom-switch .custom-control-label::after {
        content: '';
        position: absolute;
        left: 0.16rem;
        top: 50%;
        transform: translateY(-50%);
        width: 0.95rem;
        height: 0.95rem;
        border-radius: 50%;
        background: #ffffff;
        box-shadow: 0 1px 3px rgba(0,0,0,0.35);
        transition: all .18s ease;
      }
      #dash_ai_settings_overlay .custom-control.custom-switch .custom-control-input:checked + .custom-control-label::before {
        background: rgba(13,110,253,0.78);
        border-color: rgba(13,110,253,0.95);
      }
      #dash_ai_settings_overlay .custom-control.custom-switch .custom-control-input:checked + .custom-control-label::after {
        left: 1.24rem;
      }
      #dash_ai_settings_overlay .custom-control.custom-switch .custom-control-input:focus + .custom-control-label::before {
        box-shadow: 0 0 0 0.18rem rgba(13,110,253,0.28);
      }
    `;
    document.head.appendChild(style);
  }

  function aiSettings() {
    if (!S.aiSettings) loadAiSettings();
    return S.aiSettings || defaultAiSettings();
  }

  function brandKey(value) {
    return norm(value || '');
  }

  function groupKey(value) {
    return norm(value || '');
  }

  function normalizeBrandLogoSource(value) {
    const source = clean(value || '').toLowerCase();
    const known = new Set(BRAND_LOGO_SOURCES.map((s) => s.id));
    return known.has(source) ? source : 'database';
  }

  function brandLogoSourceLabel(sourceInput) {
    const source = normalizeBrandLogoSource(sourceInput);
    return t(`brand_logo_source_${source}`);
  }

  function brandLogoSourceHint(sourceInput) {
    const source = normalizeBrandLogoSource(sourceInput);
    return t(`brand_logo_source_hint_${source}`);
  }

  function defaultBrandLogoSettings() {
    return {
      lookupEnabled: false,
      bannerDismissed: false,
      knownCount: 0,
      source: 'duckduckgo',
      logoDevToken: '',
      overrides: {},
      cleared: [],
      groupOverrides: {},
      groupCleared: [],
    };
  }

  function normalizeBrandLogoSettings(rawInput) {
    const fallback = defaultBrandLogoSettings();
    const raw = rawInput && typeof rawInput === 'object' ? rawInput : {};
    const out = {
      lookupEnabled: raw.lookupEnabled === true,
      bannerDismissed: raw.bannerDismissed === true,
      knownCount: Math.max(0, Math.floor(num(raw.knownCount || fallback.knownCount))),
      source: normalizeBrandLogoSource(raw.source || fallback.source),
      logoDevToken: clean(raw.logoDevToken || ''),
      overrides: {},
      cleared: [],
      groupOverrides: {},
      groupCleared: [],
    };

    const rawOverrides = raw.overrides && typeof raw.overrides === 'object' ? raw.overrides : {};
    Object.entries(rawOverrides).forEach(([key, value]) => {
      const keyNorm = brandKey(key);
      if (!keyNorm) return;
      let url = '';
      let brand = '';
      if (typeof value === 'string') {
        url = clean(value);
      } else if (value && typeof value === 'object') {
        url = clean(value.url || '');
        brand = clean(value.brand || '');
      }
      if (!url) return;
      out.overrides[keyNorm] = { brand, url };
    });

    const rawCleared = Array.isArray(raw.cleared) ? raw.cleared : [];
    out.cleared = rawCleared
      .map((value) => brandKey(value))
      .filter((value, index, arr) => value && arr.indexOf(value) === index);

    const rawGroupOverrides = raw.groupOverrides && typeof raw.groupOverrides === 'object' ? raw.groupOverrides : {};
    Object.entries(rawGroupOverrides).forEach(([key, value]) => {
      const keyNorm = groupKey(key);
      if (!keyNorm) return;
      let url = '';
      let group = '';
      if (typeof value === 'string') {
        url = clean(value);
      } else if (value && typeof value === 'object') {
        url = clean(value.url || '');
        group = clean(value.group || '');
      }
      if (!url) return;
      out.groupOverrides[keyNorm] = { group, url };
    });

    const rawGroupCleared = Array.isArray(raw.groupCleared) ? raw.groupCleared : [];
    out.groupCleared = rawGroupCleared
      .map((value) => groupKey(value))
      .filter((value, index, arr) => value && arr.indexOf(value) === index);

    return out;
  }

  function applyBrandLogoSettings(settingsInput) {
    const settings = normalizeBrandLogoSettings(settingsInput || defaultBrandLogoSettings());
    S.brandLogoLookupEnabled = settings.lookupEnabled === true;
    S.brandLogoBannerDismissed = settings.bannerDismissed === true;
    S.brandLogoKnownCount = Math.max(0, Math.floor(num(settings.knownCount)));
    S.brandLogoSource = normalizeBrandLogoSource(settings.source || 'duckduckgo');
    S.brandLogoLogoDevToken = clean(settings.logoDevToken || '');

    const overrides = new Map();
    Object.entries(settings.overrides || {}).forEach(([key, value]) => {
      const keyNorm = brandKey(key);
      const url = clean(value && value.url ? value.url : value);
      if (!keyNorm || !url) return;
      const brand = clean(value && value.brand ? value.brand : '');
      overrides.set(keyNorm, { brand, url });
    });
    const groupOverrides = new Map();
    Object.entries(settings.groupOverrides || {}).forEach(([key, value]) => {
      const keyNorm = groupKey(key);
      const url = clean(value && value.url ? value.url : value);
      if (!keyNorm || !url) return;
      const group = clean(value && value.group ? value.group : '');
      groupOverrides.set(keyNorm, { group, url });
    });
    S.brandLogoOverrides = overrides;
    S.brandLogoCleared = new Set(settings.cleared || []);
    S.groupLogoOverrides = groupOverrides;
    S.groupLogoCleared = new Set(settings.groupCleared || []);
    return settings;
  }

  function serializeBrandLogoSettings() {
    const overrides = {};
    S.brandLogoOverrides.forEach((entry, key) => {
      const keyNorm = brandKey(key);
      if (!keyNorm) return;
      const url = clean(entry && entry.url ? entry.url : '');
      if (!url) return;
      overrides[keyNorm] = {
        brand: clean(entry && entry.brand ? entry.brand : ''),
        url,
      };
    });
    const groupOverrides = {};
    S.groupLogoOverrides.forEach((entry, key) => {
      const keyNorm = groupKey(key);
      if (!keyNorm) return;
      const url = clean(entry && entry.url ? entry.url : '');
      if (!url) return;
      groupOverrides[keyNorm] = {
        group: clean(entry && entry.group ? entry.group : ''),
        url,
      };
    });

    return {
      lookupEnabled: S.brandLogoLookupEnabled === true,
      bannerDismissed: S.brandLogoBannerDismissed === true,
      knownCount: Math.max(0, Math.floor(num(S.brandLogoKnownCount || 0))),
      source: normalizeBrandLogoSource(S.brandLogoSource || 'duckduckgo'),
      logoDevToken: clean(S.brandLogoLogoDevToken || ''),
      overrides,
      cleared: Array.from(S.brandLogoCleared || [])
        .map((value) => brandKey(value))
        .filter((value, index, arr) => value && arr.indexOf(value) === index),
      groupOverrides,
      groupCleared: Array.from(S.groupLogoCleared || [])
        .map((value) => groupKey(value))
        .filter((value, index, arr) => value && arr.indexOf(value) === index),
    };
  }

  function saveBrandLogoSettings() {
    const payload = serializeBrandLogoSettings();
    try {
      localStorage.setItem(BRAND_LOGO_STORAGE_KEY, JSON.stringify(payload));
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
    return payload;
  }

  function loadBrandLogoSettings() {
    const fallback = defaultBrandLogoSettings();
    try {
      const raw = localStorage.getItem(BRAND_LOGO_STORAGE_KEY);
      if (!raw) {
        applyBrandLogoSettings(fallback);
        return fallback;
      }
      const parsed = JSON.parse(raw);
      return applyBrandLogoSettings(parsed);
    } catch (_err) {
      applyBrandLogoSettings(fallback);
      return fallback;
    }
  }

  function defaultUiState() {
    return {
      dashboardOpen: false,
      dashboardView: 'stats',
      chartPrefs: {},
      overlayActiveIndexByChart: {},
      overlayLimitModeByChart: {},
      funPanelRandomNonceByKey: {},
      rankingsDetailsExpanded: false,
      rankingsCategory: 'all',
      rankingsPodiumModes: {},
      dataSignature: '',
      fullChartId: '',
    };
  }

  function scheduleUiStateSave() {
    clearTimeout(S.uiStateSaveTimer);
    S.uiStateSaveTimer = setTimeout(saveUiState, 120);
  }

  function saveUiState() {
    const payload = {
      dashboardOpen: S.dashboardOpen === true,
      dashboardView: S.dashboardView === 'rankings' ? 'rankings' : 'stats',
      chartPrefs: S.chartPrefs,
      overlayActiveIndexByChart: S.overlayActiveIndexByChart,
      overlayLimitModeByChart: S.overlayLimitModeByChart,
      funPanelRandomNonceByKey: S.funPanelRandomNonceByKey,
      rankingsDetailsExpanded: S.rankingsDetailsExpanded === true,
      rankingsCategory: S.rankingsCategory,
      rankingsPodiumModes: S.rankingsPodiumModes,
      dataSignature: clean(S.dataSignature || ''),
      fullChartId: clean(S.fullChartId || ''),
    };
    try {
      localStorage.setItem(UI_STATE_STORAGE_KEY, JSON.stringify(payload));
    } catch (_err) {
      // Ignore storage errors.
    }
  }

  function loadUiState() {
    const fallback = defaultUiState();
    let parsed = null;
    try {
      const raw = localStorage.getItem(UI_STATE_STORAGE_KEY);
      if (raw) parsed = JSON.parse(raw);
    } catch (_err) {
      parsed = null;
    }
    const state = (parsed && typeof parsed === 'object') ? parsed : fallback;

    S.dashboardOpen = state.dashboardOpen === true;
    S.dashboardView = state.dashboardView === 'rankings' ? 'rankings' : 'stats';
    S.overlayDetailsExpanded = false;
    S.rankingsDetailsExpanded = state.rankingsDetailsExpanded === true;
    S.rankingsCategory = normalizeRankingCategory(state.rankingsCategory);
    S.rankingsPodiumModes = (state.rankingsPodiumModes && typeof state.rankingsPodiumModes === 'object')
      ? state.rankingsPodiumModes
      : {};
    S.dataSignature = clean(state.dataSignature || '');
    S.savedFullChartId = clean(state.fullChartId || '');
    S.overlayActiveIndexByChart = (state.overlayActiveIndexByChart && typeof state.overlayActiveIndexByChart === 'object')
      ? { ...state.overlayActiveIndexByChart }
      : {};
    S.funPanelRandomNonceByKey = (state.funPanelRandomNonceByKey && typeof state.funPanelRandomNonceByKey === 'object')
      ? { ...state.funPanelRandomNonceByKey }
      : {};

    if (state.overlayLimitModeByChart && typeof state.overlayLimitModeByChart === 'object') {
      Object.entries(state.overlayLimitModeByChart).forEach(([key, value]) => {
        setOverlayLimitMode(key, value);
      });
    }
    if (state.chartPrefs && typeof state.chartPrefs === 'object') {
      Object.entries(state.chartPrefs).forEach(([key, pref]) => {
        if (!pref || typeof pref !== 'object') return;
        patchChartPref(key, {
          sort: pref.sort,
          limit: pref.limit,
          includeZero: pref.includeZero,
          qtyMode: pref.qtyMode,
          chartType: pref.chartType,
        });
      });
    }
  }

  function addonCompatibilityEmptyMappings() {
    return {
      groups: {},
      userentities: {},
      userfields: {},
    };
  }

  function normalizeAddonCompatibilityMappings(mappingsInput = null) {
    const raw = mappingsInput && typeof mappingsInput === 'object'
      ? mappingsInput
      : addonCompatibilityEmptyMappings();
    const out = addonCompatibilityEmptyMappings();
    ['groups', 'userentities', 'userfields'].forEach((category) => {
      const source = raw[category] && typeof raw[category] === 'object'
        ? raw[category]
        : {};
      Object.entries(source).forEach(([key, value]) => {
        const keyText = clean(key || '');
        const valueText = clean(value || '');
        if (!keyText || !valueText) return;
        out[category][keyText] = valueText;
      });
    });
    return out;
  }

  function defaultAddonCompatibilityState() {
    return {
      onboardingSeen: false,
      completed: false,
      lastRunAt: '',
      lastSummary: '',
      lastError: '',
      mappings: addonCompatibilityEmptyMappings(),
    };
  }

  function normalizeAddonCompatibilityState(stateInput = null) {
    const state = stateInput && typeof stateInput === 'object'
      ? stateInput
      : defaultAddonCompatibilityState();
    return {
      onboardingSeen: state.onboardingSeen === true,
      completed: state.completed === true,
      lastRunAt: clean(state.lastRunAt || ''),
      lastSummary: clean(state.lastSummary || ''),
      lastError: clean(state.lastError || ''),
      mappings: normalizeAddonCompatibilityMappings(state.mappings),
    };
  }

  function addonCompatibilityState() {
    if (!S.addonCompatState || typeof S.addonCompatState !== 'object') {
      S.addonCompatState = loadAddonCompatibilityState();
    }
    return normalizeAddonCompatibilityState(S.addonCompatState);
  }

  function saveAddonCompatibilityState(nextInput = {}, optionsInput = {}) {
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const replace = options.replace === true;
    const current = replace
      ? defaultAddonCompatibilityState()
      : addonCompatibilityState();
    const merged = normalizeAddonCompatibilityState({
      ...current,
      ...(nextInput && typeof nextInput === 'object' ? nextInput : {}),
    });
    S.addonCompatState = merged;
    try {
      localStorage.setItem(ADDON_COMPATIBILITY_KEY, JSON.stringify(merged));
    } catch (_err) {
      // Ignore localStorage errors.
    }
    return merged;
  }

  function loadAddonCompatibilityState() {
    const fallback = defaultAddonCompatibilityState();
    try {
      const raw = localStorage.getItem(ADDON_COMPATIBILITY_KEY);
      if (!raw) {
        S.addonCompatState = fallback;
        return fallback;
      }
      const parsed = JSON.parse(raw);
      const normalized = normalizeAddonCompatibilityState(parsed);
      S.addonCompatState = normalized;
      return normalized;
    } catch (_err) {
      S.addonCompatState = fallback;
      return fallback;
    }
  }

  function normalizeAddonUpdateStatusLevel(valueInput = '') {
    const value = clean(valueInput || '').toLowerCase();
    if (value === 'success' || value === 'warning' || value === 'danger' || value === 'info') return value;
    return 'muted';
  }

  function addonUpdateRepositoryText(repositoryInput = '') {
    const raw = clean(repositoryInput || '');
    if (!raw) return ADDON_UPDATE_DEFAULT_REPOSITORY;
    let text = raw
      .replace(/^https?:\/\/github\.com\//i, '')
      .replace(/\.git$/i, '')
      .replace(/^\/+|\/+$/g, '');
    const parts = text.split('/').filter(Boolean);
    if (parts.length >= 2) {
      text = `${parts[0]}/${parts[1]}`;
    }
    return clean(text || ADDON_UPDATE_DEFAULT_REPOSITORY);
  }

  function addonUpdateRepositoryParts(repositoryInput = '') {
    const repository = addonUpdateRepositoryText(repositoryInput || '');
    const match = repository.match(/^([A-Za-z0-9_.-]+)\/([A-Za-z0-9_.-]+)$/);
    if (!match) return null;
    return {
      repository: `${match[1]}/${match[2]}`,
      owner: match[1],
      name: match[2],
    };
  }

  function defaultAddonUpdateState() {
    return {
      repository: ADDON_UPDATE_DEFAULT_REPOSITORY,
      includePrerelease: false,
      localRootPath: ADDON_UPDATE_DEFAULT_LOCAL_ROOT,
      localInstalledTag: '',
      localInstalledVersion: '',
      localInstalledAt: '',
      checkedAt: '',
      latestTag: '',
      latestVersion: '',
      releaseUrl: '',
      assetUrl: '',
      assetName: '',
      selectedChangelog: '',
      selectedPublishedAt: '',
      lastStatus: '',
      lastStatusLevel: 'muted',
      lastError: '',
    };
  }

  function normalizeAddonUpdateState(stateInput = null) {
    const state = stateInput && typeof stateInput === 'object'
      ? stateInput
      : defaultAddonUpdateState();
    const repository = addonUpdateRepositoryText(state.repository || ADDON_UPDATE_DEFAULT_REPOSITORY);
    return {
      repository,
      includePrerelease: state.includePrerelease === true,
      localRootPath: clean(state.localRootPath || ADDON_UPDATE_DEFAULT_LOCAL_ROOT),
      localInstalledTag: clean(state.localInstalledTag || ''),
      localInstalledVersion: clean(state.localInstalledVersion || ''),
      localInstalledAt: clean(state.localInstalledAt || ''),
      checkedAt: clean(state.checkedAt || ''),
      latestTag: clean(state.latestTag || ''),
      latestVersion: clean(state.latestVersion || ''),
      releaseUrl: clean(state.releaseUrl || ''),
      assetUrl: clean(state.assetUrl || ''),
      assetName: clean(state.assetName || ''),
      selectedChangelog: String(state.selectedChangelog || ''),
      selectedPublishedAt: clean(state.selectedPublishedAt || ''),
      lastStatus: clean(state.lastStatus || ''),
      lastStatusLevel: normalizeAddonUpdateStatusLevel(state.lastStatusLevel || 'muted'),
      lastError: clean(state.lastError || ''),
    };
  }

  function addonUpdateState() {
    if (!S.addonUpdateState || typeof S.addonUpdateState !== 'object') {
      S.addonUpdateState = loadAddonUpdateState();
    }
    return normalizeAddonUpdateState(S.addonUpdateState);
  }

  function saveAddonUpdateState(nextInput = {}, optionsInput = {}) {
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const replace = options.replace === true;
    const current = replace
      ? defaultAddonUpdateState()
      : addonUpdateState();
    const merged = normalizeAddonUpdateState({
      ...current,
      ...(nextInput && typeof nextInput === 'object' ? nextInput : {}),
    });
    S.addonUpdateState = merged;
    try {
      localStorage.setItem(ADDON_UPDATE_KEY, JSON.stringify(merged));
    } catch (_err) {
      // Ignore localStorage errors.
    }
    return merged;
  }

  function loadAddonUpdateState() {
    const fallback = defaultAddonUpdateState();
    try {
      const raw = localStorage.getItem(ADDON_UPDATE_KEY);
      if (!raw) {
        S.addonUpdateState = fallback;
        return fallback;
      }
      const parsed = JSON.parse(raw);
      const normalized = normalizeAddonUpdateState(parsed);
      S.addonUpdateState = normalized;
      return normalized;
    } catch (_err) {
      S.addonUpdateState = fallback;
      return fallback;
    }
  }

  function addonUpdateVersionFromTag(tagInput = '') {
    return clean(tagInput || '').replace(/^v/i, '');
  }

  function addonUpdateSemverParts(versionInput = '') {
    const version = clean(versionInput || '').replace(/^v/i, '');
    const match = version.match(/^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z.-]+))?/);
    if (!match) return null;
    return {
      major: Math.max(0, Math.floor(num(match[1]))),
      minor: Math.max(0, Math.floor(num(match[2]))),
      patch: Math.max(0, Math.floor(num(match[3]))),
      prerelease: clean(match[4] || ''),
    };
  }

  function compareAddonSemver(leftInput = '', rightInput = '') {
    const left = addonUpdateSemverParts(leftInput);
    const right = addonUpdateSemverParts(rightInput);
    if (!left || !right) return 0;

    if (left.major !== right.major) return left.major < right.major ? -1 : 1;
    if (left.minor !== right.minor) return left.minor < right.minor ? -1 : 1;
    if (left.patch !== right.patch) return left.patch < right.patch ? -1 : 1;

    const leftPre = clean(left.prerelease || '');
    const rightPre = clean(right.prerelease || '');
    if (!leftPre && rightPre) return 1;
    if (leftPre && !rightPre) return -1;
    if (!leftPre && !rightPre) return 0;
    return leftPre.localeCompare(rightPre, undefined, { sensitivity: 'base', numeric: true });
  }

  function addonUpdateFormatDate(isoInput = '') {
    const iso = clean(isoInput || '');
    if (!iso) return '';
    const parsed = new Date(iso);
    if (Number.isNaN(parsed.getTime())) return iso;
    return parsed.toLocaleString();
  }

  function addonUpdateNormalizeLocalRootPath(pathInput = '') {
    const raw = String(pathInput || '').trim();
    if (!raw) return '';
    let value = raw.replace(/^["']+|["']+$/g, '');
    value = value.replace(/[\\/]+$/g, '');
    return value;
  }

  function addonUpdateBuildWindowsPaths(rootPathInput = '') {
    const root = addonUpdateNormalizeLocalRootPath(rootPathInput || '');
    if (!root) {
      return {
        root: '',
        scriptsDir: 'addon\\scripts',
        configDir: 'config',
      };
    }
    const base = root.replace(/\//g, '\\');
    return {
      root: base,
      scriptsDir: `${base}\\addon\\scripts`,
      configDir: `${base}\\config`,
    };
  }

  function addonUpdateBuildShellPaths(rootPathInput = '') {
    const root = addonUpdateNormalizeLocalRootPath(rootPathInput || '');
    if (!root) {
      return {
        root: '',
        scriptsDir: 'addon/scripts',
        configDir: 'config',
      };
    }
    const base = root.replace(/\\/g, '/');
    return {
      root: base,
      scriptsDir: `${base}/addon/scripts`,
      configDir: `${base}/config`,
    };
  }

  function addonUpdateLocalVersionValue(stateInput = null) {
    const state = normalizeAddonUpdateState(stateInput || addonUpdateState());
    const fromStateTag = clean(state.localInstalledTag || '');
    if (fromStateTag) {
      return addonUpdateVersionFromTag(fromStateTag);
    }
    const fromStateVersion = clean(state.localInstalledVersion || '');
    if (fromStateVersion) return fromStateVersion;
    return clean(ADDON_RUNTIME_VERSION || '') || t('addon_update_version_unknown');
  }

  function addonUpdatePsQuote(valueInput = '') {
    return `'${String(valueInput || '').replace(/'/g, "''")}'`;
  }

  function addonUpdatePsDoubleQuote(valueInput = '') {
    return `"${String(valueInput || '').replace(/`/g, '``').replace(/"/g, '`"')}"`;
  }

  function addonUpdateShQuote(valueInput = '') {
    const value = String(valueInput || '');
    return `'${value.replace(/'/g, `'\"'\"'`)}'`;
  }

  function addonUpdateCommandPowerShell(stateInput = null) {
    const state = normalizeAddonUpdateState(stateInput || addonUpdateState());
    const repo = clean(state.repository || ADDON_UPDATE_DEFAULT_REPOSITORY);
    const tag = clean(state.latestTag || '');
    const paths = addonUpdateBuildWindowsPaths(state.localRootPath || '');
    let command = `Set-Location ${addonUpdatePsDoubleQuote(paths.scriptsDir)}; .\\update-from-github.ps1 -Repository ${addonUpdatePsQuote(repo)} -GrocyConfigPath ${addonUpdatePsDoubleQuote(paths.configDir)}`;
    if (state.includePrerelease === true) {
      command += ' -AllowPrerelease';
    }
    if (tag) {
      command += ` -ReleaseTag ${addonUpdatePsQuote(tag)}`;
    }
    return command;
  }

  function addonUpdateCommandShell(stateInput = null) {
    const state = normalizeAddonUpdateState(stateInput || addonUpdateState());
    const repo = clean(state.repository || ADDON_UPDATE_DEFAULT_REPOSITORY);
    const tag = clean(state.latestTag || '');
    const paths = addonUpdateBuildShellPaths(state.localRootPath || '');
    let command = `cd ${addonUpdateShQuote(paths.scriptsDir)} && ./update-from-github.sh --repository ${addonUpdateShQuote(repo)} --config ${addonUpdateShQuote(paths.configDir)}`;
    if (state.includePrerelease === true) {
      command += ' --allow-prerelease';
    }
    if (tag) {
      command += ` --tag ${addonUpdateShQuote(tag)}`;
    }
    return command;
  }

  function addonUpdateRelayUrl(pathInput = '') {
    const path = String(pathInput || '').replace(/^\/+/, '');
    return `${ADDON_UPDATE_RELAY_BASE_URL}/${path}`;
  }

  async function addonUpdateRelayHealthCheck() {
    try {
      const response = await fetch(addonUpdateRelayUrl('health'), { method: 'GET', cache: 'no-store' });
      if (!response || !response.ok) return false;
      const payload = await response.json().catch(() => null);
      if (!payload || payload.ok !== true) return false;
      return true;
    } catch (_err) {
      return false;
    }
  }

  async function runAddonUpdateViaRelay() {
    if (S.addonUpdateInstalling === true || S.addonUpdateChecking === true) return null;
    const state = addonUpdateState();
    const repoInput = document.getElementById('dash_addon_update_repo');
    const localRootInput = document.getElementById('dash_addon_update_local_root');
    const repository = addonUpdateRepositoryText(repoInput?.value || state.repository || ADDON_UPDATE_DEFAULT_REPOSITORY);
    const parts = addonUpdateRepositoryParts(repository);
    if (!parts) {
      setAddonUpdateSettingsStatus(t('addon_update_repo_invalid'), 'danger');
      return null;
    }
    const localRootPath = addonUpdateNormalizeLocalRootPath(localRootInput?.value || state.localRootPath || ADDON_UPDATE_DEFAULT_LOCAL_ROOT);
    const releaseTag = clean(state.latestTag || '');
    const includePrerelease = state.includePrerelease === true;
    const noBackup = false;
    if (!releaseTag) {
      setAddonUpdateSettingsStatus(t('addon_update_status_release_missing'), 'warning');
      return null;
    }

    S.addonUpdateInstalling = true;
    syncAddonUpdateSettingsSection();
    setAddonUpdateSettingsStatus(t('addon_update_bridge_status_running'), 'info');

    try {
      const health = await addonUpdateRelayHealthCheck();
      if (!health) {
        throw new Error(t('addon_update_bridge_status_missing'));
      }

      const response = await fetch(addonUpdateRelayUrl('v1/update'), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
        body: JSON.stringify({
          repository: parts.repository,
          releaseTag,
          localRootPath,
          includePrerelease,
          noBackup,
        }),
      });
      const payload = await response.json().catch(() => null);
      if (!response.ok || !payload || payload.ok !== true) {
        const msg = clean(payload && payload.error ? payload.error : '') || `${response.status} ${response.statusText}`.trim();
        throw new Error(msg || t('focus_unknown_error'));
      }

      await refreshAddonInstalledVersionFromFile();
      const next = saveAddonUpdateState({
        repository: parts.repository,
        localRootPath,
        checkedAt: new Date().toISOString(),
        localInstalledTag: clean(payload.installedTag || releaseTag),
        localInstalledVersion: addonUpdateVersionFromTag(clean(payload.installedTag || releaseTag)),
        lastError: '',
        lastStatus: t('addon_update_bridge_status_success'),
        lastStatusLevel: 'success',
      });
      syncAddonUpdateCommandFields(next);
      syncAddonUpdateVersionSummary(next);
      syncStatNerdAboutInfoBlock(next);
      syncAddonUpdateSettingsSection();
      return payload;
    } catch (error) {
      const message = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
      const next = saveAddonUpdateState({
        repository: parts.repository,
        localRootPath,
        checkedAt: new Date().toISOString(),
        lastError: message,
        lastStatus: t('addon_update_bridge_status_error', { msg: message }),
        lastStatusLevel: 'danger',
      });
      syncAddonUpdateCommandFields(next);
      syncAddonUpdateVersionSummary(next);
      syncAddonUpdateSettingsSection();
      return null;
    } finally {
      S.addonUpdateInstalling = false;
      syncAddonUpdateSettingsSection();
    }
  }

  function addonUpdatePickReleaseAsset(assetsInput = null) {
    const assets = Array.isArray(assetsInput) ? assetsInput : [];
    if (!assets.length) return null;
    return assets.find((asset) => /^grocy-addon-v.+\.zip$/i.test(clean(asset?.name || '')))
      || assets.find((asset) => /\.zip$/i.test(clean(asset?.name || '')))
      || null;
  }

  function addonUpdateReleasePayloadToInfo(payloadInput = null, repository = '') {
    const payload = payloadInput && typeof payloadInput === 'object' ? payloadInput : null;
    if (!payload) return null;
    const tag = clean(payload && payload.tag_name ? payload.tag_name : '');
    if (!tag) return null;
    const version = addonUpdateVersionFromTag(tag);
    const releaseUrl = clean(payload && payload.html_url ? payload.html_url : '');
    const publishedAt = clean(payload && payload.published_at ? payload.published_at : '');
    const changelog = String(payload && payload.body ? payload.body : '');
    const prerelease = payload && payload.prerelease === true;
    const asset = addonUpdatePickReleaseAsset(payload && payload.assets);
    return {
      repository,
      tag,
      version,
      releaseUrl,
      assetName: clean(asset && asset.name ? asset.name : ''),
      assetUrl: clean(asset && asset.browser_download_url ? asset.browser_download_url : ''),
      prerelease,
      publishedAt,
      changelog,
    };
  }

  async function fetchAddonReleaseList(repositoryInput = '', optionsInput = {}) {
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const includePrerelease = options.includePrerelease === true;
    const limit = clamp(Math.floor(num(options.limit || '20')), 1, 50);
    const repo = addonUpdateRepositoryParts(repositoryInput || '');
    if (!repo) {
      throw new Error(t('addon_update_repo_invalid'));
    }

    const endpoint = `https://api.github.com/repos/${encodeURIComponent(repo.owner)}/${encodeURIComponent(repo.name)}/releases?per_page=${limit}`;
    let response = null;
    try {
      response = await fetch(endpoint, {
        headers: {
          Accept: 'application/vnd.github+json',
          'X-GitHub-Api-Version': '2022-11-28',
        },
      });
    } catch (error) {
      const message = clean(error && error.message ? error.message : String(error));
      throw new Error(message || t('focus_unknown_error'));
    }

    if (!response || !response.ok) {
      let message = response ? `HTTP ${response.status}` : '';
      try {
        const payload = await response.json();
        const remoteMessage = clean(payload && payload.message ? payload.message : '');
        if (remoteMessage) message = remoteMessage;
      } catch (_err) {}
      if (response && response.status === 404) {
        throw new Error(t('addon_update_status_release_missing'));
      }
      throw new Error(message || t('focus_unknown_error'));
    }

    const rawPayload = await response.json();
    const rows = Array.isArray(rawPayload) ? rawPayload : [];
    const filtered = rows.filter((row) => {
      if (!row || row.draft === true) return false;
      const tag = clean(row.tag_name || '');
      if (!tag) return false;
      if (includePrerelease) return row.prerelease === true;
      return row.prerelease !== true;
    });
    let list = filtered
      .map((row) => addonUpdateReleasePayloadToInfo(row, repo.repository))
      .filter(Boolean);
    if (includePrerelease) {
      list = list.slice(0, ADDON_UPDATE_PRERELEASE_VISIBLE_LIMIT);
    }
    if (!list.length) {
      throw new Error(t('addon_update_status_release_missing'));
    }
    return list;
  }

  async function fetchAddonLatestReleaseInfo(repositoryInput = '', optionsInput = {}) {
    const list = await fetchAddonReleaseList(repositoryInput, optionsInput);
    if (!Array.isArray(list) || !list.length) {
      throw new Error(t('addon_update_status_release_missing'));
    }
    return list[0];
  }

  function addonUpdateCandidateStateFileUrls() {
    const pathname = clean(window.location && window.location.pathname ? window.location.pathname : '');
    const baseCandidates = ['data/grocy-addon-state.json', '/data/grocy-addon-state.json', 'grocy-addon-state.json'];
    const apiCandidates = [];
    try {
      if (typeof U === 'function') {
        const fromGroup = clean(U('/api/files/data/') || '');
        if (fromGroup) {
          apiCandidates.push(`${fromGroup}${encodeURIComponent('grocy-addon-state.json')}`);
        }
        const fromFull = clean(U('/api/files/data/grocy-addon-state.json') || '');
        if (fromFull) {
          apiCandidates.push(fromFull);
        }
      }
    } catch (_err) {
      // Ignore URL helper issues and use plain candidates.
    }
    apiCandidates.push('/api/files/data/grocy-addon-state.json');
    apiCandidates.push('/api/files/data/' + encodeURIComponent('grocy-addon-state.json'));
    if (!pathname) return Array.from(new Set([...apiCandidates, ...baseCandidates]));
    const basePath = pathname.replace(/\/[^/]*$/, '/');
    return Array.from(new Set([
      ...apiCandidates,
      `${basePath}data/grocy-addon-state.json`,
      `${basePath}grocy-addon-state.json`,
      ...baseCandidates,
    ]));
  }

  async function fetchAddonInstalledStateFromFile() {
    const urls = addonUpdateCandidateStateFileUrls();
    for (let i = 0; i < urls.length; i += 1) {
      const url = urls[i];
      try {
        const response = await fetch(url, { cache: 'no-store' });
        if (!response || !response.ok) continue;
        const payload = await response.json();
        if (!payload || typeof payload !== 'object') continue;
        const tag = clean(payload.release_tag || '');
        if (!tag) continue;
        return {
          tag,
          version: addonUpdateVersionFromTag(tag),
          installedAt: clean(payload.installed_at || ''),
        };
      } catch (_err) {
        // try next candidate
      }
    }
    return null;
  }

  async function refreshAddonInstalledVersionFromFile() {
    if (S.addonUpdateLocalVersionPromise) return S.addonUpdateLocalVersionPromise;
    S.addonUpdateLocalVersionPromise = (async () => {
      try {
        const installed = await fetchAddonInstalledStateFromFile();
        if (!installed) return addonUpdateState();
        const next = saveAddonUpdateState({
          localInstalledTag: clean(installed.tag || ''),
          localInstalledVersion: clean(installed.version || ''),
          localInstalledAt: clean(installed.installedAt || ''),
        });
        syncAddonUpdateVersionSummary(next);
        syncStatNerdAboutInfoBlock(next);
        return next;
      } finally {
        S.addonUpdateLocalVersionPromise = null;
      }
    })();
    return S.addonUpdateLocalVersionPromise;
  }

  async function copyTextToClipboard(textInput = '') {
    const text = String(textInput || '');
    if (!text) return false;
    try {
      if (navigator && navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
        await navigator.clipboard.writeText(text);
        return true;
      }
    } catch (_err) {}

    try {
      const area = document.createElement('textarea');
      area.value = text;
      area.setAttribute('readonly', 'readonly');
      area.style.position = 'fixed';
      area.style.opacity = '0';
      area.style.pointerEvents = 'none';
      document.body.appendChild(area);
      area.focus();
      area.select();
      const copied = document.execCommand('copy');
      if (area.parentNode) area.parentNode.removeChild(area);
      return copied === true;
    } catch (_err) {
      return false;
    }
  }

  function normalizeAddonCompatibilityMatchText(valueInput = '') {
    return norm(valueInput || '').replace(/[^a-z0-9]+/g, ' ').trim();
  }

  function normalizeUserfieldMatchToken(valueInput = '') {
    return normalizeAddonCompatibilityMatchText(valueInput || '').replace(/\s+/g, '');
  }

  function addonCompatibilityMapKey(valueInput = '') {
    return normalizeUserfieldMatchToken(valueInput || '');
  }

  function addonCompatibilityGroupMapKey(groupNameInput = '') {
    return addonCompatibilityMapKey(groupNameInput);
  }

  function addonCompatibilityUserentityMapKey(entityNameInput = '') {
    return addonCompatibilityMapKey(entityNameInput);
  }

  function addonCompatibilityUserfieldMapKey(definitionInput = {}) {
    const definition = definitionInput && typeof definitionInput === 'object' ? definitionInput : {};
    const entityRef = clean(definition.entity || 'products') || 'products';
    return `${addonCompatibilityMapKey(entityRef)}::${addonCompatibilityMapKey(definition.name || '')}`;
  }

  function addonCompatibilityUserfieldRowRef(rowInput = {}) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const entity = clean(row.entity || '');
    const name = clean(row.name || '');
    if (!entity || !name) return '';
    return `${entity}||${name}`;
  }

  function parseAddonCompatibilityUserfieldRowRef(valueInput = '') {
    const value = clean(valueInput || '');
    if (!value || !value.includes('||')) return null;
    const parts = value.split('||');
    const entity = clean(parts[0] || '');
    const name = clean(parts[1] || '');
    if (!entity || !name) return null;
    return { entity, name };
  }

  function addonCompatibilitySimilarityScore(referenceInput = '', candidateInput = '') {
    const reference = normalizeAddonCompatibilityMatchText(referenceInput || '');
    const candidate = normalizeAddonCompatibilityMatchText(candidateInput || '');
    if (!reference || !candidate) return 0;
    if (reference === candidate) return 1;
    if (reference.includes(candidate) || candidate.includes(reference)) {
      const ratio = Math.min(reference.length, candidate.length) / Math.max(reference.length, candidate.length);
      return 0.7 + (0.25 * ratio);
    }
    const refTokens = reference.split(' ').filter(Boolean);
    const candTokens = candidate.split(' ').filter(Boolean);
    if (!refTokens.length || !candTokens.length) return 0;
    const candSet = new Set(candTokens);
    const overlap = refTokens.filter((token) => candSet.has(token)).length;
    if (!overlap) return 0;
    return overlap / Math.max(refTokens.length, candTokens.length);
  }

  function addonCompatibilitySimilarityCandidates(
    expectedLabelsInput = [],
    rowsInput = [],
    resolverInput = null,
    minScoreInput = 0.55,
    maxItemsInput = 8
  ) {
    const expectedLabels = Array.isArray(expectedLabelsInput)
      ? expectedLabelsInput.map((value) => clean(value || '')).filter(Boolean)
      : [];
    const rows = Array.isArray(rowsInput) ? rowsInput : [];
    const resolver = typeof resolverInput === 'function' ? resolverInput : null;
    const minScore = Math.max(0, num(minScoreInput));
    const maxItems = Math.max(1, Math.floor(num(maxItemsInput)));
    if (!expectedLabels.length || !rows.length || !resolver) return [];

    const out = [];
    const seen = new Set();

    rows.forEach((row) => {
      const info = resolver(row);
      if (!info || typeof info !== 'object') return;
      const value = clean(info.value || '');
      const label = clean(info.label || '');
      const scoreTexts = Array.isArray(info.scoreTexts)
        ? info.scoreTexts.map((text) => clean(text || '')).filter(Boolean)
        : [clean(info.scoreText || ''), label].filter(Boolean);
      if (!value || !label || !scoreTexts.length) return;

      let bestScore = 0;
      expectedLabels.forEach((expectedLabel) => {
        scoreTexts.forEach((scoreText) => {
          bestScore = Math.max(bestScore, addonCompatibilitySimilarityScore(expectedLabel, scoreText));
        });
      });
      if (bestScore < minScore) return;

      const dedupeKey = `${addonCompatibilityMapKey(value)}|${addonCompatibilityMapKey(label)}`;
      if (seen.has(dedupeKey)) return;
      seen.add(dedupeKey);
      out.push({
        row,
        value,
        label,
        score: bestScore,
      });
    });

    out.sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      return a.label.localeCompare(b.label, undefined, { sensitivity: 'base' });
    });
    return out.slice(0, maxItems);
  }

  function addonCompatibilityProductGroupDefinitions() {
    const lang = resolveUiLanguage();
    return ADDON_COMPAT_REQUIRED_PRODUCT_GROUPS.map((group) => ({
      ...group,
      description: lang === 'en'
        ? clean(group.descriptionEn || group.descriptionFr || '')
        : clean(group.descriptionFr || group.descriptionEn || ''),
    }));
  }

  function addonCompatibilityUserentityDefinitions() {
    const lang = resolveUiLanguage();
    return ADDON_COMPAT_REQUIRED_USERENTITIES.map((entity) => ({
      ...entity,
      caption: lang === 'en'
        ? clean(entity.captionEn || entity.captionFr || entity.name)
        : clean(entity.captionFr || entity.captionEn || entity.name),
      description: lang === 'en'
        ? clean(entity.descriptionEn || entity.descriptionFr || '')
        : clean(entity.descriptionFr || entity.descriptionEn || ''),
    }));
  }

  function addonCompatibilityExpectedEntityNameFromRef(entityRefInput = '') {
    const entityRef = clean(entityRefInput || '');
    if (!entityRef || norm(entityRef) === 'products') return '';
    if (entityRef.includes(':')) return clean(entityRef.split(':').slice(1).join(':'));
    if (entityRef.startsWith('userentity-')) return clean(entityRef.slice('userentity-'.length));
    return entityRef;
  }

  function addonCompatibilityUserfieldDefinitions() {
    const lang = resolveUiLanguage();
    return ADDON_COMPAT_REQUIRED_USERFIELDS.map((field) => ({
      ...field,
      entity: clean(field.entity || 'products') || 'products',
      caption: lang === 'en'
        ? clean(field.captionEn || field.captionFr || field.name)
        : clean(field.captionFr || field.captionEn || field.name),
    }));
  }

  function userfieldMatchesAddonDefinition(rowInput, definitionInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const definition = definitionInput && typeof definitionInput === 'object' ? definitionInput : {};
    const rowName = normalizeUserfieldMatchToken(row.name || '');
    const rowCaption = normalizeUserfieldMatchToken(row.caption || '');
    const defName = normalizeUserfieldMatchToken(definition.name || '');
    const defCaptionFr = normalizeUserfieldMatchToken(definition.captionFr || '');
    const defCaptionEn = normalizeUserfieldMatchToken(definition.captionEn || '');
    const defCaption = normalizeUserfieldMatchToken(definition.caption || '');
    if (!defName) return false;
    if (rowName && rowName === defName) return true;
    if (rowCaption && (
      rowCaption === defCaption
      || rowCaption === defCaptionFr
      || rowCaption === defCaptionEn
    )) return true;
    return false;
  }

  async function fetchProductGroupsForCompatibility() {
    const payload = await fetchJson('api/objects/product_groups');
    let rows = extractArray(payload);
    if (rows.length === 0) {
      rows = deepCollectObjects(payload, (obj) => hasAnyKey(obj, ['id']) && hasAnyKey(obj, ['name']));
    }
    return rows.filter((row) => clean(row && row.name ? row.name : ''));
  }

  async function fetchUserentitiesForCompatibility() {
    let payload;
    try {
      payload = await fetchJson('api/objects/userentities');
    } catch (_err) {
      payload = await fetchJson('api/userentities');
    }
    let rows = extractArray(payload);
    if (rows.length === 0) {
      rows = deepCollectObjects(payload, (obj) => hasAnyKey(obj, ['name']) && hasAnyKey(obj, ['caption']));
    }
    return rows.filter((row) => clean(row && row.name ? row.name : ''));
  }

  async function fetchUserfieldsForCompatibility(entityInput = '') {
    const entity = clean(entityInput || '');
    let payload;
    if (entity) {
      try {
        payload = await fetchJson(`api/objects/userfields?query[]=entity=${encodeURIComponent(entity)}`);
      } catch (_err) {
        payload = await fetchJson('api/objects/userfields');
      }
    } else {
      payload = await fetchJson('api/objects/userfields');
    }

    let rows = extractArray(payload);
    if (rows.length === 0) {
      rows = deepCollectObjects(
        payload,
        (obj) => hasAnyKey(obj, ['entity']) && hasAnyKey(obj, ['name']) && hasAnyKey(obj, ['caption'])
      );
    }
    if (!entity) return rows;
    const entityKey = addonCompatibilityMapKey(entity);
    return rows.filter((row) => addonCompatibilityMapKey(row && row.entity ? row.entity : '') === entityKey);
  }

  async function fetchProductUserfieldsForCompatibility() {
    return fetchUserfieldsForCompatibility('products');
  }

  function addonCompatibilityCreateProductGroupPayload(definitionInput = {}) {
    const definition = definitionInput && typeof definitionInput === 'object' ? definitionInput : {};
    return {
      name: clean(definition.name || ''),
      description: clean(definition.description || definition.descriptionFr || definition.descriptionEn || ''),
      active: definition.active === 0 ? 0 : 1,
    };
  }

  function addonCompatibilityCreateUserentityPayload(definitionInput = {}) {
    const definition = definitionInput && typeof definitionInput === 'object' ? definitionInput : {};
    return {
      name: clean(definition.name || ''),
      caption: clean(definition.caption || definition.captionFr || definition.captionEn || definition.name || ''),
      description: clean(definition.description || definition.descriptionFr || definition.descriptionEn || ''),
      show_in_sidebar_menu: definition.showInSidebar === 0 ? 0 : 1,
      icon_css_class: clean(definition.iconCssClass || ''),
    };
  }

  function addonCompatibilityCreatePayload(definitionInput = {}, entityOverrideInput = '') {
    const definition = definitionInput && typeof definitionInput === 'object' ? definitionInput : {};
    const entityOverride = clean(entityOverrideInput || '');
    const expectedEntityRef = clean(definition.entity || 'products') || 'products';
    let entity = entityOverride || expectedEntityRef;
    if (entity.startsWith('userentity:')) {
      const entityName = addonCompatibilityExpectedEntityNameFromRef(entity);
      entity = entityName ? `userentity-${entityName}` : 'products';
    }
    return {
      entity: clean(entity || 'products') || 'products',
      name: clean(definition.name || ''),
      caption: clean(definition.caption || definition.captionFr || definition.captionEn || definition.name || ''),
      type: clean(definition.type || 'text-single-line'),
      show_as_column_in_tables: definition.showAsColumn ? 1 : 0,
      sort_number: Number.isFinite(num(definition.sortNumber)) ? Math.floor(num(definition.sortNumber)) : null,
      input_required: definition.inputRequired ? 1 : 0,
      default_value: clean(definition.defaultValue || ''),
      config: definition.config == null ? '' : String(definition.config),
    };
  }

  async function createAddonCompatibilityUserentity(payloadInput = {}) {
    const payload = payloadInput && typeof payloadInput === 'object' ? payloadInput : {};
    try {
      return await postJson('api/objects/userentities', payload);
    } catch (_err) {
      return postJson('api/userentities', payload);
    }
  }

  function addonCompatibilityResolveUserfieldEntity(definitionInput = {}, entityFindingsInput = []) {
    const definition = definitionInput && typeof definitionInput === 'object' ? definitionInput : {};
    const entityRef = clean(definition.entity || 'products') || 'products';
    if (addonCompatibilityMapKey(entityRef) === addonCompatibilityMapKey('products')) {
      return {
        entityRef,
        expectedEntityName: '',
        entityKey: 'products',
        entityDisplay: 'products',
      };
    }
    const expectedEntityName = addonCompatibilityExpectedEntityNameFromRef(entityRef);
    const expectedMapKey = addonCompatibilityUserentityMapKey(expectedEntityName);
    const finding = Array.isArray(entityFindingsInput)
      ? entityFindingsInput.find((entry) => clean(entry.mapKey || '') === expectedMapKey)
      : null;
    const resolvedName = clean((finding && finding.resolvedName) || expectedEntityName);
    const entityKey = resolvedName ? `userentity-${resolvedName}` : '';
    return {
      entityRef,
      expectedEntityName,
      entityKey,
      entityDisplay: resolvedName || expectedEntityName || '',
    };
  }

  function addonCompatibilityMergeMappingSelection(selectionInput = {}) {
    const selection = selectionInput && typeof selectionInput === 'object'
      ? selectionInput
      : addonCompatibilityEmptyMappings();
    const current = normalizeAddonCompatibilityMappings(addonCompatibilityState().mappings);
    const next = normalizeAddonCompatibilityMappings(current);
    ['groups', 'userentities', 'userfields'].forEach((category) => {
      const part = selection[category] && typeof selection[category] === 'object'
        ? selection[category]
        : {};
      Object.entries(part).forEach(([key, value]) => {
        const keyText = clean(key || '');
        if (!keyText) return;
        const valueText = clean(value || '');
        if (!valueText) {
          delete next[category][keyText];
          return;
        }
        next[category][keyText] = valueText;
      });
    });
    saveAddonCompatibilityState({ mappings: next });
    return next;
  }

  function addonCompatibilityLooksLikeAlreadyExistsError(messageInput = '') {
    const message = norm(messageInput || '');
    if (!message) return false;
    return message.includes('already exists')
      || message.includes('already assigned')
      || message.includes('deja')
      || message.includes('unique');
  }

  async function analyzeAddonCompatibility(optionsInput = {}) {
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const state = addonCompatibilityState();
    const mappings = options.useStateMappings === false
      ? addonCompatibilityEmptyMappings()
      : normalizeAddonCompatibilityMappings(state.mappings);

    const [groupsRows, userentityRows, userfieldRows] = await Promise.all([
      fetchProductGroupsForCompatibility(),
      fetchUserentitiesForCompatibility(),
      fetchUserfieldsForCompatibility(''),
    ]);

    const groupDefs = addonCompatibilityProductGroupDefinitions();
    const userentityDefs = addonCompatibilityUserentityDefinitions();
    const userfieldDefs = addonCompatibilityUserfieldDefinitions();

    const groupFindings = groupDefs.map((definition) => {
      const mapKey = addonCompatibilityGroupMapKey(definition.name || '');
      const expectedKey = addonCompatibilityMapKey(definition.name || '');
      const exactRow = groupsRows.find((row) => addonCompatibilityMapKey(row && row.name ? row.name : '') === expectedKey) || null;
      const mappingValue = clean(mappings.groups[mapKey] || '');
      const mappedRow = !exactRow && mappingValue
        ? (groupsRows.find((row) => addonCompatibilityMapKey(row && row.name ? row.name : '') === addonCompatibilityMapKey(mappingValue)) || null)
        : null;
      const status = exactRow ? 'existing' : (mappedRow ? 'mapped' : 'missing');
      const candidates = status === 'missing'
        ? addonCompatibilitySimilarityCandidates(
            [definition.name],
            groupsRows,
            (row) => ({
              value: clean(row && row.name ? row.name : ''),
              label: clean(row && row.name ? row.name : ''),
              scoreTexts: [clean(row && row.name ? row.name : '')],
            }),
            0.55,
            8
          )
        : [];
      const matchRow = exactRow || mappedRow;
      return {
        kind: 'group',
        mapCategory: 'groups',
        mapKey,
        expected: definition,
        status,
        matchRow,
        resolvedName: clean(matchRow && matchRow.name ? matchRow.name : definition.name || ''),
        candidates,
      };
    });

    const userentityFindings = userentityDefs.map((definition) => {
      const mapKey = addonCompatibilityUserentityMapKey(definition.name || '');
      const expectedKeys = new Set([
        addonCompatibilityMapKey(definition.name || ''),
        addonCompatibilityMapKey(definition.caption || ''),
        addonCompatibilityMapKey(definition.captionFr || ''),
        addonCompatibilityMapKey(definition.captionEn || ''),
      ].filter(Boolean));
      const exactRow = userentityRows.find((row) => {
        const rowNameKey = addonCompatibilityMapKey(row && row.name ? row.name : '');
        const rowCaptionKey = addonCompatibilityMapKey(row && row.caption ? row.caption : '');
        return expectedKeys.has(rowNameKey) || expectedKeys.has(rowCaptionKey);
      }) || null;
      const mappingValue = clean(mappings.userentities[mapKey] || '');
      const mappingKey = addonCompatibilityMapKey(mappingValue);
      const mappedRow = !exactRow && mappingKey
        ? (userentityRows.find((row) => {
          const rowNameKey = addonCompatibilityMapKey(row && row.name ? row.name : '');
          const rowCaptionKey = addonCompatibilityMapKey(row && row.caption ? row.caption : '');
          return rowNameKey === mappingKey || rowCaptionKey === mappingKey;
        }) || null)
        : null;
      const status = exactRow ? 'existing' : (mappedRow ? 'mapped' : 'missing');
      const candidates = status === 'missing'
        ? addonCompatibilitySimilarityCandidates(
            [definition.name, definition.caption],
            userentityRows,
            (row) => ({
              value: clean(row && row.name ? row.name : ''),
              label: clean(row && row.caption ? row.caption : (row && row.name ? row.name : '')),
              scoreTexts: [
                clean(row && row.name ? row.name : ''),
                clean(row && row.caption ? row.caption : ''),
              ],
            }),
            0.52,
            8
          )
        : [];
      const matchRow = exactRow || mappedRow;
      return {
        kind: 'userentity',
        mapCategory: 'userentities',
        mapKey,
        expected: definition,
        status,
        matchRow,
        resolvedName: clean(matchRow && matchRow.name ? matchRow.name : definition.name || ''),
        candidates,
      };
    });

    const userfieldFindings = userfieldDefs.map((definition) => {
      const mapKey = addonCompatibilityUserfieldMapKey(definition);
      const entityResolution = addonCompatibilityResolveUserfieldEntity(definition, userentityFindings);
      const entityKey = clean(entityResolution.entityKey || 'products') || 'products';
      const entityMatchKey = addonCompatibilityMapKey(entityKey);
      const entityRows = userfieldRows.filter(
        (row) => addonCompatibilityMapKey(row && row.entity ? row.entity : '') === entityMatchKey
      );
      const exactRow = entityRows.find((row) => userfieldMatchesAddonDefinition(row, definition)) || null;

      const mappedRef = clean(mappings.userfields[mapKey] || '');
      const parsedMappedRef = parseAddonCompatibilityUserfieldRowRef(mappedRef);
      let mappedRow = null;
      if (!exactRow && parsedMappedRef) {
        mappedRow = entityRows.find((row) => {
          const rowEntityKey = addonCompatibilityMapKey(row && row.entity ? row.entity : '');
          const rowNameKey = addonCompatibilityMapKey(row && row.name ? row.name : '');
          return rowEntityKey === addonCompatibilityMapKey(parsedMappedRef.entity)
            && rowNameKey === addonCompatibilityMapKey(parsedMappedRef.name);
        }) || null;
      }

      const status = exactRow ? 'existing' : (mappedRow ? 'mapped' : 'missing');
      const candidates = status === 'missing'
        ? addonCompatibilitySimilarityCandidates(
            [definition.name, definition.caption, definition.captionFr, definition.captionEn],
            entityRows,
            (row) => ({
              value: addonCompatibilityUserfieldRowRef(row),
              label: clean(row && row.caption ? row.caption : (row && row.name ? row.name : '')),
              scoreTexts: [
                clean(row && row.name ? row.name : ''),
                clean(row && row.caption ? row.caption : ''),
              ],
            }),
            0.5,
            8
          )
        : [];
      const matchRow = exactRow || mappedRow;
      return {
        kind: 'userfield',
        mapCategory: 'userfields',
        mapKey,
        expected: definition,
        status,
        matchRow,
        resolvedName: clean(matchRow && matchRow.name ? matchRow.name : definition.name || ''),
        targetEntityKey: entityKey,
        targetEntityDisplay: clean(entityResolution.entityDisplay || ''),
        expectedEntityName: clean(entityResolution.expectedEntityName || ''),
        candidates,
      };
    });

    const mappingSuggestions = [];

    groupFindings
      .filter((finding) => finding.status === 'missing' && finding.candidates.length > 0)
      .forEach((finding) => {
        mappingSuggestions.push({
          mapCategory: finding.mapCategory,
          mapKey: finding.mapKey,
          label: langText(`Groupe: ${finding.expected.name}`, `Group: ${finding.expected.name}`),
          expectedName: clean(finding.expected.name || ''),
          candidates: finding.candidates,
        });
      });

    userentityFindings
      .filter((finding) => finding.status === 'missing' && finding.candidates.length > 0)
      .forEach((finding) => {
        mappingSuggestions.push({
          mapCategory: finding.mapCategory,
          mapKey: finding.mapKey,
          label: langText(
            `Entité utilisateur: ${finding.expected.caption || finding.expected.name}`,
            `User entity: ${finding.expected.caption || finding.expected.name}`
          ),
          expectedName: clean(finding.expected.caption || finding.expected.name || ''),
          candidates: finding.candidates,
        });
      });

    userfieldFindings
      .filter((finding) => finding.status === 'missing' && finding.candidates.length > 0)
      .forEach((finding) => {
        const entityLabel = finding.targetEntityKey === 'products'
          ? langText('produits', 'products')
          : clean(finding.targetEntityDisplay || finding.expectedEntityName || '');
        mappingSuggestions.push({
          mapCategory: finding.mapCategory,
          mapKey: finding.mapKey,
          label: langText(
            `Attribut: ${finding.expected.caption || finding.expected.name} (${entityLabel})`,
            `Field: ${finding.expected.caption || finding.expected.name} (${entityLabel})`
          ),
          expectedName: clean(finding.expected.caption || finding.expected.name || ''),
          candidates: finding.candidates,
        });
      });

    const allFindings = [...groupFindings, ...userentityFindings, ...userfieldFindings];
    const existingCount = allFindings.filter((finding) => finding.status === 'existing').length;
    const mappedCount = allFindings.filter((finding) => finding.status === 'mapped').length;
    const missingCount = allFindings.filter((finding) => finding.status === 'missing').length;

    return {
      groupFindings,
      userentityFindings,
      userfieldFindings,
      mappingSuggestions,
      existingCount,
      mappedCount,
      missingCount,
      allSatisfied: missingCount === 0,
      createGroups: groupFindings.filter((finding) => finding.status === 'missing'),
      createUserentities: userentityFindings.filter((finding) => finding.status === 'missing'),
      createUserfields: userfieldFindings.filter((finding) => finding.status === 'missing'),
    };
  }

  function ensureAddonCompatibilityMappingModal() {
    if (document.getElementById('dash_addon_compat_mapping_modal')) return;
    const modal = document.createElement('div');
    modal.id = 'dash_addon_compat_mapping_modal';
    modal.className = 'd-none';
    modal.innerHTML = `
      <div class="dash-addon-compat-mapping-card card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <div class="font-weight-bold">${t('addon_compat_mapping_title')}</div>
          <button id="dash_addon_compat_mapping_close" type="button" class="btn btn-sm btn-outline-secondary">${t('addon_compat_mapping_close')}</button>
        </div>
        <div class="card-body">
          <div id="dash_addon_compat_mapping_intro" class="small text-muted mb-2"></div>
          <div id="dash_addon_compat_mapping_rows"></div>
        </div>
        <div class="card-footer d-flex justify-content-end flex-wrap">
          <button id="dash_addon_compat_mapping_skip" type="button" class="btn btn-sm btn-outline-secondary mr-2 mb-1">${t('addon_compat_mapping_skip')}</button>
          <button id="dash_addon_compat_mapping_apply" type="button" class="btn btn-sm btn-primary mb-1">${t('addon_compat_mapping_apply')}</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);

    const close = () => closeAddonCompatibilityMappingModal(null);
    modal.addEventListener('click', (event) => {
      if (event.target === modal) close();
    });
    document.getElementById('dash_addon_compat_mapping_close')?.addEventListener('click', close);
    document.addEventListener('keydown', (event) => {
      if (event && event.key === 'Escape' && !modal.classList.contains('d-none')) {
        close();
      }
    });
  }

  function closeAddonCompatibilityMappingModal(resultInput = null) {
    const modal = document.getElementById('dash_addon_compat_mapping_modal');
    if (modal) modal.classList.add('d-none');
    if (typeof S.addonCompatMappingResolve === 'function') {
      const resolver = S.addonCompatMappingResolve;
      S.addonCompatMappingResolve = null;
      resolver(resultInput);
    }
  }

  function openAddonCompatibilityMappingModal(suggestionsInput = []) {
    const suggestions = Array.isArray(suggestionsInput) ? suggestionsInput : [];
    if (!suggestions.length) return Promise.resolve(addonCompatibilityEmptyMappings());

    ensureAddonCompatibilityMappingModal();

    const modal = document.getElementById('dash_addon_compat_mapping_modal');
    const intro = document.getElementById('dash_addon_compat_mapping_intro');
    const rowsHost = document.getElementById('dash_addon_compat_mapping_rows');
    if (!modal || !rowsHost) return Promise.resolve(addonCompatibilityEmptyMappings());

    const stateMappings = normalizeAddonCompatibilityMappings(addonCompatibilityState().mappings);
    if (intro) {
      intro.textContent = t('addon_compat_mapping_intro', {
        count: fmt(suggestions.length, 0),
      });
    }

    const rowsHtml = suggestions.map((suggestion, index) => {
      const category = clean(suggestion.mapCategory || '');
      const key = clean(suggestion.mapKey || '');
      const currentValue = clean(
        stateMappings[category] && typeof stateMappings[category] === 'object'
          ? (stateMappings[category][key] || '')
          : ''
      );
      const optionRows = [
        `<option value="">${escapeHtml(t('addon_compat_mapping_create', { name: suggestion.expectedName || '' }))}</option>`,
        ...(Array.isArray(suggestion.candidates) ? suggestion.candidates : []).map((candidate) => {
          const value = clean(candidate && candidate.value ? candidate.value : '');
          const label = clean(candidate && candidate.label ? candidate.label : '');
          if (!value || !label) return '';
          const selected = addonCompatibilityMapKey(currentValue) === addonCompatibilityMapKey(value) ? ' selected' : '';
          return `<option value="${escapeHtml(value)}"${selected}>${escapeHtml(label)} (${escapeHtml(t('addon_compat_mapping_similarity', { score: fmt(num(candidate.score) * 100, 0) }))})</option>`;
        }).filter(Boolean),
      ].join('');
      return `
        <div class="form-group mb-2 pb-2 border-bottom">
          <label for="dash_addon_compat_map_${index}" class="mb-1 small font-weight-bold">${escapeHtml(clean(suggestion.label || ''))}</label>
          <select
            id="dash_addon_compat_map_${index}"
            class="form-control form-control-sm"
            data-addon-compat-map-category="${escapeHtml(category)}"
            data-addon-compat-map-key="${escapeHtml(key)}"
          >
            ${optionRows}
          </select>
        </div>
      `;
    }).join('');

    rowsHost.innerHTML = rowsHtml;

    const skipButton = document.getElementById('dash_addon_compat_mapping_skip');
    if (skipButton) {
      skipButton.onclick = () => {
        closeAddonCompatibilityMappingModal(addonCompatibilityEmptyMappings());
      };
    }
    const applyButton = document.getElementById('dash_addon_compat_mapping_apply');
    if (applyButton) {
      applyButton.onclick = () => {
        const payload = addonCompatibilityEmptyMappings();
        rowsHost.querySelectorAll('select[data-addon-compat-map-category][data-addon-compat-map-key]').forEach((select) => {
          const category = clean(select.getAttribute('data-addon-compat-map-category') || '');
          const key = clean(select.getAttribute('data-addon-compat-map-key') || '');
          if (!category || !key || !Object.prototype.hasOwnProperty.call(payload, category)) return;
          payload[category][key] = clean(select.value || '');
        });
        closeAddonCompatibilityMappingModal(payload);
      };
    }

    modal.classList.remove('d-none');

    if (typeof S.addonCompatMappingResolve === 'function') {
      S.addonCompatMappingResolve(addonCompatibilityEmptyMappings());
    }

    return new Promise((resolve) => {
      S.addonCompatMappingResolve = resolve;
    });
  }

  async function refreshAddonCompatibilityScan(optionsInput = {}) {
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    if (S.addonCompatScanPromise && options.force !== true) return S.addonCompatScanPromise;

    const run = async () => {
      try {
        const analysis = await analyzeAddonCompatibility();
        S.addonCompatScan = {
          checkedAt: new Date().toISOString(),
          allSatisfied: analysis.allSatisfied === true,
          missingCount: Math.max(0, Math.floor(num(analysis.missingCount))),
          mappedCount: Math.max(0, Math.floor(num(analysis.mappedCount))),
          existingCount: Math.max(0, Math.floor(num(analysis.existingCount))),
          suggestionCount: Array.isArray(analysis.mappingSuggestions) ? analysis.mappingSuggestions.length : 0,
        };

        const state = addonCompatibilityState();
        if (analysis.allSatisfied) {
          if (state.completed !== true || state.lastError) {
            saveAddonCompatibilityState({
              completed: true,
              lastError: '',
              lastSummary: state.lastSummary || t('addon_compat_status_ready'),
            });
          }
        } else if (state.completed === true) {
          saveAddonCompatibilityState({ completed: false });
        }

        if (options.render === true) {
          renderAddonCompatibilityBanner();
          syncAddonCompatibilitySettingsSection();
        }
        return analysis;
      } catch (_error) {
        S.addonCompatScan = null;
        if (options.render === true) {
          renderAddonCompatibilityBanner();
          syncAddonCompatibilitySettingsSection();
        }
        return null;
      } finally {
        S.addonCompatScanPromise = null;
      }
    };

    S.addonCompatScanPromise = run();
    return S.addonCompatScanPromise;
  }

  async function openAddonCompatibilityMappingAssistant() {
    if (S.addonCompatApplying) return { cancelled: false, updated: false };
    try {
      const analysis = await analyzeAddonCompatibility();
      if (!analysis || !Array.isArray(analysis.mappingSuggestions) || analysis.mappingSuggestions.length === 0) {
        const message = analysis && analysis.allSatisfied
          ? t('addon_compat_status_ready')
          : t('addon_compat_status_mapping_none');
        setAddonCompatibilitySettingsStatus(message, analysis && analysis.allSatisfied ? 'success' : 'muted');
        return { cancelled: false, updated: false };
      }
      const selection = await openAddonCompatibilityMappingModal(analysis.mappingSuggestions);
      if (selection === null) {
        setAddonCompatibilitySettingsStatus(t('addon_compat_status_mapping_cancelled'), 'warning');
        return { cancelled: true, updated: false };
      }
      addonCompatibilityMergeMappingSelection(selection);
      await refreshAddonCompatibilityScan({ render: true, force: true });
      return { cancelled: false, updated: true };
    } catch (error) {
      const message = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
      setAddonCompatibilitySettingsStatus(t('addon_compat_status_fail', { msg: message }), 'danger');
      return { cancelled: false, updated: false };
    }
  }

  function setAddonCompatibilitySettingsStatus(text = '', level = 'muted') {
    const node = document.getElementById('dash_addon_compat_status');
    if (!node) return;
    node.className = `small mt-2 text-${level}`;
    node.textContent = clean(text || '');
  }

  function syncAddonCompatibilitySettingsSection() {
    const runBtn = document.getElementById('dash_addon_compat_run');
    const mapBtn = document.getElementById('dash_addon_compat_map');
    const reofferBtn = document.getElementById('dash_addon_compat_reoffer');
    const state = addonCompatibilityState();
    if (runBtn) runBtn.disabled = S.addonCompatApplying === true;
    if (mapBtn) mapBtn.disabled = S.addonCompatApplying === true;
    if (reofferBtn) reofferBtn.disabled = S.addonCompatApplying === true;
    if (S.addonCompatApplying === true) {
      setAddonCompatibilitySettingsStatus(t('addon_compat_status_running'), 'info');
      return;
    }
    if (state.lastError) {
      setAddonCompatibilitySettingsStatus(t('addon_compat_status_fail', { msg: state.lastError }), 'danger');
      return;
    }
    if (state.lastSummary) {
      setAddonCompatibilitySettingsStatus(state.lastSummary, state.completed ? 'success' : 'warning');
      return;
    }
    if (S.addonCompatScan && S.addonCompatScan.allSatisfied) {
      setAddonCompatibilitySettingsStatus(t('addon_compat_status_ready'), 'success');
      return;
    }
    setAddonCompatibilitySettingsStatus(t('addon_compat_status_idle'), 'muted');
  }

  function addonCompatibilityBannerHost() {
    return document.getElementById('dash_addon_compat_banner_host');
  }

  function shouldShowAddonCompatibilityBanner() {
    const state = addonCompatibilityState();
    if (state.completed) return false;
    if (S.addonCompatScan && S.addonCompatScan.allSatisfied) return false;
    return state.onboardingSeen !== true;
  }

  function renderAddonCompatibilityBanner() {
    const host = addonCompatibilityBannerHost();
    if (!host) return;

    if (!shouldShowAddonCompatibilityBanner()) {
      host.classList.add('d-none');
      host.innerHTML = '';
      return;
    }

    const scan = S.addonCompatScan;
    const scopeText = scan && scan.missingCount > 0
      ? t('addon_compat_banner_missing_detail', {
        missing: fmt(scan.missingCount, 0),
        mapping: fmt(scan.suggestionCount || 0, 0),
      })
      : t('addon_compat_scope_note');
    const mapButtonHtml = scan && scan.suggestionCount > 0
      ? `<button id="dash_addon_compat_banner_map" type="button" class="btn btn-outline-warning">${t('addon_compat_banner_map')}</button>`
      : '';

    host.classList.remove('d-none');
    host.innerHTML = `
      <div class="alert alert-info border mb-0">
        <div class="d-flex justify-content-between align-items-center flex-wrap">
          <div class="small mb-2 mb-md-0">
            <div>${escapeHtml(t('addon_compat_banner_text'))}</div>
            <div class="text-muted">${escapeHtml(scopeText)}</div>
          </div>
          <div class="btn-group btn-group-sm">
            ${mapButtonHtml}
            <button id="dash_addon_compat_banner_apply" type="button" class="btn btn-outline-info">${t('addon_compat_banner_apply')}</button>
            <button id="dash_addon_compat_banner_later" type="button" class="btn btn-outline-secondary">${t('addon_compat_banner_later')}</button>
          </div>
        </div>
      </div>
    `;

    host.querySelector('#dash_addon_compat_banner_map')?.addEventListener('click', async () => {
      saveAddonCompatibilityState({ onboardingSeen: true });
      await openAddonCompatibilityMappingAssistant();
    });
    host.querySelector('#dash_addon_compat_banner_apply')?.addEventListener('click', async () => {
      saveAddonCompatibilityState({ onboardingSeen: true });
      await runAddonCompatibilitySetup({ source: 'banner' });
    });
    host.querySelector('#dash_addon_compat_banner_later')?.addEventListener('click', () => {
      saveAddonCompatibilityState({ onboardingSeen: true });
      renderAddonCompatibilityBanner();
      syncAddonCompatibilitySettingsSection();
    });
  }

  async function runAddonCompatibilitySetup(optionsInput = {}) {
    if (S.addonCompatApplying) return null;
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    S.addonCompatApplying = true;
    if (options.markSeen !== false) {
      saveAddonCompatibilityState({ onboardingSeen: true });
    }
    syncAddonCompatibilitySettingsSection();

    try {
      let analysis = await analyzeAddonCompatibility();
      if (!analysis) {
        throw new Error(t('focus_unknown_error'));
      }

      if (Array.isArray(analysis.mappingSuggestions) && analysis.mappingSuggestions.length > 0 && options.skipMappingPrompt !== true) {
        const selection = await openAddonCompatibilityMappingModal(analysis.mappingSuggestions);
        if (selection === null) {
          saveAddonCompatibilityState({
            onboardingSeen: true,
            completed: false,
            lastSummary: t('addon_compat_status_mapping_cancelled'),
            lastError: '',
          });
          syncAddonCompatibilitySettingsSection();
          renderAddonCompatibilityBanner();
          return { cancelled: true };
        }
        addonCompatibilityMergeMappingSelection(selection);
        analysis = await analyzeAddonCompatibility();
      }

      if (analysis.allSatisfied) {
        const summaryReady = t('addon_compat_status_ready');
        saveAddonCompatibilityState({
          onboardingSeen: true,
          completed: true,
          lastRunAt: new Date().toISOString(),
          lastSummary: summaryReady,
          lastError: '',
        });
        await refreshAddonCompatibilityScan({ render: true, force: true });
        syncAddonCompatibilitySettingsSection();
        renderAddonCompatibilityBanner();
        setAiSettingsStatus(summaryReady, 'success');
        return { created: 0, existing: analysis.existingCount, mapped: analysis.mappedCount, failed: 0, errors: [] };
      }

      let created = 0;
      let existing = analysis.existingCount;
      const mapped = analysis.mappedCount;
      let failed = 0;
      const errors = [];

      for (const finding of analysis.createGroups) {
        try {
          const payload = addonCompatibilityCreateProductGroupPayload(finding.expected);
          await postJson('api/objects/product_groups', payload);
          created += 1;
        } catch (error) {
          const message = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
          if (addonCompatibilityLooksLikeAlreadyExistsError(message)) {
            existing += 1;
            continue;
          }
          failed += 1;
          errors.push(`${finding.expected.name}: ${message}`);
        }
      }

      for (const finding of analysis.createUserentities) {
        try {
          const payload = addonCompatibilityCreateUserentityPayload(finding.expected);
          await createAddonCompatibilityUserentity(payload);
          created += 1;
        } catch (error) {
          const message = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
          if (addonCompatibilityLooksLikeAlreadyExistsError(message)) {
            existing += 1;
            continue;
          }
          failed += 1;
          errors.push(`${finding.expected.name}: ${message}`);
        }
      }

      for (const finding of analysis.createUserfields) {
        try {
          const payload = addonCompatibilityCreatePayload(finding.expected, finding.targetEntityKey);
          await postJson('api/objects/userfields', payload);
          created += 1;
        } catch (error) {
          const message = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
          if (addonCompatibilityLooksLikeAlreadyExistsError(message)) {
            existing += 1;
            continue;
          }
          failed += 1;
          errors.push(`${finding.expected.name}: ${message}`);
        }
      }

      const summary = t('addon_compat_status_done', {
        created: fmt(created, 0),
        existing: fmt(existing, 0),
        mapped: fmt(mapped, 0),
        failed: fmt(failed, 0),
      });
      saveAddonCompatibilityState({
        onboardingSeen: true,
        completed: failed === 0,
        lastRunAt: new Date().toISOString(),
        lastSummary: summary,
        lastError: errors.length ? errors.slice(0, 3).join(' | ') : '',
      });
      await refreshAddonCompatibilityScan({ render: true, force: true });
      syncAddonCompatibilitySettingsSection();
      renderAddonCompatibilityBanner();
      if (errors.length) {
        setAiSettingsStatus(t('addon_compat_status_fail', { msg: errors[0] }), 'warning');
      } else {
        setAiSettingsStatus(summary, 'success');
      }
      return { created, existing, mapped, failed, errors };
    } catch (error) {
      const message = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
      saveAddonCompatibilityState({
        onboardingSeen: true,
        completed: false,
        lastRunAt: new Date().toISOString(),
        lastSummary: '',
        lastError: message,
      });
      syncAddonCompatibilitySettingsSection();
      renderAddonCompatibilityBanner();
      setAiSettingsStatus(t('addon_compat_status_fail', { msg: message }), 'danger');
      return null;
    } finally {
      S.addonCompatApplying = false;
      syncAddonCompatibilitySettingsSection();
    }
  }

  function setAddonUpdateSettingsStatus(text = '', level = 'muted') {
    const node = document.getElementById('dash_addon_update_status');
    if (!node) return;
    node.className = `small mt-2 text-${level}`;
    node.textContent = clean(text || '');
  }

  function setAddonUpdateVersionsStatus(text = '', level = 'muted') {
    const node = document.getElementById('dash_addon_update_versions');
    if (!node) return;
    node.className = `small mt-2 text-${level}`;
    node.textContent = clean(text || '');
  }

  function addonUpdateReleaseChoices() {
    return Array.isArray(S.addonUpdateReleaseChoices) ? S.addonUpdateReleaseChoices : [];
  }

  function setAddonUpdateReleaseChoices(listInput = null) {
    const list = Array.isArray(listInput) ? listInput : [];
    S.addonUpdateReleaseChoices = list
      .map((row) => (row && typeof row === 'object' ? row : null))
      .filter(Boolean)
      .map((row) => ({
        repository: clean(row.repository || ''),
        tag: clean(row.tag || ''),
        version: clean(row.version || addonUpdateVersionFromTag(row.tag || '')),
        releaseUrl: clean(row.releaseUrl || ''),
        assetName: clean(row.assetName || ''),
        assetUrl: clean(row.assetUrl || ''),
        prerelease: row.prerelease === true,
        publishedAt: clean(row.publishedAt || ''),
        changelog: String(row.changelog || ''),
      }))
      .filter((row) => !!row.tag);
  }

  function renderAddonUpdateChangelog(changelogInput = '', metaInput = null) {
    const node = document.getElementById('dash_addon_update_changelog');
    if (!node) return;
    const text = String(changelogInput || '').replace(/\r\n/g, '\n').trim();
    const meta = metaInput && typeof metaInput === 'object' ? metaInput : {};
    const tag = clean(meta.tag || '');
    const publishedAt = clean(meta.publishedAt || '');
    if (!text) {
      node.innerHTML = `<div class="small text-muted">${escapeHtml(t('addon_update_changelog_empty'))}</div>`;
      syncStatNerdAboutInfoBlock();
      return;
    }
    const headerBits = [];
    if (tag) headerBits.push(t('addon_update_open_release_tag', { tag }));
    if (publishedAt) headerBits.push(addonUpdateFormatDate(publishedAt) || publishedAt);
    const header = headerBits.length ? `<div class="small text-muted mb-1">${escapeHtml(headerBits.join(' | '))}</div>` : '';
    node.innerHTML = `${header}<pre class="dash-addon-update-changelog mb-0">${escapeHtml(text)}</pre>`;
    syncStatNerdAboutInfoBlock();
  }

  function syncAddonUpdateReleaseChoicesUi(stateInput = null) {
    const host = document.getElementById('dash_addon_update_release_choices');
    if (!host) return;
    const state = normalizeAddonUpdateState(stateInput || addonUpdateState());
    const list = addonUpdateReleaseChoices();
    if (!list.length) {
      host.innerHTML = `<div class="small text-muted">${escapeHtml(t('addon_update_release_list_empty'))}</div>`;
      renderAddonUpdateChangelog(state.selectedChangelog || '', {
        tag: state.latestTag,
        publishedAt: state.selectedPublishedAt,
      });
      return;
    }
    const selectedTag = clean(state.latestTag || list[0].tag || '');
    host.innerHTML = list.map((row) => {
      const rowTag = clean(row.tag || '');
      const isSelected = rowTag === selectedTag;
      const css = isSelected ? 'btn-outline-info' : 'btn-outline-secondary';
      const badge = row.prerelease ? `<span class="badge badge-warning ml-1">${escapeHtml(t('addon_update_release_badge_prerelease'))}</span>` : '';
      const dateText = clean(row.publishedAt || '');
      const label = `${rowTag}${dateText ? ` • ${addonUpdateFormatDate(dateText) || dateText}` : ''}`;
      return `<button type="button" class="btn ${css} btn-sm mr-1 mb-1" data-addon-release-tag="${escapeHtml(rowTag)}">${escapeHtml(label)}${badge}</button>`;
    }).join('');
    const selected = list.find((row) => clean(row.tag || '') === selectedTag) || list[0];
    renderAddonUpdateChangelog(selected ? selected.changelog : state.selectedChangelog, {
      tag: selected ? selected.tag : state.latestTag,
      publishedAt: selected ? selected.publishedAt : state.selectedPublishedAt,
    });
  }

  function selectAddonUpdateReleaseByTag(tagInput = '', optionsInput = {}) {
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const tag = clean(tagInput || '');
    if (!tag) return null;
    const list = addonUpdateReleaseChoices();
    const release = list.find((row) => clean(row.tag || '') === tag);
    if (!release) return null;
    const next = saveAddonUpdateState({
      repository: clean(release.repository || addonUpdateState().repository || ADDON_UPDATE_DEFAULT_REPOSITORY),
      latestTag: clean(release.tag || ''),
      latestVersion: clean(release.version || ''),
      releaseUrl: clean(release.releaseUrl || ''),
      assetUrl: clean(release.assetUrl || ''),
      assetName: clean(release.assetName || ''),
      selectedChangelog: String(release.changelog || ''),
      selectedPublishedAt: clean(release.publishedAt || ''),
      includePrerelease: release.prerelease === true,
    });
    syncAddonUpdateCommandFields(next);
    syncAddonUpdateReleaseLink(next);
    syncAddonUpdateVersionSummary(next);
    syncAddonUpdateReleaseChoicesUi(next);
    syncAddonUpdateSettingsSection();
    if (options.withStatus === true) {
      setAddonUpdateSettingsStatus(t('addon_update_release_selected', { tag: release.tag }), 'success');
    }
    return next;
  }

  function syncAddonUpdateReleaseLink(stateInput = null) {
    const state = normalizeAddonUpdateState(stateInput || addonUpdateState());
    const link = document.getElementById('dash_addon_update_open_release');
    if (!link) return;
    const releaseUrl = clean(state.releaseUrl || '');
    if (!releaseUrl) {
      link.classList.add('d-none');
      link.removeAttribute('href');
      link.textContent = t('addon_update_open_release_btn');
      return;
    }
    link.classList.remove('d-none');
    link.setAttribute('href', releaseUrl);
    const tag = clean(state.latestTag || '');
    link.textContent = tag
      ? t('addon_update_open_release_tag', { tag })
      : t('addon_update_open_release_btn');
  }

  function syncAddonUpdateCommandFields(stateInput = null) {
    const state = normalizeAddonUpdateState(stateInput || addonUpdateState());
    const ps = document.getElementById('dash_addon_update_cmd_ps');
    const sh = document.getElementById('dash_addon_update_cmd_sh');
    if (ps) ps.value = addonUpdateCommandPowerShell(state);
    if (sh) sh.value = addonUpdateCommandShell(state);
  }

  function syncAddonUpdateVersionSummary(stateInput = null) {
    const state = normalizeAddonUpdateState(stateInput || addonUpdateState());
    const localVersion = addonUpdateLocalVersionValue(state);
    const remoteVersion = clean(state.latestVersion || addonUpdateVersionFromTag(state.latestTag || '')) || t('addon_update_version_unknown');
    const tag = clean(state.latestTag || '') || '-';
    const checkedLabel = state.checkedAt
      ? t('addon_update_last_checked', { date: addonUpdateFormatDate(state.checkedAt) || state.checkedAt })
      : t('addon_update_not_checked');
    const line = `${t('addon_update_versions_line', { local: localVersion, remote: remoteVersion, tag })} ${checkedLabel}`;
    setAddonUpdateVersionsStatus(line, 'muted');
  }

  function syncAddonUpdateSettingsSection() {
    const busy = S.addonUpdateChecking === true || S.addonUpdateInstalling === true;
    const ids = [
      'dash_addon_update_repo',
      'dash_addon_update_local_root',
      'dash_addon_update_local_root_browse',
      'dash_addon_update_check_stable',
      'dash_addon_update_check_prerelease',
      'dash_addon_update_run_bridge',
      'dash_addon_update_test_bridge',
      'dash_addon_update_copy_ps',
      'dash_addon_update_copy_sh',
    ];
    ids.forEach((id) => {
      const el = document.getElementById(id);
      if (el) el.disabled = busy;
    });
    if (busy) {
      setAddonUpdateSettingsStatus(
        S.addonUpdateInstalling === true ? t('addon_update_bridge_status_running') : t('addon_update_status_checking'),
        'info'
      );
      return;
    }

    const state = addonUpdateState();
    if (state.lastStatus) {
      setAddonUpdateSettingsStatus(state.lastStatus, normalizeAddonUpdateStatusLevel(state.lastStatusLevel || 'muted'));
      return;
    }
    if (state.lastError) {
      setAddonUpdateSettingsStatus(t('addon_update_status_error', { msg: state.lastError }), 'danger');
      return;
    }
    setAddonUpdateSettingsStatus(t('addon_update_status_idle'), 'muted');
  }

  async function copyAddonUpdateCommandFromField(fieldId = '') {
    const input = document.getElementById(fieldId);
    const text = clean(input?.value || '');
    if (!text) {
      setAddonUpdateSettingsStatus(t('addon_update_copy_fail'), 'warning');
      return false;
    }
    const copied = await copyTextToClipboard(text);
    setAddonUpdateSettingsStatus(copied ? t('addon_update_copy_ok') : t('addon_update_copy_fail'), copied ? 'success' : 'warning');
    return copied;
  }

  async function runAddonUpdateVersionCheck(optionsInput = {}) {
    if (S.addonUpdateChecking) return null;
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const includePrerelease = options.includePrerelease === true;
    const repoInput = document.getElementById('dash_addon_update_repo');
    const localRootInput = document.getElementById('dash_addon_update_local_root');
    const localRootPath = addonUpdateNormalizeLocalRootPath(localRootInput?.value || addonUpdateState().localRootPath || ADDON_UPDATE_DEFAULT_LOCAL_ROOT);
    const candidate = addonUpdateRepositoryText(repoInput?.value || addonUpdateState().repository || ADDON_UPDATE_DEFAULT_REPOSITORY);
    const parts = addonUpdateRepositoryParts(candidate);
    if (!parts) {
      const msg = t('addon_update_repo_invalid');
      const invalidState = saveAddonUpdateState({
        repository: clean(repoInput?.value || candidate || ADDON_UPDATE_DEFAULT_REPOSITORY),
        includePrerelease,
        localRootPath,
        checkedAt: new Date().toISOString(),
        lastError: msg,
        lastStatus: t('addon_update_status_error', { msg }),
        lastStatusLevel: 'danger',
      });
      syncAddonUpdateCommandFields(invalidState);
      syncAddonUpdateReleaseLink(invalidState);
      syncAddonUpdateVersionSummary(invalidState);
      syncAddonUpdateReleaseChoicesUi(invalidState);
      syncAddonUpdateSettingsSection();
      return null;
    }

    if (repoInput) repoInput.value = parts.repository;
    if (localRootInput) localRootInput.value = localRootPath;
    saveAddonUpdateState({ repository: parts.repository, includePrerelease, localRootPath, lastError: '' });

    S.addonUpdateChecking = true;
    syncAddonUpdateSettingsSection();

    let finalState = null;
    try {
      await refreshAddonInstalledVersionFromFile();
      const releases = await fetchAddonReleaseList(
        parts.repository,
        { includePrerelease, limit: includePrerelease ? ADDON_UPDATE_PRERELEASE_VISIBLE_LIMIT : 25 }
      );
      setAddonUpdateReleaseChoices(releases);
      const release = Array.isArray(releases) && releases.length ? releases[0] : null;
      if (!release) {
        throw new Error(t('addon_update_status_release_missing'));
      }
      const localVersion = addonUpdateLocalVersionValue(addonUpdateState());
      const remoteVersion = clean(release.version || addonUpdateVersionFromTag(release.tag || '')) || t('addon_update_version_unknown');
      const tag = clean(release.tag || '-');
      const compare = compareAddonSemver(localVersion, remoteVersion);

      let statusText = '';
      let statusLevel = 'info';
      if (!clean(release.assetUrl || '')) {
        statusText = t('addon_update_status_release_missing_asset', { tag });
        statusLevel = 'warning';
      } else if (compare < 0) {
        statusText = t('addon_update_status_update_available', {
          local: localVersion,
          latest: remoteVersion,
          tag,
        });
        statusLevel = 'warning';
      } else if (compare > 0) {
        statusText = t('addon_update_status_local_ahead', {
          local: localVersion,
          latest: remoteVersion,
        });
        statusLevel = 'info';
      } else {
        statusText = t('addon_update_status_up_to_date', { version: localVersion });
        statusLevel = 'success';
      }

      finalState = saveAddonUpdateState({
        repository: release.repository || parts.repository,
        includePrerelease,
        localRootPath,
        checkedAt: new Date().toISOString(),
        latestTag: clean(release.tag || ''),
        latestVersion: clean(release.version || ''),
        releaseUrl: clean(release.releaseUrl || ''),
        assetUrl: clean(release.assetUrl || ''),
        assetName: clean(release.assetName || ''),
        selectedChangelog: String(release.changelog || ''),
        selectedPublishedAt: clean(release.publishedAt || ''),
        lastError: '',
        lastStatus: statusText,
        lastStatusLevel: statusLevel,
      });
    } catch (error) {
      const message = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
      finalState = saveAddonUpdateState({
        repository: parts.repository,
        includePrerelease,
        localRootPath,
        checkedAt: new Date().toISOString(),
        lastError: message,
        lastStatus: t('addon_update_status_error', { msg: message }),
        lastStatusLevel: 'danger',
      });
    } finally {
      S.addonUpdateChecking = false;
      const state = finalState || addonUpdateState();
      syncAddonUpdateCommandFields(state);
      syncAddonUpdateReleaseLink(state);
      syncAddonUpdateVersionSummary(state);
      syncAddonUpdateReleaseChoicesUi(state);
      syncStatNerdAboutInfoBlock(state);
      syncAddonUpdateSettingsSection();
    }

    return finalState;
  }

  function fillAddonUpdateSettingsForm() {
    const state = addonUpdateState();
    const repoInput = document.getElementById('dash_addon_update_repo');
    const localRootInput = document.getElementById('dash_addon_update_local_root');
    if (repoInput) repoInput.value = clean(state.repository || ADDON_UPDATE_DEFAULT_REPOSITORY);
    if (localRootInput) localRootInput.value = addonUpdateNormalizeLocalRootPath(state.localRootPath || ADDON_UPDATE_DEFAULT_LOCAL_ROOT);
    syncAddonUpdateCommandFields(state);
    syncAddonUpdateReleaseLink(state);
    syncAddonUpdateVersionSummary(state);
    syncAddonUpdateReleaseChoicesUi(state);
    syncStatNerdAboutInfoBlock(state);
    syncAddonUpdateSettingsSection();
    refreshAddonInstalledVersionFromFile();
  }

  function providerFormFieldId(providerId, fieldName) {
    return `dash_ai_${providerId}_${fieldName}`;
  }

  function providerBadgeId(providerId) {
    return `dash_ai_badge_${providerId}`;
  }

  function providerFieldErrorId(providerId, fieldName) {
    return `dash_ai_err_${providerId}_${fieldName}`;
  }

  function providerValidationMsgId(providerId) {
    return `dash_ai_provider_validation_${providerId}`;
  }

  function aiProviderFieldMeta(fieldName) {
    const meta = AI_PROVIDER_FIELDS[fieldName] || { label: fieldName, labelEn: fieldName, type: 'text', placeholder: '' };
    const lang = resolveUiLanguage();
    const label = lang === 'en'
      ? clean(meta.labelEn || meta.label || fieldName)
      : clean(meta.label || meta.labelEn || fieldName);
    return {
      ...meta,
      label,
    };
  }

  function providerFieldHtml(providerId, fieldName) {
    const meta = aiProviderFieldMeta(fieldName);
    const id = providerFormFieldId(providerId, fieldName);
    const type = meta.type === 'password' ? 'password' : (meta.type === 'textarea' ? 'textarea' : 'text');
    const colClass = type === 'textarea' ? 'col-12' : 'col-md-6';
    const placeholder = meta.placeholder ? ` placeholder="${escapeHtml(meta.placeholder)}"` : '';

    if (type === 'textarea') {
      return `
        <div class="${colClass}">
          <div class="form-group mb-2">
            <label for="${id}" class="mb-1">${escapeHtml(meta.label)}</label>
            <textarea id="${id}" class="form-control form-control-sm" rows="2"${placeholder}></textarea>
            <div id="${providerFieldErrorId(providerId, fieldName)}" class="dash-ai-field-error small text-danger mt-1"></div>
          </div>
        </div>
      `;
    }

    return `
      <div class="${colClass}">
        <div class="form-group mb-2">
          <label for="${id}" class="mb-1">${escapeHtml(meta.label)}</label>
          <input type="${type}" id="${id}" class="form-control form-control-sm"${placeholder}>
          <div id="${providerFieldErrorId(providerId, fieldName)}" class="dash-ai-field-error small text-danger mt-1"></div>
        </div>
      </div>
    `;
  }

  function providerLinksHtml(def) {
    const links = Array.isArray(def.links) ? def.links : [];
    if (!links.length) return '';
    const items = links
      .filter((link) => link && link.url)
      .map((link) => {
        const labelKey = clean(link.labelKey || '');
        const label = labelKey ? t(labelKey) : clean(link.label || link.url);
        return `<a class="dash-ai-provider-link" href="${escapeHtml(link.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(label)}</a>`;
      })
      .join('');
    if (!items) return '';
    return `
      <div class="dash-ai-provider-links small">
        <span class="dash-ai-provider-links-title">${escapeHtml(t('ai_provider_links_title'))}:</span>
        <span class="dash-ai-provider-links-items">${items}</span>
      </div>
    `;
  }

  function providerCardHtml(def) {
    const fields = (def.fields || []).map((fieldName) => providerFieldHtml(def.id, fieldName)).join('');
    const help = clean(resolveUiLanguage() === 'en' ? (def.hintEn || def.hint) : (def.hint || def.hintEn));
    const linksHtml = providerLinksHtml(def);
    return `
      <details class="dash-ai-provider-card" data-ai-provider-card="${def.id}">
        <summary class="dash-ai-provider-summary">
          <span>${escapeHtml(def.label)}</span>
          <span id="${providerBadgeId(def.id)}" class="badge badge-secondary">${t('not_configured_short')}</span>
        </summary>
        ${help ? `<div class="small text-muted dash-ai-provider-help mt-2 mb-2">${escapeHtml(help)}</div>` : ''}
        ${linksHtml}
        <div class="form-row dash-ai-provider-fields">
          ${fields}
        </div>
        <div class="d-flex justify-content-between align-items-center flex-wrap mt-2">
          <div id="dash_ai_provider_validation_${escapeHtml(def.id)}" class="dash-ai-provider-validation-msg small"></div>
          <button type="button" class="btn btn-outline-info btn-sm" data-ai-provider-test="${escapeHtml(def.id)}">${t('ai_test_btn')}</button>
        </div>
      </details>
    `;
  }

  function initAiProviderFormLayout() {
    const providerSelect = document.getElementById('dash_ai_provider');
    const fallbackList = document.getElementById('dash_ai_fallback_list');
    const forms = document.getElementById('dash_ai_provider_forms');
    if (!providerSelect || !fallbackList || !forms) return;

    providerSelect.innerHTML = AI_PROVIDER_DEFS
      .map((def) => `<option value="${escapeHtml(def.id)}">${escapeHtml(def.label)}</option>`)
      .join('');
    fallbackList.innerHTML = AI_PROVIDER_DEFS
      .map((def) => `<option value="${escapeHtml(def.id)}">${escapeHtml(def.label)}</option>`)
      .join('');

    forms.innerHTML = AI_PROVIDER_DEFS.map((def) => providerCardHtml(def)).join('');
  }

  function syncAiProviderUiFromSelection() {
    const activeId = normalizeProviderId(document.getElementById('dash_ai_provider')?.value || aiSettings().activeProvider);
    const useFallback = document.getElementById('dash_ai_fallback_enabled')?.checked === true;
    const validationMode = selectedValidationModeFromForm(aiSettings());
    const showFallbackSection = validationMode === 'fallback_chain';
    const fallbackSelectionEnabled = useFallback || validationMode === 'fallback_chain';
    const fallbackList = document.getElementById('dash_ai_fallback_list');
    const fallbackSection = document.getElementById('dash_ai_fallback_section');

    if (fallbackSection) fallbackSection.classList.toggle('d-none', !showFallbackSection);

    Array.from(document.querySelectorAll('#dash_ai_provider_forms [data-ai-provider-card]')).forEach((card) => {
      const on = card.getAttribute('data-ai-provider-card') === activeId;
      card.classList.toggle('dash-ai-provider-active', on);
      if (on) card.open = true;
    });

    if (fallbackList) {
      fallbackList.disabled = !showFallbackSection || !fallbackSelectionEnabled;
      Array.from(fallbackList.options).forEach((option) => {
        const isActive = option.value === activeId;
        option.disabled = isActive;
        if (isActive) option.selected = false;
      });
    }
  }

  function syncAiProviderBadges(settingsInput) {
    const settings = normalizeAiSettings(settingsInput || readAiSettingsForm());
    AI_PROVIDER_DEFS.forEach((def) => {
      const badge = document.getElementById(providerBadgeId(def.id));
      if (!badge) return;
      const ok = isAiProviderConfigured(settings, def.id);
      const runtimeState = S.aiProviderRuntimeState[def.id] || '';
      if (runtimeState === 'rejected') {
        badge.className = 'badge badge-warning';
        badge.textContent = t('error_short');
        return;
      }
      badge.className = ok ? 'badge badge-success' : 'badge badge-secondary';
      badge.textContent = ok ? t('configured_short') : t('not_configured_short');
    });
  }

  function updateFallbackOrderStateFromUi() {
    const fallbackList = document.getElementById('dash_ai_fallback_list');
    if (!fallbackList) return;
    const selected = Array.from(fallbackList.selectedOptions || [])
      .map((option) => normalizeProviderId(option.value))
      .filter(Boolean);
    const prev = Array.isArray(S.aiFormState && S.aiFormState.fallbackOrder) ? S.aiFormState.fallbackOrder : [];
    const next = prev.filter((id) => selected.includes(id));
    selected.forEach((id) => {
      if (!next.includes(id)) next.push(id);
    });
    S.aiFormState = {
      ...(S.aiFormState && typeof S.aiFormState === 'object' ? S.aiFormState : {}),
      fallbackOrder: next,
    };
  }

  function orderedFallbackProvidersFromUi(activeProvider, fallbackList) {
    const selected = fallbackList
      ? Array.from(fallbackList.selectedOptions || [])
        .map((option) => normalizeProviderId(option.value))
        .filter((id, index, arr) => id && id !== activeProvider && arr.indexOf(id) === index)
      : [];
    const preferred = Array.isArray(S.aiFormState && S.aiFormState.fallbackOrder) ? S.aiFormState.fallbackOrder : [];
    const ordered = preferred.filter((id) => selected.includes(id) && id !== activeProvider);
    selected.forEach((id) => {
      if (!ordered.includes(id) && id !== activeProvider) ordered.push(id);
    });
    return ordered;
  }

  function selectedUiLanguageModeFromForm(baseSettings = null) {
    const switchRoot = document.getElementById('dash_ui_lang_switch');
    const stored = clean(switchRoot?.getAttribute('data-selected-ui-lang') || '');
    if (stored) return normalizeUiLanguageMode(stored);

    const hidden = clean(document.getElementById('dash_ui_lang_mode_value')?.value || '');
    if (hidden) return normalizeUiLanguageMode(hidden);

    const active = document.querySelector('#dash_ui_lang_switch [data-ui-lang].is-active');
    if (active && active.dataset && active.dataset.uiLang) {
      return normalizeUiLanguageMode(active.dataset.uiLang);
    }
    if (baseSettings) return normalizeUiLanguageMode(baseSettings.uiLanguageMode);
    return normalizeUiLanguageMode(aiSettings().uiLanguageMode);
  }

  function selectedValidationModeFromForm(baseSettings = null) {
    const switchRoot = document.getElementById('dash_ai_validation_switch');
    const stored = clean(switchRoot?.getAttribute('data-selected-ai-validation') || '');
    if (stored) return normalizeAiValidationMode(stored);

    const hidden = clean(document.getElementById('dash_ai_validation_mode_value')?.value || '');
    if (hidden) return normalizeAiValidationMode(hidden);

    const active = document.querySelector('#dash_ai_validation_switch [data-ai-validation].is-active');
    if (active && active.dataset && active.dataset.aiValidation) {
      return normalizeAiValidationMode(active.dataset.aiValidation);
    }
    if (baseSettings) return normalizeAiValidationMode(baseSettings.validationMode);
    return normalizeAiValidationMode(aiSettings().validationMode);
  }

  function syncUiLanguageModeButtons(modeInput) {
    const mode = normalizeUiLanguageMode(modeInput);
    const switchRoot = document.getElementById('dash_ui_lang_switch');
    if (!switchRoot) return;
    switchRoot.setAttribute('data-selected-ui-lang', mode);

    const hidden = document.getElementById('dash_ui_lang_mode_value');
    if (hidden) hidden.value = mode;

    Array.from(switchRoot.querySelectorAll('[data-ui-lang]')).forEach((button) => {
      const active = normalizeUiLanguageMode(button.dataset.uiLang) === mode;
      button.classList.toggle('is-active', active);
      button.classList.toggle('btn-primary', false);
      button.classList.toggle('btn-outline-secondary', false);
      button.setAttribute('aria-pressed', active ? 'true' : 'false');
    });

    const resolved = resolveUiLanguage({ ...normalizeAiSettings(aiSettings()), uiLanguageMode: mode });
    const hint = document.getElementById('dash_ui_lang_hint');
    if (hint) {
      const langLabel = languageName(resolved, resolved);
      hint.textContent = mode === 'auto'
        ? t('lang_mode_hint_auto', { lang: langLabel }, resolved)
        : t('lang_mode_hint_fixed', { lang: langLabel }, resolved);
    }
  }

  function syncValidationModeButtons(modeInput) {
    const mode = normalizeAiValidationMode(modeInput);
    const switchRoot = document.getElementById('dash_ai_validation_switch');
    if (!switchRoot) return;
    switchRoot.setAttribute('data-selected-ai-validation', mode);

    const hidden = document.getElementById('dash_ai_validation_mode_value');
    if (hidden) hidden.value = mode;

    Array.from(switchRoot.querySelectorAll('[data-ai-validation]')).forEach((button) => {
      const active = normalizeAiValidationMode(button.dataset.aiValidation) === mode;
      button.classList.toggle('is-active', active);
      button.setAttribute('aria-pressed', active ? 'true' : 'false');
    });

    const hint = document.getElementById('dash_ai_validation_hint');
    if (hint) {
      hint.textContent = mode === 'fallback_chain'
        ? t('ai_validation_mode_hint_fallback')
        : t('ai_validation_mode_hint_single');
    }
  }

  function syncDueDateDisplayFormat(modeInput) {
    const mode = normalizeDueDateDisplayFormat(modeInput);
    const select = document.getElementById('dash_due_date_format');
    if (select) select.value = mode;
    const hint = document.getElementById('dash_due_date_format_hint');
    if (hint) {
      const sample = formatDueDate(new Date('2026-02-14T00:00:00'), { ...normalizeAiSettings(aiSettings()), dueDateDisplayFormat: mode });
      hint.textContent = `${t('due_date_format_hint')} ${t('due_date_format_hint_sample', { sample })}`;
    }
  }

  function refreshTabsLanguageLabels() {
    const groupFilter = document.getElementById('product-group-filter');
    const allLabel = clean(groupFilter?.querySelector('option[value="all"]')?.textContent || (resolveUiLanguage() === 'fr' ? 'Tout' : 'All'));
    const tabAll = document.getElementById('tab_all');
    const tabFood = document.getElementById('tab_food');
    const tabMed = document.getElementById('tab_med');
    const tabHyg = document.getElementById('tab_hyg');
    const tabHouse = document.getElementById('tab_house');

    if (tabAll) tabAll.textContent = allLabel;
    if (tabFood) tabFood.textContent = t('tab_food');
    if (tabMed && tabMed.classList.contains('disabled')) tabMed.textContent = t('tab_meds_default');
    if (tabHyg && tabHyg.classList.contains('disabled')) tabHyg.textContent = t('tab_hyg_default');
    if (tabHouse && tabHouse.classList.contains('disabled')) tabHouse.textContent = t('tab_home_default');
  }

  function rebuildDashboardForLanguage() {
    const dashboard = document.getElementById('stock-analytics-dashboard');
    if (!dashboard) return;

    const body = document.getElementById('dash_body');
    const wasCollapsed = !body || body.classList.contains('d-none');
    const overlayEl = document.getElementById('dash_chart_overlay');
    const overlayWasOpen = !!(overlayEl && !overlayEl.classList.contains('d-none'));
    const overlayChartId = clean(S.fullChartId || '');

    closeChartOverlay();
    clearCharts();

    const chartOverlay = document.getElementById('dash_chart_overlay');
    if (chartOverlay && chartOverlay.parentNode) chartOverlay.parentNode.removeChild(chartOverlay);
    if (dashboard.parentNode) dashboard.parentNode.removeChild(dashboard);

    initDashboard();
    setDashboardView(S.dashboardView || 'stats');
    setRankingsDetailsExpanded(S.rankingsDetailsExpanded === true);

    if (wasCollapsed) {
      setDashboardCollapsed(true, { ensureReady: false });
    } else {
      setDashboardCollapsed(false, { ensureReady: false });
    }

    if (!wasCollapsed && overlayWasOpen && overlayChartId) {
      setTimeout(() => {
        if (!S.dashboardOpen) return;
        openChartOverlay(overlayChartId);
      }, 260);
    }
  }

  function rebuildAiSettingsOverlayForLanguage() {
    const overlay = document.getElementById('dash_ai_settings_overlay');
    const wasOpen = !!(overlay && !overlay.classList.contains('d-none'));
    setBrandLogoMenuOpen(false);
    setGroupLogoMenuOpen(false);
    closeBrandLogoLightbox();
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    if (wasOpen) openAiSettingsOverlay();
  }

  function refreshUiLanguageWithoutReload() {
    refreshTabsLanguageLabels();
    rebuildDashboardForLanguage();
    rebuildAiSettingsOverlayForLanguage();
  }

  function applyUiLanguageModeInstant(modeInput, { reload = true } = {}) {
    const mode = normalizeUiLanguageMode(modeInput);
    const base = normalizeAiSettings(aiSettings());
    const beforeMode = normalizeUiLanguageMode(base.uiLanguageMode);
    const next = { ...base, uiLanguageMode: mode };
    saveAiSettings(next);
    if (!reload && beforeMode !== mode) {
      refreshUiLanguageWithoutReload();
    }
    syncUiLanguageModeButtons(mode);
    syncAiSettingsButton();
    const resolved = resolveUiLanguage(next);
    setAiSettingsStatus(t('lang_applied_instant', { lang: languageName(resolved, resolved) }, resolved), 'success');
    if (reload && beforeMode !== mode) {
      setTimeout(() => window.location.reload(), 80);
    }
  }

  function syncAiSettingsButton() {
    const button = document.getElementById('dash_ai_settings_open');
    if (!button) return;
    const settings = aiSettings();
    const active = activeAiProvider(settings);
    const configured = settings.enabled && isAiProviderConfigured(settings, active.id);
    button.classList.toggle('btn-outline-secondary', !configured);
    button.classList.toggle('btn-outline-info', configured);
    button.title = configured
      ? t('ai_settings_btn_title_configured', { provider: active.def.label })
      : t('ai_settings_btn_title_not_configured', { provider: active.def.label });
  }

  function closeAiSettingsOverlay() {
    setBrandLogoMenuOpen(false);
    setGroupLogoMenuOpen(false);
    closeBrandLogoLightbox();
    const overlay = document.getElementById('dash_ai_settings_overlay');
    if (overlay) overlay.classList.add('d-none');
  }

  function setPhotoSearchSettingsStatus(text = '', level = 'muted') {
    const status = document.getElementById('dash_photo_search_status');
    if (!status) return;
    status.className = `small mt-2 text-${level}`;
    status.textContent = clean(text || '');
  }

  function syncPhotoSearchSettingsHint() {
    const engine = normalizePhotoSearchEngine(
      document.getElementById('dash_photo_search_engine')?.value
      || photoSearchSettings().engine
    );
    const hint = document.getElementById('dash_photo_search_engine_hint');
    if (hint) hint.textContent = photoSearchEngineHint(engine);
  }

  function fillPhotoSearchSettingsForm() {
    const settings = normalizePhotoSearchSettings(photoSearchSettings());
    const engineSelect = document.getElementById('dash_photo_search_engine');
    const fallback = document.getElementById('dash_photo_search_off_name_fallback');
    if (engineSelect) engineSelect.value = settings.engine;
    if (fallback) fallback.checked = settings.offNameFallback === true;
    syncPhotoSearchSettingsHint();
    setPhotoSearchSettingsStatus('', 'muted');
  }

  function readPhotoSearchSettingsForm() {
    const base = normalizePhotoSearchSettings(photoSearchSettings());
    const engine = normalizePhotoSearchEngine(document.getElementById('dash_photo_search_engine')?.value || base.engine);
    const offNameFallback = document.getElementById('dash_photo_search_off_name_fallback')?.checked === true;
    return { engine, offNameFallback };
  }

  function savePhotoSearchSettingsFromForm(showGlobalStatus = false) {
    const saved = savePhotoSearchSettings(readPhotoSearchSettingsForm());
    setPhotoSearchSettingsStatus(
      `${t('photo_search_status_saved')} ${photoSearchEngineLabel(saved.engine)}.`,
      'success'
    );
    if (showGlobalStatus) {
      setAiSettingsStatus(t('settings_section_saved', { section: t('settings_section_photo_search') }), 'success');
    }
    if (typeof S.productImageSearchRefresh === 'function') {
      try { S.productImageSearchRefresh(); } catch (_err) {}
    }
    return saved;
  }

  function setBarcodeLookupSettingsStatus(text = '', level = 'muted') {
    const status = document.getElementById('dash_barcode_lookup_status');
    if (!status) return;
    status.className = `small mt-2 text-${level}`;
    status.textContent = clean(text || '');
  }

  function setFactsApiTestStatus(text = '', level = 'muted') {
    const status = document.getElementById('dash_facts_api_test_status');
    if (!status) return;
    status.className = `small mt-2 text-${level}`;
    status.textContent = clean(text || '');
  }

  async function runFactsProviderApiTest(providerIdInput = '') {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput);
    const providerLabel = barcodeLookupProviderLabel(providerId);
    const buttonId = providerId === 'openproductsfacts' ? 'dash_facts_test_opf' : 'dash_facts_test_off';
    const button = document.getElementById(buttonId);
    const startedAt = Date.now();
    setFactsApiTestStatus(t('facts_api_test_running', { provider: providerLabel }), 'info');
    if (button) setButtonBusy(button, true);
    try {
      const result = await fetchBarcodeLookupProductsByName('cola', providerId);
      const durationMs = Math.max(1, Date.now() - startedAt);
      const count = Array.isArray(result.products) ? result.products.length : 0;
      setFactsApiTestStatus(t('facts_api_test_success', {
        provider: providerLabel,
        count: fmt(count, 0),
        ms: fmt(durationMs, 0),
      }), 'success');
      return { ok: true, provider: providerId, durationMs, count };
    } catch (error) {
      const msg = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
      setFactsApiTestStatus(t('facts_api_test_error', { provider: providerLabel, msg }), 'danger');
      return { ok: false, provider: providerId, durationMs: Math.max(1, Date.now() - startedAt), message: msg };
    } finally {
      if (button) setButtonBusy(button, false);
    }
  }

  async function runFactsActiveOrderApiTest() {
    const settings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
    const activeBtn = document.getElementById('dash_facts_test_active');
    if (settings.enabled !== true) {
      setFactsApiTestStatus(t('facts_provider_disabled'), 'warning');
      return;
    }
    const order = barcodeLookupProviderOrder(settings);
    if (activeBtn) setButtonBusy(activeBtn, true);
    try {
      const failures = [];
      for (const providerId of order) {
        const result = await runFactsProviderApiTest(providerId);
        if (result.ok) {
          setFactsApiTestStatus(t('facts_api_test_active_success', {
            provider: barcodeLookupProviderLabel(providerId),
            ms: fmt(result.durationMs, 0),
          }), 'success');
          return;
        }
        failures.push(`${barcodeLookupProviderLabel(providerId)}: ${clean(result.message || t('focus_unknown_error'))}`);
      }
      setFactsApiTestStatus(t('facts_api_test_active_error', { msg: failures.join(' | ') || t('focus_unknown_error') }), 'danger');
    } finally {
      if (activeBtn) setButtonBusy(activeBtn, false);
    }
  }

  function syncBarcodeLookupSettingsHint() {
    const provider = normalizeBarcodeLookupProvider(
      document.getElementById('dash_barcode_lookup_provider')?.value
      || barcodeLookupSettings().provider
    );
    const enabledToggle = document.getElementById('dash_barcode_lookup_enabled');
    const enabled = enabledToggle ? enabledToggle.checked === true : normalizeBarcodeLookupSettings(barcodeLookupSettings()).enabled === true;
    const hint = document.getElementById('dash_barcode_lookup_hint');
    const orderNote = document.getElementById('dash_barcode_lookup_order_note');
    if (hint) {
      hint.textContent = enabled
        ? barcodeLookupProviderHint(provider)
        : t('barcode_lookup_provider_hint_off');
    }
    if (orderNote) {
      const order = barcodeLookupProviderOrder({
        provider,
        enabled,
        autoFallback: document.getElementById('dash_barcode_lookup_auto_fallback')?.checked === true,
      }).map((id) => barcodeLookupProviderLabel(id)).join(' -> ');
      orderNote.textContent = t('facts_provider_switch_note', { order });
    }
  }

  function fillBarcodeLookupSettingsForm() {
    const settings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
    const providerSelect = document.getElementById('dash_barcode_lookup_provider');
    const enabled = document.getElementById('dash_barcode_lookup_enabled');
    const autoFallback = document.getElementById('dash_barcode_lookup_auto_fallback');
    if (providerSelect) providerSelect.value = settings.provider;
    if (enabled) enabled.checked = settings.enabled === true;
    if (autoFallback) autoFallback.checked = settings.autoFallback === true;
    syncBarcodeLookupSettingsHint();
    setBarcodeLookupSettingsStatus('', 'muted');
  }

  function readBarcodeLookupSettingsForm() {
    const base = normalizeBarcodeLookupSettings(barcodeLookupSettings());
    const provider = normalizeBarcodeLookupProvider(document.getElementById('dash_barcode_lookup_provider')?.value || base.provider);
    const enabled = document.getElementById('dash_barcode_lookup_enabled')?.checked === true;
    const autoFallback = document.getElementById('dash_barcode_lookup_auto_fallback')?.checked === true;
    return { provider, enabled, autoFallback };
  }

  function saveBarcodeLookupSettingsFromForm(showGlobalStatus = false) {
    const saved = saveBarcodeLookupSettings(readBarcodeLookupSettingsForm());
    const label = barcodeLookupProviderLabel(saved.provider);
    const enabled = saved.enabled === true ? t('barcode_lookup_enabled_yes') : t('barcode_lookup_enabled_no');
    const fallback = saved.autoFallback === true ? t('barcode_lookup_fallback_yes') : t('barcode_lookup_fallback_no');
    setBarcodeLookupSettingsStatus(t('barcode_lookup_status_saved', { provider: label, fallback, enabled }), 'success');
    if (showGlobalStatus) {
      setAiSettingsStatus(t('settings_section_saved', { section: t('settings_section_barcode_lookup') }), 'success');
    }
    try {
      if (typeof S.productImageSearchRefresh === 'function') S.productImageSearchRefresh();
      if (typeof S.productBarcodesHeaderRefresh === 'function') S.productBarcodesHeaderRefresh();
      document.querySelectorAll('form#barcode-form').forEach((form) => {
        if (form && typeof form.__offBarcodeRefresh === 'function') {
          try { form.__offBarcodeRefresh(); } catch (_err) {}
        }
      });
      initBarcodeAutofillButtons(document);
    } catch (_err) {}
    return saved;
  }

  function fillAiSettingsForm() {
    const settings = normalizeAiSettings(aiSettings());
    const providerSelect = document.getElementById('dash_ai_provider');
    const fallbackToggle = document.getElementById('dash_ai_fallback_enabled');
    const fallbackList = document.getElementById('dash_ai_fallback_list');
    const enabled = document.getElementById('dash_ai_enabled');
    const focusMode = document.getElementById('dash_ai_focus_mode');
    const temp = document.getElementById('dash_ai_temp');
    const timeout = document.getElementById('dash_ai_timeout');
    const status = document.getElementById('dash_ai_status');

    initAiProviderFormLayout();

    if (enabled) enabled.checked = settings.enabled === true;
    if (providerSelect) providerSelect.value = normalizeProviderId(settings.activeProvider);
    if (fallbackToggle) fallbackToggle.checked = settings.useFallback === true;
    if (focusMode) focusMode.value = normalizeAiFocusMode(settings.focusMode);
    syncUiLanguageModeButtons(settings.uiLanguageMode);
    syncDueDateDisplayFormat(settings.dueDateDisplayFormat);
    syncValidationModeButtons(settings.validationMode);
    if (fallbackList) {
      const selected = new Set(settings.fallbackProviders || []);
      Array.from(fallbackList.options).forEach((option) => {
        option.selected = selected.has(option.value);
      });
    }
    S.aiFormState = {
      ...(S.aiFormState && typeof S.aiFormState === 'object' ? S.aiFormState : {}),
      fallbackOrder: Array.isArray(settings.fallbackProviders) ? [...settings.fallbackProviders] : [],
    };
    if (temp) temp.value = String(Number.isFinite(settings.temperature) ? settings.temperature : 0.25);
    if (timeout) timeout.value = String(Number.isFinite(settings.timeoutMs) ? settings.timeoutMs : 18000);

    AI_PROVIDER_DEFS.forEach((def) => {
      const cfg = aiProviderSettings(settings, def.id);
      const fields = Object.keys(def.defaults || {});
      fields.forEach((fieldName) => {
        const input = document.getElementById(providerFormFieldId(def.id, fieldName));
        if (!input) return;
        const value = Object.prototype.hasOwnProperty.call(cfg, fieldName) ? cfg[fieldName] : '';
        input.value = String(value || '');
      });
    });

    syncAiProviderUiFromSelection();
    syncAiProviderBadges(settings);
    clearAiProviderValidationUi();
    renderBrandLogoEditor();
    setBrandLogoMenuOpen(false);
    setBrandLogoEditorStatus(S.brandLogoLookupEnabled ? '' : t('brand_logo_lookup_off'), 'muted');
    renderGroupLogoEditor();
    setGroupLogoMenuOpen(false);
    setGroupLogoEditorStatus('', 'muted');
    fillPhotoSearchSettingsForm();
    fillBarcodeLookupSettingsForm();
    setFactsApiTestStatus('', 'muted');
    syncAddonCompatibilitySettingsSection();
    fillAddonUpdateSettingsForm();
    collapseDonneSettingsGroups();
    if (status) status.textContent = '';
  }

  function readAiSettingsForm() {
    const base = normalizeAiSettings(aiSettings());
    updateFallbackOrderStateFromUi();
    const enabled = document.getElementById('dash_ai_enabled')?.checked === true;
    const activeProvider = normalizeProviderId(document.getElementById('dash_ai_provider')?.value || base.activeProvider);
    const focusMode = normalizeAiFocusMode(document.getElementById('dash_ai_focus_mode')?.value || base.focusMode);
    const validationMode = selectedValidationModeFromForm(base);
    const useFallback = validationMode === 'fallback_chain' && document.getElementById('dash_ai_fallback_enabled')?.checked === true;
    const uiLanguageMode = selectedUiLanguageModeFromForm(base);
    const dueDateDisplayFormat = normalizeDueDateDisplayFormat(document.getElementById('dash_due_date_format')?.value || base.dueDateDisplayFormat);
    const fallbackList = document.getElementById('dash_ai_fallback_list');
    const fallbackProviders = validationMode === 'fallback_chain'
      ? orderedFallbackProvidersFromUi(activeProvider, fallbackList)
      : [];

    const temp = clamp(num(document.getElementById('dash_ai_temp')?.value || '0.25'), 0, 1.2);
    const timeoutMs = clamp(num(document.getElementById('dash_ai_timeout')?.value || '18000'), 3000, 120000);

    const providers = {};
    AI_PROVIDER_DEFS.forEach((def) => {
      const next = { ...(base.providers?.[def.id] || def.defaults || {}) };
      const fields = Object.keys(def.defaults || {});
      fields.forEach((fieldName) => {
        const input = document.getElementById(providerFormFieldId(def.id, fieldName));
        if (!input) return;
        if (fieldName === 'extraHeaders') {
          next[fieldName] = String(input.value || '').trim();
        } else {
          next[fieldName] = clean(input.value || '');
        }
      });
      providers[def.id] = sanitizeAiProviderConfig(def.id, next);
    });

    return {
      enabled,
      activeProvider,
      useFallback,
      focusMode,
      validationMode,
      uiLanguageMode,
      dueDateDisplayFormat,
      fallbackProviders,
      temperature: temp,
      timeoutMs,
      providers,
    };
  }

  function readAiSettingsFormNonProvider() {
    const base = normalizeAiSettings(aiSettings());
    updateFallbackOrderStateFromUi();
    const enabled = document.getElementById('dash_ai_enabled')?.checked === true;
    const activeProvider = normalizeProviderId(document.getElementById('dash_ai_provider')?.value || base.activeProvider);
    const focusMode = normalizeAiFocusMode(document.getElementById('dash_ai_focus_mode')?.value || base.focusMode);
    const validationMode = selectedValidationModeFromForm(base);
    const useFallback = validationMode === 'fallback_chain' && document.getElementById('dash_ai_fallback_enabled')?.checked === true;
    const uiLanguageMode = selectedUiLanguageModeFromForm(base);
    const dueDateDisplayFormat = normalizeDueDateDisplayFormat(document.getElementById('dash_due_date_format')?.value || base.dueDateDisplayFormat);
    const fallbackList = document.getElementById('dash_ai_fallback_list');
    const fallbackProviders = validationMode === 'fallback_chain'
      ? orderedFallbackProvidersFromUi(activeProvider, fallbackList)
      : [];
    const temperature = clamp(num(document.getElementById('dash_ai_temp')?.value || '0.25'), 0, 1.2);
    const timeoutMs = clamp(num(document.getElementById('dash_ai_timeout')?.value || '18000'), 3000, 120000);

    return normalizeAiSettings({
      ...base,
      enabled,
      activeProvider,
      useFallback,
      focusMode,
      validationMode,
      uiLanguageMode,
      dueDateDisplayFormat,
      fallbackProviders,
      temperature,
      timeoutMs,
      providers: base.providers,
    });
  }

  function saveAiSettingsFromCurrentForm(sectionLabel = '') {
    const base = normalizeAiSettings(aiSettings());
    const candidate = normalizeAiSettings(readAiSettingsForm());
    candidate.uiLanguageMode = normalizeUiLanguageMode(base.uiLanguageMode);
    const saved = saveAiSettings(candidate);
    syncAiProviderBadges(saved);
    syncAiSettingsButton();
    clearAiCache();
    if (S.overlayFocus) renderOverlayFocusCard(S.overlayFocus, true, 'manual');
    if (sectionLabel) {
      setAiSettingsStatus(t('settings_section_saved', { section: sectionLabel }), 'success');
    }
    return saved;
  }

  function saveAiNonProviderSettingsFromForm(sectionLabel = '') {
    const candidate = readAiSettingsFormNonProvider();
    const saved = saveAiSettings(candidate);
    syncAiProviderBadges(saved);
    syncAiSettingsButton();
    clearAiCache();
    if (S.overlayFocus) renderOverlayFocusCard(S.overlayFocus, true, 'manual');
    if (sectionLabel) {
      setAiSettingsStatus(t('settings_section_saved', { section: sectionLabel }), 'success');
    }
    return saved;
  }

  function saveAiProviderSettingsAfterTest() {
    const base = normalizeAiSettings(aiSettings());
    const fromForm = normalizeAiSettings(readAiSettingsForm());
    const merged = {
      ...base,
      activeProvider: normalizeProviderId(fromForm.activeProvider || base.activeProvider),
      validationMode: normalizeAiValidationMode(fromForm.validationMode || base.validationMode),
      useFallback: fromForm.useFallback === true,
      fallbackProviders: Array.isArray(fromForm.fallbackProviders) ? fromForm.fallbackProviders : [],
      providers: fromForm.providers && typeof fromForm.providers === 'object' ? fromForm.providers : base.providers,
    };
    const saved = saveAiSettings(merged);
    syncAiProviderBadges(saved);
    syncAiSettingsButton();
    clearAiCache();
    if (S.overlayFocus) renderOverlayFocusCard(S.overlayFocus, true, 'manual');
    return saved;
  }

  function saveBrandLogoSectionSettings(showStatus = true) {
    applyBrandLogoSectionFormToState();
    saveBrandLogoSettings();
    if (showStatus) {
      setBrandLogoEditorStatus(t('settings_section_saved', { section: t('settings_section_brand_logos') }), 'success');
    }
  }

  function saveGroupLogoSectionSettings(showStatus = true) {
    saveBrandLogoSettings();
    if (showStatus) {
      setGroupLogoEditorStatus(t('settings_section_saved', { section: t('settings_section_group_logos') }), 'success');
    }
  }

  function setAiSettingsStatus(text, level = 'muted') {
    const status = document.getElementById('dash_ai_status');
    if (!status) return;
    status.className = `small mt-2 text-${level}`;
    status.textContent = text;
  }

  function setAiSettingsBusyState(isBusy) {
    const busy = isBusy === true;
    S.aiValidationInProgress = busy;
    const ids = [
      'dash_ai_save',
      'dash_ai_save_interface',
      'dash_ai_save_runtime',
      'dash_ai_save_providers',
      'dash_photo_search_engine',
      'dash_photo_search_off_name_fallback',
      'dash_photo_search_save',
      'dash_barcode_lookup_provider',
      'dash_barcode_lookup_enabled',
      'dash_barcode_lookup_auto_fallback',
      'dash_barcode_lookup_save',
      'dash_facts_test_off',
      'dash_facts_test_opf',
      'dash_facts_test_active',
      'dash_addon_compat_run',
      'dash_addon_compat_map',
      'dash_addon_compat_reoffer',
      'dash_addon_update_repo',
      'dash_addon_update_local_root',
      'dash_addon_update_local_root_browse',
      'dash_addon_update_check_stable',
      'dash_addon_update_check_prerelease',
      'dash_addon_update_copy_ps',
      'dash_addon_update_copy_sh',
      'dash_due_date_format',
      'dash_brand_logo_save_section',
      'dash_brand_logo_lookup',
      'dash_brand_logo_fetch_all',
      'dash_brand_logo_save',
      'dash_brand_logo_clear',
      'dash_brand_logo_reset',
      'dash_brand_logo_zoom',
      'dash_brand_logo_brand_toggle',
      'dash_brand_logo_source',
      'dash_brand_logo_logodev_token',
      'dash_group_logo_save_section',
      'dash_group_logo_save',
      'dash_group_logo_clear',
      'dash_group_logo_reset',
      'dash_group_logo_zoom',
      'dash_group_logo_group_toggle',
      'dash_group_logo_group',
      'dash_group_logo_url',
    ];
    ids.forEach((id) => {
      const el = document.getElementById(id);
      if (el) el.disabled = busy;
    });
    document.querySelectorAll('[data-ai-provider-test]').forEach((button) => {
      if (button) button.disabled = busy;
    });
    if (!busy) {
      syncAddonCompatibilitySettingsSection();
      syncAddonUpdateSettingsSection();
    }
  }

  function setAiProviderFieldError(providerId, fieldName, message = '') {
    const target = document.getElementById(providerFieldErrorId(providerId, fieldName));
    const input = document.getElementById(providerFormFieldId(providerId, fieldName));
    if (!target) return;
    target.textContent = clean(message || '');
    if (input) {
      input.classList.toggle('is-invalid', !!clean(message || ''));
    }
  }

  function setAiProviderValidationState(providerId, state = 'none', message = '') {
    const card = document.querySelector(`#dash_ai_provider_forms [data-ai-provider-card="${providerId}"]`);
    const msg = document.getElementById(providerValidationMsgId(providerId));
    if (state === 'none') {
      delete S.aiProviderRuntimeState[providerId];
    } else {
      S.aiProviderRuntimeState[providerId] = state;
    }
    if (card) {
      card.classList.toggle('dash-ai-provider-rejected', state === 'rejected');
      card.classList.toggle('dash-ai-provider-validated', state === 'valid');
    }
    if (msg) {
      msg.className = 'dash-ai-provider-validation-msg small';
      msg.textContent = clean(message || '');
      if (state === 'rejected') msg.classList.add('text-danger');
      if (state === 'valid') msg.classList.add('text-success');
    }
    syncAiProviderBadges();
  }

  function clearAiProviderValidationUi() {
    AI_PROVIDER_DEFS.forEach((def) => {
      setAiProviderValidationState(def.id, 'none', '');
      Object.keys(def.defaults || {}).forEach((fieldName) => {
        setAiProviderFieldError(def.id, fieldName, '');
      });
    });
    S.aiProviderRuntimeState = {};
    syncAiProviderBadges();
  }

  function isAiLowCreditErrorMessage(message) {
    const text = norm(message || '');
    if (!text) return false;
    return /quota|credit|insufficient|billing|payment|solde|limite|429|exceeded|too many requests/.test(text);
  }

  function isAiAccessDeniedErrorMessage(message) {
    const text = norm(message || '');
    if (!text) return false;
    return /forbidden|unauthorized|access denied|access is denied|invalid api key|invalid key|permission|401|403|authentication/.test(text);
  }

  function missingRequiredFields(settingsInput, providerId) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const def = aiProviderDef(providerId);
    const cfg = aiProviderSettings(settings, providerId);
    const required = Array.isArray(def.required) ? def.required : [];
    return required.filter((field) => !clean(cfg[field] || ''));
  }

  function detectFieldFromError(message, providerId) {
    const text = norm(message || '');
    if (!text) return '';
    if (/model|unknown model|invalid model|not supported/.test(text)) return 'model';
    if (/api key|apikey|token|authentication|unauthorized|forbidden|permission|401|403|invalid key/.test(text)) return 'apiKey';
    if (/base url|endpoint|host|url|404|not found|connection refused|network/.test(text)) return 'baseUrl';
    if (/deployment/.test(text)) return 'deployment';
    if (/resource/.test(text)) return 'resource';
    if (/api version|version/.test(text)) return 'apiVersion';
    if (/organization|org_/.test(text)) return 'organization';
    if (/project/.test(text)) return 'project';
    if (/header/.test(text)) return 'extraHeaders';
    if (/keep alive/.test(text)) return 'keepAlive';
    return '';
  }

  function aiValidationRuntime(settingsInput) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    return aiRuntimeFromOptions(settings, {
      temperature: 0.1,
      maxOutputTokens: 32,
      timeoutMs: Math.min(clamp(num(settings.timeoutMs || 9000), 3000, 120000), 9000),
    });
  }

  async function validateSingleProvider(settingsInput, providerId) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const id = normalizeProviderId(providerId);
    const label = aiProviderLabel(id);
    if (!isAiProviderConfigured(settings, id)) {
      const missing = missingRequiredFields(settings, id);
      return {
        ok: false,
        providerId: id,
        providerLabel: label,
        message: t('ai_test_incomplete', { provider: label }),
        reason: 'incomplete',
        missingFields: missing,
      };
    }

    try {
      const runtime = aiValidationRuntime(settings);
      const text = await callAiProviderText(id, settings, t('ai_test_prompt_tiny'), runtime);
      const normalizedText = aiTextFromUnknown(text);
      if (!normalizedText) {
        return {
          ok: false,
          providerId: id,
          providerLabel: label,
          message: t('ai_empty_response_short'),
          reason: 'empty',
        };
      }
      return {
        ok: true,
        providerId: id,
        providerLabel: label,
        message: normalizedText.slice(0, 80),
        reason: 'ok',
      };
    } catch (error) {
      const message = clean(error && error.message ? error.message : String(error));
      return {
        ok: false,
        providerId: id,
        providerLabel: label,
        message: message || t('focus_unknown_error'),
        reason: 'error',
      };
    }
  }

  function validationProviderOrder(settingsInput) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const mode = normalizeAiValidationMode(settings.validationMode);
    if (mode === 'fallback_chain') {
      const order = [normalizeProviderId(settings.activeProvider)];
      (settings.fallbackProviders || []).forEach((id) => {
        const normalized = normalizeProviderId(id);
        if (!order.includes(normalized)) order.push(normalized);
      });
      return order;
    }
    return [normalizeProviderId(settings.activeProvider)];
  }

  async function validateProvidersForSave(settingsInput) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const order = validationProviderOrder(settings);
    const failures = [];
    let success = null;

    clearAiProviderValidationUi();

    for (const providerId of order) {
      const result = await validateSingleProvider(settings, providerId);
      if (result.ok) {
        success = result;
        setAiProviderValidationState(providerId, 'valid', `${t('ai_provider_valid_short')}: ${result.providerLabel}`);
        break;
      }

      const message = clean(result.message || '');
      let fieldMessage = message;
      if (isAiLowCreditErrorMessage(message)) {
        fieldMessage = t('ai_api_key_error_low_credit');
      } else if (isAiAccessDeniedErrorMessage(message)) {
        fieldMessage = t('ai_api_key_error_access_denied');
      }

      setAiProviderValidationState(
        providerId,
        'rejected',
        t('ai_provider_rejected_reason', { msg: message || t('focus_unknown_error') })
      );
      setAiProviderFieldError(providerId, 'apiKey', fieldMessage);
      failures.push(`${result.providerLabel}: ${message || t('focus_unknown_error')}`);
    }

    return {
      ok: !!success,
      success,
      failures,
      order,
    };
  }

  async function testAiProvider(providerId) {
    const id = normalizeProviderId(providerId);
    if (!id || S.aiValidationInProgress) return;
    const settings = normalizeAiSettings(readAiSettingsForm());
    setAiSettingsBusyState(true);
    setAiProviderValidationState(id, 'none', '');
    setAiProviderFieldError(id, 'apiKey', '');
    try {
      const result = await validateSingleProvider(settings, id);
      if (result.ok) {
        setAiProviderValidationState(id, 'valid', `${t('ai_provider_valid_short')}: ${result.providerLabel}`);
        return;
      }
      const message = clean(result.message || '');
      let fieldMessage = message;
      if (isAiLowCreditErrorMessage(message)) {
        fieldMessage = t('ai_api_key_error_low_credit');
      } else if (isAiAccessDeniedErrorMessage(message)) {
        fieldMessage = t('ai_api_key_error_access_denied');
      }
      setAiProviderValidationState(
        id,
        'rejected',
        t('ai_provider_rejected_reason', { msg: message || t('focus_unknown_error') })
      );
      if (result.reason === 'incomplete') {
        const missing = Array.isArray(result.missingFields) ? result.missingFields : [];
        if (missing.length) {
          missing.forEach((field) => setAiProviderFieldError(id, field, t('ai_field_required')));
        } else {
          setAiProviderFieldError(id, 'apiKey', t('ai_test_incomplete', { provider: result.providerLabel }));
        }
      } else {
        const detectedField = detectFieldFromError(message, id);
        if (detectedField) setAiProviderFieldError(id, detectedField, fieldMessage);
        else setAiProviderFieldError(id, 'apiKey', fieldMessage);
      }
    } finally {
      try {
        saveAiProviderSettingsAfterTest();
        setAiSettingsStatus(t('settings_section_saved', { section: t('settings_section_providers') }), 'success');
      } catch (_err) {
        // Keep provider test UX responsive even if autosave fails.
      }
      setAiSettingsBusyState(false);
    }
  }

  function setBrandLogoEditorStatus(text, level = 'muted') {
    const el = document.getElementById('dash_brand_logo_status');
    if (!el) return;
    el.className = `small mt-2 text-${level}`;
    el.textContent = clean(text || '');
  }

  function setGroupLogoEditorStatus(text, level = 'muted') {
    const el = document.getElementById('dash_group_logo_status');
    if (!el) return;
    el.className = `small mt-2 text-${level}`;
    el.textContent = clean(text || '');
  }

  function knownBrandsForLogoEditor() {
    const fromRows = collectKnownBrands(S.lastAllRows);
    const byKey = new Map();
    fromRows.forEach((brand) => byKey.set(brandKey(brand), brand));
    S.brandLogoOverrides.forEach((entry, key) => {
      if (byKey.has(key)) return;
      const brand = clean(entry && entry.brand ? entry.brand : '');
      byKey.set(key, brand || key);
    });
    return Array.from(byKey.values())
      .filter(Boolean)
      .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
  }

  function knownGroupsForLogoEditor() {
    const fromRows = collectKnownGroups(S.lastAllRows);
    const byKey = new Map();
    fromRows.forEach((group) => byKey.set(groupKey(group), group));
    S.groupLogoOverrides.forEach((entry, key) => {
      if (byKey.has(key)) return;
      const group = clean(entry && entry.group ? entry.group : '');
      byKey.set(key, group || key);
    });
    return Array.from(byKey.values())
      .filter(Boolean)
      .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
  }

  function selectedBrandLogoState() {
    const brandInput = document.getElementById('dash_brand_logo_brand');
    const brand = clean(brandInput?.value || '');
    const key = brandKey(brand);
    if (!key) {
      return {
        brand: '',
        key: '',
        overrideUrl: '',
        defaultUrl: '',
        effectiveUrl: '',
        cleared: false,
      };
    }
    const overrideUrl = brandLogoOverrideUrl(brand);
    const defaultUrl = brandLogoDefaultUrl(brand);
    const cleared = S.brandLogoCleared.has(key);
    const effectiveUrl = brandLogoEffectiveUrl(brand);
    return { brand, key, overrideUrl, defaultUrl, effectiveUrl, cleared };
  }

  function selectedGroupLogoState() {
    rebuildGroupLogoDefaultCache(S.lastAllRows);
    const groupInput = document.getElementById('dash_group_logo_group');
    const group = clean(groupInput?.value || '');
    const key = groupKey(group);
    if (!key) {
      return {
        group: '',
        key: '',
        overrideUrl: '',
        defaultUrl: '',
        effectiveUrl: '',
        cleared: false,
      };
    }
    const overrideUrl = groupLogoOverrideUrl(group);
    const defaultUrl = groupLogoDefaultUrl(group);
    const cleared = S.groupLogoCleared.has(key);
    const effectiveUrl = groupLogoEffectiveUrl(group);
    return { group, key, overrideUrl, defaultUrl, effectiveUrl, cleared };
  }

  function readBrandLogoSourceFromUi() {
    const select = document.getElementById('dash_brand_logo_source');
    return normalizeBrandLogoSource(select?.value || S.brandLogoSource || 'duckduckgo');
  }

  function readBrandLogoDevTokenFromUi() {
    const input = document.getElementById('dash_brand_logo_logodev_token');
    return clean(input?.value || S.brandLogoLogoDevToken || '');
  }

  function applyBrandLogoSectionFormToState() {
    S.brandLogoSource = readBrandLogoSourceFromUi();
    S.brandLogoLogoDevToken = readBrandLogoDevTokenFromUi();
    return {
      source: S.brandLogoSource,
      logoDevToken: S.brandLogoLogoDevToken,
    };
  }

  async function fetchExternalJson(url) {
    const response = await fetch(url, { headers: { Accept: 'application/json' } });
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  }

  function brandDomainCandidates(brand, officialWebsite = '') {
    const candidates = [];
    const push = (raw) => {
      const value = clean(raw || '').toLowerCase();
      if (!value || candidates.includes(value)) return;
      if (!/^[a-z0-9.-]+\.[a-z]{2,}$/i.test(value)) return;
      candidates.push(value);
    };

    if (officialWebsite) {
      try {
        const host = new URL(officialWebsite).hostname || '';
        push(host.replace(/^www\./i, ''));
      } catch (_err) {}
    }

    const base = norm(brand || '').replace(/[^a-z0-9]+/g, '');
    if (base) {
      push(`${base}.com`);
      push(`${base}.fr`);
      push(`${base}.net`);
    }

    const words = norm(brand || '')
      .split(/[^a-z0-9]+/g)
      .filter(Boolean);
    if (words.length > 1) {
      const compact = words.join('');
      push(`${compact}.com`);
      push(`${compact}.fr`);
      push(`${words[0]}.com`);
      push(`${words[0]}.fr`);
    }

    return candidates;
  }

  function simpleIconSlugCandidates(brand) {
    const raw = norm(brand || '');
    const compact = raw
      .replace(/&/g, ' and ')
      .replace(/[^a-z0-9]+/g, ' ')
      .trim()
      .split(/\s+/g)
      .filter(Boolean);
    const joined = compact.join('');
    const candidates = [
      joined,
      compact.join('-'),
      compact.join('_'),
      compact.slice(0, 2).join(''),
    ]
      .map((value) => clean(value || '').toLowerCase().replace(/[^a-z0-9-]/g, ''))
      .filter((value, index, arr) => value && arr.indexOf(value) === index);
    return candidates;
  }

  function preloadImage(url, timeoutMs = 9000) {
    return new Promise((resolve) => {
      const imageUrl = clean(url || '');
      if (!imageUrl) {
        resolve(false);
        return;
      }
      const img = new Image();
      let done = false;
      const finish = (ok) => {
        if (done) return;
        done = true;
        resolve(ok === true);
      };
      const timer = setTimeout(() => finish(false), timeoutMs);
      img.onload = () => {
        clearTimeout(timer);
        finish(true);
      };
      img.onerror = () => {
        clearTimeout(timer);
        finish(false);
      };
      img.src = imageUrl;
    });
  }

  function waitMs(duration) {
    const ms = Math.max(0, Math.floor(num(duration)));
    return new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
  }

  function wikidataPickStatementValue(entity, propertyId) {
    const claims = entity && entity.claims ? entity.claims : null;
    const rows = claims && Array.isArray(claims[propertyId]) ? claims[propertyId] : [];
    for (const row of rows) {
      const value = row
        && row.mainsnak
        && row.mainsnak.datavalue
        ? row.mainsnak.datavalue.value
        : null;
      if (typeof value === 'string' && clean(value)) return clean(value);
    }
    return '';
  }

  async function wikidataSearchBrandEntity(brand) {
    const queryUrl = `https://www.wikidata.org/w/api.php?action=wbsearchentities&search=${encodeURIComponent(brand)}&language=en&type=item&format=json&origin=*`;
    const payload = await fetchExternalJson(queryUrl);
    const rows = Array.isArray(payload && payload.search) ? payload.search : [];
    return rows.find((row) => clean(row && row.id)) || null;
  }

  async function wikidataEntityById(entityId) {
    const id = clean(entityId || '');
    if (!id) return null;
    const payload = await fetchExternalJson(`https://www.wikidata.org/wiki/Special:EntityData/${encodeURIComponent(id)}.json`);
    if (!payload || !payload.entities) return null;
    return payload.entities[id] || null;
  }

  async function commonsFileUrlFromFileName(fileName) {
    const file = clean(fileName || '');
    if (!file) return '';
    const title = `File:${file}`;
    const apiUrl = `https://commons.wikimedia.org/w/api.php?action=query&titles=${encodeURIComponent(title)}&prop=imageinfo&iiprop=url&format=json&origin=*`;
    const payload = await fetchExternalJson(apiUrl);
    const pages = payload && payload.query && payload.query.pages ? Object.values(payload.query.pages) : [];
    const info = pages[0] && Array.isArray(pages[0].imageinfo) ? pages[0].imageinfo[0] : null;
    return clean(info && info.url ? info.url : '');
  }

  async function fetchBrandLogoViaWikidata(brand) {
    const hit = await wikidataSearchBrandEntity(brand);
    if (!hit || !clean(hit.id)) return { url: '', website: '' };
    const entity = await wikidataEntityById(hit.id);
    if (!entity) return { url: '', website: '' };
    const logoFile = wikidataPickStatementValue(entity, 'P154');
    const website = wikidataPickStatementValue(entity, 'P856');
    if (!logoFile) return { url: '', website };
    const url = await commonsFileUrlFromFileName(logoFile);
    if (!url) return { url: '', website };
    const ok = await preloadImage(url);
    return { url: ok ? url : '', website };
  }

  async function fetchBrandLogoViaSimpleIcons(brand) {
    const slugs = simpleIconSlugCandidates(brand);
    for (const slug of slugs) {
      const url = `https://cdn.simpleicons.org/${encodeURIComponent(slug)}`;
      const ok = await preloadImage(url);
      if (ok) return { url };
    }
    return { url: '' };
  }

  async function fetchBrandLogoViaDuckDuckGo(brand, websiteHint = '') {
    const domains = brandDomainCandidates(brand, websiteHint);
    for (const domain of domains) {
      const clearbitUrl = `https://logo.clearbit.com/${encodeURIComponent(domain)}?size=512`;
      const clearbitOk = await preloadImage(clearbitUrl);
      if (clearbitOk) return { url: clearbitUrl, domain };
      const url = `https://icons.duckduckgo.com/ip3/${encodeURIComponent(domain)}.ico`;
      const ok = await preloadImage(url);
      if (ok) return { url, domain };
    }
    return { url: '', domain: '' };
  }

  async function fetchBrandLogoViaLogoDev(brand, token = '') {
    const apiToken = clean(token || '');
    if (!apiToken) {
      throw new Error(t('brand_logo_logodev_token_missing'));
    }
    const url = `https://img.logo.dev/name/${encodeURIComponent(brand)}?token=${encodeURIComponent(apiToken)}&size=768`;
    const ok = await preloadImage(url);
    return { url: ok ? url : '' };
  }

  async function fetchBrandLogoFromSelectedSource(brand) {
    const source = normalizeBrandLogoSource(S.brandLogoSource || readBrandLogoSourceFromUi());
    if (source === 'database') {
      return { source, sourceLabel: brandLogoSourceLabel(source), url: '', website: '', domain: '' };
    }

    if (source === 'wikidata') {
      const result = await fetchBrandLogoViaWikidata(brand);
      return { source, sourceLabel: brandLogoSourceLabel(source), ...result };
    }

    if (source === 'simpleicons') {
      const result = await fetchBrandLogoViaSimpleIcons(brand);
      return { source, sourceLabel: brandLogoSourceLabel(source), ...result };
    }

    if (source === 'duckduckgo') {
      const fromWiki = await fetchBrandLogoViaWikidata(brand).catch(() => ({ website: '' }));
      const result = await fetchBrandLogoViaDuckDuckGo(brand, fromWiki.website || '');
      return { source, sourceLabel: brandLogoSourceLabel(source), ...result };
    }

    if (source === 'logodev') {
      const result = await fetchBrandLogoViaLogoDev(brand, S.brandLogoLogoDevToken || readBrandLogoDevTokenFromUi());
      return { source, sourceLabel: brandLogoSourceLabel(source), ...result };
    }

    return { source, sourceLabel: brandLogoSourceLabel(source), url: '' };
  }

  function brandLogoFetchDelayMs(source) {
    const id = normalizeBrandLogoSource(source);
    if (id === 'simpleicons') return 140;
    if (id === 'duckduckgo') return 320;
    if (id === 'logodev') return 380;
    if (id === 'wikidata') return 750;
    return 0;
  }

  function brandLogoNeedsFetch(brand) {
    const key = brandKey(brand);
    if (!key) return false;
    if (S.brandLogoCleared.has(key)) return false;
    if (brandLogoOverrideUrl(brand)) return false;
    if (brandLogoDefaultUrl(brand)) return false;
    return true;
  }

  function brandLogoComboElements() {
    return {
      combo: document.getElementById('dash_brand_logo_brand_combo'),
      input: document.getElementById('dash_brand_logo_brand'),
      toggle: document.getElementById('dash_brand_logo_brand_toggle'),
      menu: document.getElementById('dash_brand_logo_brand_menu'),
    };
  }

  function groupLogoComboElements() {
    return {
      combo: document.getElementById('dash_group_logo_group_combo'),
      input: document.getElementById('dash_group_logo_group'),
      toggle: document.getElementById('dash_group_logo_group_toggle'),
      menu: document.getElementById('dash_group_logo_group_menu'),
    };
  }

  function setBrandLogoMenuOpen(open) {
    const { menu, toggle } = brandLogoComboElements();
    const normalized = open === true;
    if (menu) menu.classList.toggle('d-none', !normalized);
    if (toggle) {
      toggle.classList.toggle('is-open', normalized);
      toggle.setAttribute('aria-expanded', normalized ? 'true' : 'false');
    }
  }

  function isBrandLogoMenuOpen() {
    const { menu } = brandLogoComboElements();
    return !!menu && !menu.classList.contains('d-none');
  }

  function setGroupLogoMenuOpen(open) {
    const { menu, toggle } = groupLogoComboElements();
    const normalized = open === true;
    if (menu) menu.classList.toggle('d-none', !normalized);
    if (toggle) {
      toggle.classList.toggle('is-open', normalized);
      toggle.setAttribute('aria-expanded', normalized ? 'true' : 'false');
    }
  }

  function isGroupLogoMenuOpen() {
    const { menu } = groupLogoComboElements();
    return !!menu && !menu.classList.contains('d-none');
  }

  function filteredBrandsForLogoEditor(brandsInput, queryInput) {
    const brands = Array.isArray(brandsInput) ? brandsInput : [];
    const query = norm(queryInput || '');
    if (!query) return brands;
    return brands.filter((brand) => norm(brand).includes(query));
  }

  function filteredGroupsForLogoEditor(groupsInput, queryInput) {
    const groups = Array.isArray(groupsInput) ? groupsInput : [];
    const query = norm(queryInput || '');
    if (!query) return groups;
    return groups.filter((group) => norm(group).includes(query));
  }

  function isDirectEditKey(key) {
    if (!key) return false;
    if (key === 'Backspace' || key === 'Delete') return true;
    return key.length === 1;
  }

  function renderBrandLogoBrandMenu(brandsInput, queryInput = '') {
    const { menu } = brandLogoComboElements();
    if (!menu) return [];
    const filteredBrands = filteredBrandsForLogoEditor(brandsInput, queryInput);
    if (!filteredBrands.length) {
      menu.innerHTML = `<div class="dash-brand-logo-menu-empty">${escapeHtml(t('brand_logo_brand_empty'))}</div>`;
      return [];
    }

    const rows = filteredBrands
      .slice(0, 180)
      .map((brand) => `<button type="button" class="dash-brand-logo-menu-item" data-brand-option="${escapeHtml(brand)}">${escapeHtml(brand)}</button>`)
      .join('');
    menu.innerHTML = rows;
    return filteredBrands;
  }

  function renderGroupLogoGroupMenu(groupsInput, queryInput = '') {
    const { menu } = groupLogoComboElements();
    if (!menu) return [];
    const filteredGroups = filteredGroupsForLogoEditor(groupsInput, queryInput);
    if (!filteredGroups.length) {
      menu.innerHTML = `<div class="dash-brand-logo-menu-empty">${escapeHtml(t('group_logo_group_empty'))}</div>`;
      return [];
    }

    const rows = filteredGroups
      .slice(0, 180)
      .map((group) => `<button type="button" class="dash-brand-logo-menu-item" data-group-option="${escapeHtml(group)}">${escapeHtml(group)}</button>`)
      .join('');
    menu.innerHTML = rows;
    return filteredGroups;
  }

  function selectBrandFromBrandLogoMenu(brandName) {
    const { input } = brandLogoComboElements();
    if (!input) return;
    const brand = clean(brandName || '');
    if (!brand) return;
    input.value = brand;
    if (input.dataset) input.dataset.clearOnType = '0';
    setBrandLogoMenuOpen(false);
    renderBrandLogoEditor();
  }

  function selectGroupFromGroupLogoMenu(groupName) {
    const { input } = groupLogoComboElements();
    if (!input) return;
    const group = clean(groupName || '');
    if (!group) return;
    input.value = group;
    if (input.dataset) input.dataset.clearOnType = '0';
    setGroupLogoMenuOpen(false);
    renderGroupLogoEditor();
  }

  function initBrandLogoLightbox() {
    if (document.getElementById('dash_brand_logo_lightbox')) return;
    const lightbox = document.createElement('div');
    lightbox.id = 'dash_brand_logo_lightbox';
    lightbox.className = 'd-none';
    lightbox.innerHTML = `
      <div class="dash-brand-logo-lightbox-card card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <div class="font-weight-bold">${t('brand_logo_modal_title')}</div>
          <button id="dash_brand_logo_lightbox_close" type="button" class="btn btn-sm btn-outline-secondary">${t('brand_logo_modal_close')}</button>
        </div>
        <div class="card-body">
          <div class="dash-brand-logo-lightbox-preview p-2">
            <img id="dash_brand_logo_lightbox_img" src="" alt="">
          </div>
          <div id="dash_brand_logo_lightbox_meta" class="dash-brand-logo-lightbox-meta small mt-2 text-muted"></div>
        </div>
      </div>
    `;
    document.body.appendChild(lightbox);
    document.getElementById('dash_brand_logo_lightbox_close')?.addEventListener('click', () => {
      closeBrandLogoLightbox();
    });
    lightbox.addEventListener('click', (event) => {
      if (event.target === lightbox) closeBrandLogoLightbox();
    });
    document.addEventListener('keydown', (event) => {
      if (event && event.key === 'Escape') {
        const isOpen = !lightbox.classList.contains('d-none');
        if (isOpen) closeBrandLogoLightbox();
      }
    });
  }

  function closeBrandLogoLightbox() {
    const lightbox = document.getElementById('dash_brand_logo_lightbox');
    if (lightbox) lightbox.classList.add('d-none');
  }

  function logoUrlForLargeDisplay(urlInput) {
    const source = clean(urlInput || '');
    if (!source) return '';

    if (/img\.logo\.dev\//i.test(source)) {
      if (/([?&])size=\d+/i.test(source)) return source.replace(/([?&]size=)\d+/i, '$1768');
      return `${source}${source.includes('?') ? '&' : '?'}size=768`;
    }

    if (/logo\.clearbit\.com\//i.test(source)) {
      if (/([?&])size=\d+/i.test(source)) return source.replace(/([?&]size=)\d+/i, '$1512');
      return `${source}${source.includes('?') ? '&' : '?'}size=512`;
    }

    return source;
  }

  function openBrandLogoLightboxFromState(stateInput = null) {
    const state = stateInput || selectedBrandLogoState();
    if (!state || !state.effectiveUrl) {
      setBrandLogoEditorStatus(t('brand_logo_status_missing_logo'), 'warning');
      return;
    }

    initBrandLogoLightbox();
    const lightbox = document.getElementById('dash_brand_logo_lightbox');
    const img = document.getElementById('dash_brand_logo_lightbox_img');
    const meta = document.getElementById('dash_brand_logo_lightbox_meta');
    if (!lightbox || !img || !meta) return;

    const source = state.overrideUrl ? t('brand_logo_preview_override') : t('brand_logo_preview_default');
    img.src = logoUrlForLargeDisplay(state.effectiveUrl);
    img.alt = clean(state.brand || t('default_brand'));
    meta.textContent = `${clean(state.brand || t('default_brand'))} - ${source}`;
    lightbox.classList.remove('d-none');
  }

  function openGroupLogoLightboxFromState(stateInput = null) {
    const state = stateInput || selectedGroupLogoState();
    if (!state || !state.effectiveUrl) {
      setGroupLogoEditorStatus(t('group_logo_status_missing_logo'), 'warning');
      return;
    }

    initBrandLogoLightbox();
    const lightbox = document.getElementById('dash_brand_logo_lightbox');
    const img = document.getElementById('dash_brand_logo_lightbox_img');
    const meta = document.getElementById('dash_brand_logo_lightbox_meta');
    if (!lightbox || !img || !meta) return;

    const source = state.overrideUrl ? t('group_logo_preview_override') : t('group_logo_preview_default');
    img.src = logoUrlForLargeDisplay(state.effectiveUrl);
    img.alt = clean(state.group || t('default_no_group'));
    meta.textContent = `${clean(state.group || t('default_no_group'))} - ${source}`;
    lightbox.classList.remove('d-none');
  }

  function renderBrandLogoEditor(options = {}) {
    const keepUrl = options && options.keepUrl === true;
    const keepMenuOpen = options && options.keepMenuOpen === true;
    const brandInput = document.getElementById('dash_brand_logo_brand');
    const sourceSelect = document.getElementById('dash_brand_logo_source');
    const sourceHint = document.getElementById('dash_brand_logo_source_hint');
    const tokenInput = document.getElementById('dash_brand_logo_logodev_token');
    const urlInput = document.getElementById('dash_brand_logo_url');
    const preview = document.getElementById('dash_brand_logo_preview');
    const saveBtn = document.getElementById('dash_brand_logo_save');
    const clearBtn = document.getElementById('dash_brand_logo_clear');
    const resetBtn = document.getElementById('dash_brand_logo_reset');
    const lookupBtn = document.getElementById('dash_brand_logo_lookup');
    const zoomBtn = document.getElementById('dash_brand_logo_zoom');
    const toggleBtn = document.getElementById('dash_brand_logo_brand_toggle');
    if (!brandInput || !urlInput || !preview) return;

    const brands = knownBrandsForLogoEditor();
    const currentBrand = clean(brandInput.value || '');
    renderBrandLogoBrandMenu(brands, brandInput.value || '');
    if (!keepMenuOpen) setBrandLogoMenuOpen(false);
    if (toggleBtn) toggleBtn.disabled = brands.length === 0;

    const selectedSource = normalizeBrandLogoSource(S.brandLogoSource || readBrandLogoSourceFromUi());
    if (sourceSelect) {
      sourceSelect.innerHTML = BRAND_LOGO_SOURCES
        .map((entry) => `<option value="${escapeHtml(entry.id)}">${escapeHtml(brandLogoSourceLabel(entry.id))}</option>`)
        .join('');
      sourceSelect.value = selectedSource;
    }
    if (sourceHint) sourceHint.textContent = brandLogoSourceHint(selectedSource);
    const tokenGroup = document.getElementById('dash_brand_logo_logodev_group');
    if (tokenInput) {
      tokenInput.value = clean(S.brandLogoLogoDevToken || '');
    }
    if (tokenGroup) tokenGroup.classList.toggle('d-none', selectedSource !== 'logodev');

    const state = selectedBrandLogoState();

    if (!keepUrl) {
      if (state.overrideUrl) urlInput.value = state.overrideUrl;
      else if (state.defaultUrl && !state.cleared) urlInput.value = state.defaultUrl;
      else urlInput.value = '';
    }

    const hasAnyKnown = !!state.overrideUrl || !!state.defaultUrl;
    if (saveBtn) saveBtn.disabled = !state.brand;
    if (clearBtn) {
      clearBtn.classList.toggle('d-none', !state.brand || state.cleared || !hasAnyKnown);
      clearBtn.disabled = !state.brand || state.cleared || !hasAnyKnown;
    }
    if (resetBtn) {
      const showReset = !!state.brand && !!state.defaultUrl && (state.cleared || !!state.overrideUrl);
      resetBtn.classList.toggle('d-none', !showReset);
      resetBtn.disabled = !showReset;
    }
    if (lookupBtn) {
      lookupBtn.textContent = selectedSource === 'database'
        ? (S.brandLogoLookupEnabled ? t('brand_logo_lookup_refresh_btn') : t('brand_logo_lookup_btn'))
        : t('brand_logo_fetch_btn');
    }
    if (zoomBtn) {
      zoomBtn.disabled = !state.brand || !state.effectiveUrl;
      zoomBtn.title = t('brand_logo_preview_open_title');
    }

    if (!state.brand) {
      preview.innerHTML = `<span class="text-muted">${escapeHtml(t('brand_logo_status_missing_brand'))}</span>`;
      return;
    }

    if (!state.effectiveUrl) {
      const text = state.cleared ? t('brand_logo_preview_cleared') : t('brand_logo_preview_none');
      preview.innerHTML = `<span class="text-muted">${escapeHtml(text)}</span>`;
      return;
    }

    const source = state.overrideUrl
      ? t('brand_logo_preview_override')
      : t('brand_logo_preview_default');
    preview.innerHTML = `
      <button type="button" class="dash-brand-logo-preview-open" data-brand-logo-open="1" title="${escapeHtml(t('brand_logo_preview_open_title'))}">
        ${brandLogoIconHtml(state.brand)}
        <span>
          <span class="dash-brand-logo-preview-name">${escapeHtml(state.brand)}</span>
          <span class="dash-brand-logo-preview-source d-block">${escapeHtml(source)}</span>
        </span>
      </button>
    `;
  }

  function renderGroupLogoEditor(options = {}) {
    const keepUrl = options && options.keepUrl === true;
    const keepMenuOpen = options && options.keepMenuOpen === true;
    const groupInput = document.getElementById('dash_group_logo_group');
    const urlInput = document.getElementById('dash_group_logo_url');
    const preview = document.getElementById('dash_group_logo_preview');
    const saveBtn = document.getElementById('dash_group_logo_save');
    const clearBtn = document.getElementById('dash_group_logo_clear');
    const resetBtn = document.getElementById('dash_group_logo_reset');
    const zoomBtn = document.getElementById('dash_group_logo_zoom');
    const toggleBtn = document.getElementById('dash_group_logo_group_toggle');
    if (!groupInput || !urlInput || !preview) return;

    const groups = knownGroupsForLogoEditor();
    renderGroupLogoGroupMenu(groups, groupInput.value || '');
    if (!keepMenuOpen) setGroupLogoMenuOpen(false);
    if (toggleBtn) toggleBtn.disabled = groups.length === 0;

    const state = selectedGroupLogoState();

    if (!keepUrl) {
      if (state.overrideUrl) urlInput.value = state.overrideUrl;
      else if (state.defaultUrl && !state.cleared) urlInput.value = state.defaultUrl;
      else urlInput.value = '';
    }

    const hasAnyKnown = !!state.overrideUrl || !!state.defaultUrl;
    if (saveBtn) saveBtn.disabled = !state.group;
    if (clearBtn) {
      clearBtn.classList.toggle('d-none', !state.group || state.cleared || !hasAnyKnown);
      clearBtn.disabled = !state.group || state.cleared || !hasAnyKnown;
    }
    if (resetBtn) {
      const showReset = !!state.group && !!state.defaultUrl && (state.cleared || !!state.overrideUrl);
      resetBtn.classList.toggle('d-none', !showReset);
      resetBtn.disabled = !showReset;
    }
    if (zoomBtn) {
      zoomBtn.disabled = !state.group || !state.effectiveUrl;
      zoomBtn.title = t('group_logo_preview_open_title');
    }

    if (!state.group) {
      preview.innerHTML = `<span class="text-muted">${escapeHtml(t('group_logo_status_missing_group'))}</span>`;
      return;
    }

    if (!state.effectiveUrl) {
      const text = state.cleared ? t('group_logo_preview_cleared') : t('group_logo_preview_none');
      preview.innerHTML = `<span class="text-muted">${escapeHtml(text)}</span>`;
      return;
    }

    const source = state.overrideUrl
      ? t('group_logo_preview_override')
      : t('group_logo_preview_default');
    preview.innerHTML = `
      <button type="button" class="dash-brand-logo-preview-open" data-group-logo-open="1" title="${escapeHtml(t('group_logo_preview_open_title'))}">
        ${groupLogoIconHtml(state.group)}
        <span>
          <span class="dash-brand-logo-preview-name">${escapeHtml(state.group)}</span>
          <span class="dash-brand-logo-preview-source d-block">${escapeHtml(source)}</span>
        </span>
      </button>
    `;
  }

  function enableBrandLogoLookupFromUserAction() {
    S.brandLogoLookupEnabled = true;
    S.brandLogoBannerDismissed = true;
    const rows = Array.isArray(S.lastAllRows) && S.lastAllRows.length ? S.lastAllRows : data(false);
    rebuildBrandLogoDefaultCache(rows);
    S.brandLogoKnownCount = Math.max(S.brandLogoKnownCount, collectKnownBrands(rows).length);
    saveBrandLogoSettings();
    setBrandLogoEditorStatus(t('brand_logo_lookup_done', { count: fmt(S.brandLogoDefaultCache.size, 0) }), 'success');
  }

  function renderBrandLogoBanner(rowsInput) {
    const host = document.getElementById('dash_brand_logo_banner_host');
    if (!host) return;

    const rows = Array.isArray(rowsInput) ? rowsInput : [];
    const knownBrands = collectKnownBrands(rows);
    const count = knownBrands.length;
    if (count <= 0) {
      host.innerHTML = '';
      return;
    }
    const hadKnown = num(S.brandLogoKnownCount);
    let changed = false;

    if (count > hadKnown && S.brandLogoBannerDismissed) {
      S.brandLogoBannerDismissed = false;
      changed = true;
    }
    const nextKnown = Math.max(hadKnown, count);
    if (nextKnown !== hadKnown) {
      S.brandLogoKnownCount = nextKnown;
      changed = true;
    }
    if (changed) saveBrandLogoSettings();

    if (S.brandLogoBannerDismissed) {
      host.innerHTML = '';
      return;
    }

    const bodyText = S.brandLogoLookupEnabled
      ? t('brand_logo_banner_new_brand')
      : t('brand_logo_banner_intro');
    const actionText = S.brandLogoLookupEnabled
      ? t('brand_logo_banner_refresh')
      : t('brand_logo_banner_enable');

    host.innerHTML = `
      <div class="dash-brand-logo-banner p-2">
        <div class="d-flex align-items-start justify-content-between flex-wrap">
          <div class="dash-brand-logo-banner-text pr-2">${escapeHtml(bodyText)}</div>
          <div class="btn-group btn-group-sm mt-1 mt-sm-0">
            <button id="dash_brand_logo_banner_apply" type="button" class="btn btn-outline-info">${escapeHtml(actionText)}</button>
            <button id="dash_brand_logo_banner_dismiss" type="button" class="btn btn-outline-secondary">${escapeHtml(t('brand_logo_banner_close'))}</button>
          </div>
        </div>
      </div>
    `;

    document.getElementById('dash_brand_logo_banner_apply')?.addEventListener('click', () => {
      enableBrandLogoLookupFromUserAction();
      S.brandLogoBannerDismissed = true;
      saveBrandLogoSettings();
      host.innerHTML = '';
      renderBrandLogoEditor();
      scheduleRender();
    });
    document.getElementById('dash_brand_logo_banner_dismiss')?.addEventListener('click', () => {
      S.brandLogoBannerDismissed = true;
      saveBrandLogoSettings();
      host.innerHTML = '';
    });
  }

  async function testAiSettings() {
    if (S.aiValidationInProgress) return;
    const settings = readAiSettingsForm();
    const active = activeAiProvider(settings);
    const model = aiProviderModelLabel(active.id, settings);

    if (!settings.enabled) {
      setAiSettingsStatus(t('ai_test_disabled'), 'warning');
      return;
    }
    if (!isAiProviderConfigured(settings, active.id)) {
      setAiSettingsStatus(t('ai_test_incomplete', { provider: active.def.label }), 'warning');
      setAiProviderValidationState(active.id, 'rejected', t('ai_test_incomplete', { provider: active.def.label }));
      return;
    }

    clearAiProviderValidationUi();
    setAiSettingsBusyState(true);
    setAiSettingsStatus(t('ai_test_running', { provider: active.def.label }), 'info');
    try {
      const result = await callAiText(
        settings,
        t('ai_test_prompt'),
        { maxOutputTokens: 64, allowFallback: false, forceProvider: active.id }
      );
      const short = clean(result.text).slice(0, 180) || t('ai_empty_response_short');
      const src = result.providerLabel || active.def.label;
      const modelLabel = clean(result.model || model);
      setAiSettingsStatus(t('ai_test_ok', {
        provider: src,
        model: modelLabel ? ` / ${modelLabel}` : '',
        msg: short,
      }), 'success');
      setAiProviderValidationState(active.id, 'valid', `${t('ai_provider_valid_short')}: ${src}`);
      syncAiProviderBadges(settings);
    } catch (error) {
      const message = clean(error && error.message ? error.message : String(error));
      setAiSettingsStatus(t('ai_test_fail', {
        provider: active.def.label,
        msg: message,
      }), 'danger');
      let fieldMessage = message;
      if (isAiLowCreditErrorMessage(message)) fieldMessage = t('ai_api_key_error_low_credit');
      else if (isAiAccessDeniedErrorMessage(message)) fieldMessage = t('ai_api_key_error_access_denied');
      setAiProviderValidationState(active.id, 'rejected', t('ai_provider_rejected_reason', { msg: message || t('focus_unknown_error') }));
      setAiProviderFieldError(active.id, 'apiKey', fieldMessage);
    } finally {
      setAiSettingsBusyState(false);
    }
  }

  function ensurePhotoSearchSettingsSection() {
    const overlay = document.getElementById('dash_ai_settings_overlay');
    if (!overlay) return;
    if (document.getElementById('dash_photo_search_section')) return;

    const body = overlay.querySelector('.card-body');
    if (!body) return;

    const section = document.createElement('div');
    section.id = 'dash_photo_search_section';
    section.className = 'dash-settings-section p-2 mt-3';
    section.innerHTML = `
      <div class="small font-weight-bold mb-2">${t('settings_section_photo_search')}</div>
      <div class="form-row">
        <div class="form-group col-md-8 mb-2">
          <label for="dash_photo_search_engine" class="mb-1">${t('photo_search_engine_label')}</label>
          <select id="dash_photo_search_engine" class="form-control form-control-sm">
            <option value="google">${t('photo_search_engine_google')}</option>
            <option value="duckduckgo">${t('photo_search_engine_duckduckgo')}</option>
            <option value="bing">${t('photo_search_engine_bing')}</option>
          </select>
          <div id="dash_photo_search_engine_hint" class="small text-muted mt-1"></div>
        </div>
        <div class="form-group col-md-4 mb-2 d-flex justify-content-md-end align-items-end">
          <button id="dash_photo_search_save" type="button" class="btn btn-outline-secondary btn-sm">${t('settings_save_btn')}</button>
        </div>
      </div>
      <div class="form-group mb-1">
        <div class="custom-control custom-switch">
          <input type="checkbox" class="custom-control-input" id="dash_photo_search_off_name_fallback">
          <label class="custom-control-label" for="dash_photo_search_off_name_fallback">${t('photo_search_off_name_fallback_label')}</label>
        </div>
      </div>
      <div id="dash_photo_search_status" class="small mt-2 text-muted"></div>
    `;

    const barcodeSection = document.getElementById('dash_barcode_lookup_section');
    if (barcodeSection && barcodeSection.parentNode) {
      barcodeSection.parentNode.insertBefore(section, barcodeSection);
    } else {
      body.appendChild(section);
    }
  }

  function ensureBarcodeLookupSettingsSection() {
    const overlay = document.getElementById('dash_ai_settings_overlay');
    if (!overlay) return;
    if (document.getElementById('dash_barcode_lookup_section')) return;

    const body = overlay.querySelector('.card-body');
    if (!body) return;

    const section = document.createElement('div');
    section.id = 'dash_barcode_lookup_section';
    section.className = 'dash-settings-section p-2 mt-3';
    section.innerHTML = `
      <div class="small font-weight-bold mb-2">${t('settings_section_barcode_lookup')}</div>
      <div class="form-row align-items-end">
        <div class="form-group col-md-8 mb-2">
          <label for="dash_barcode_lookup_provider" class="mb-1">${t('barcode_lookup_provider_label')}</label>
          <select id="dash_barcode_lookup_provider" class="form-control form-control-sm">
            <option value="openfoodfacts">${t('barcode_lookup_provider_openfoodfacts')}</option>
            <option value="openproductsfacts">${t('barcode_lookup_provider_openproductsfacts')}</option>
          </select>
          <div id="dash_barcode_lookup_hint" class="small text-muted mt-1"></div>
          <div id="dash_barcode_lookup_order_note" class="small text-muted mt-1"></div>
        </div>
        <div class="form-group col-md-4 mb-2 d-flex justify-content-md-end">
          <button id="dash_barcode_lookup_save" type="button" class="btn btn-outline-secondary btn-sm">${t('settings_save_btn')}</button>
        </div>
      </div>
      <div class="form-group mb-1">
        <div class="custom-control custom-switch">
          <input type="checkbox" class="custom-control-input" id="dash_barcode_lookup_enabled">
          <label class="custom-control-label" for="dash_barcode_lookup_enabled">${t('barcode_lookup_enabled_label')}</label>
        </div>
        <div class="small text-muted mt-1">${t('barcode_lookup_enabled_hint')}</div>
      </div>
      <div class="form-group mb-1">
        <div class="custom-control custom-switch">
          <input type="checkbox" class="custom-control-input" id="dash_barcode_lookup_auto_fallback">
          <label class="custom-control-label" for="dash_barcode_lookup_auto_fallback">${t('barcode_lookup_auto_fallback_label')}</label>
        </div>
        <div class="small text-muted mt-1">${t('barcode_lookup_auto_fallback_hint')}</div>
      </div>
      <div id="dash_barcode_lookup_status" class="small mt-2 text-muted"></div>
    `;

    const providersSection = document.getElementById('dash_ai_provider_forms')?.closest('.dash-settings-section');
    if (providersSection && providersSection.parentNode) {
      providersSection.parentNode.insertBefore(section, providersSection);
    } else {
      body.appendChild(section);
    }
  }

  function ensureFactsApiTestSection() {
    const overlay = document.getElementById('dash_ai_settings_overlay');
    if (!overlay) return;
    if (document.getElementById('dash_facts_api_test_section')) return;

    const body = overlay.querySelector('.card-body');
    if (!body) return;

    const section = document.createElement('div');
    section.id = 'dash_facts_api_test_section';
    section.className = 'dash-settings-section p-2 mt-3';
    section.innerHTML = `
      <div class="small font-weight-bold mb-2">${t('settings_section_facts_api_tests')}</div>
      <div class="small text-muted mb-2">${t('facts_api_test_hint')}</div>
      <div class="d-flex flex-wrap align-items-center">
        <button id="dash_facts_test_off" type="button" class="btn btn-outline-secondary btn-sm mr-2 mb-1">${t('facts_api_test_off_btn')}</button>
        <button id="dash_facts_test_opf" type="button" class="btn btn-outline-secondary btn-sm mr-2 mb-1">${t('facts_api_test_opf_btn')}</button>
        <button id="dash_facts_test_active" type="button" class="btn btn-outline-info btn-sm mb-1">${t('facts_api_test_active_btn')}</button>
      </div>
      <div id="dash_facts_api_test_status" class="small mt-2 text-muted"></div>
    `;

    const barcodeSection = document.getElementById('dash_barcode_lookup_section');
    if (barcodeSection && barcodeSection.parentNode) {
      barcodeSection.parentNode.insertBefore(section, barcodeSection.nextSibling);
    } else {
      body.appendChild(section);
    }
  }

  function ensureAddonCompatibilitySection() {
    const overlay = document.getElementById('dash_ai_settings_overlay');
    if (!overlay) return;
    if (document.getElementById('dash_addon_compat_section')) return;

    const body = overlay.querySelector('.card-body');
    if (!body) return;

    const section = document.createElement('div');
    section.id = 'dash_addon_compat_section';
    section.className = 'dash-settings-section p-2 mt-3';
    section.innerHTML = `
      <div class="small font-weight-bold mb-2">${t('settings_section_addon_compat')}</div>
      <div class="small text-muted mb-1">${t('addon_compat_desc')}</div>
      <div class="small text-muted mb-2">${t('addon_compat_scope_note')}</div>
      <div class="d-flex flex-wrap align-items-center">
        <button id="dash_addon_compat_run" type="button" class="btn btn-outline-info btn-sm mr-2 mb-1">${t('addon_compat_run_btn')}</button>
        <button id="dash_addon_compat_map" type="button" class="btn btn-outline-warning btn-sm mr-2 mb-1">${t('addon_compat_map_btn')}</button>
        <button id="dash_addon_compat_reoffer" type="button" class="btn btn-outline-secondary btn-sm mb-1">${t('addon_compat_reoffer_btn')}</button>
      </div>
      <div id="dash_addon_compat_status" class="small mt-2 text-muted"></div>
    `;

    const factsSection = document.getElementById('dash_facts_api_test_section');
    if (factsSection && factsSection.parentNode) {
      factsSection.parentNode.insertBefore(section, factsSection.nextSibling);
    } else {
      body.appendChild(section);
    }

    section.querySelector('#dash_addon_compat_run')?.addEventListener('click', async () => {
      await runAddonCompatibilitySetup({ source: 'settings' });
    });
    section.querySelector('#dash_addon_compat_map')?.addEventListener('click', async () => {
      await openAddonCompatibilityMappingAssistant();
    });
    section.querySelector('#dash_addon_compat_reoffer')?.addEventListener('click', () => {
      saveAddonCompatibilityState({
        onboardingSeen: false,
        completed: false,
        lastSummary: '',
        lastError: '',
      });
      setAddonCompatibilitySettingsStatus(t('addon_compat_status_prompt_reset'), 'info');
      renderAddonCompatibilityBanner();
      syncAddonCompatibilitySettingsSection();
      refreshAddonCompatibilityScan({ render: true, force: true });
    });

    syncAddonCompatibilitySettingsSection();
    refreshAddonCompatibilityScan({ render: true });
  }

  function ensureAddonUpdateSettingsSection() {
    const overlay = document.getElementById('dash_ai_settings_overlay');
    if (!overlay) return;
    if (document.getElementById('dash_addon_update_section')) return;

    const body = overlay.querySelector('.card-body');
    if (!body) return;

    const section = document.createElement('div');
    section.id = 'dash_addon_update_section';
    section.className = 'dash-settings-section p-2 mt-3';
    section.innerHTML = `
      <div class="small font-weight-bold mb-2">${t('settings_section_addon_update')}</div>
      <div class="small text-muted mb-2">${t('addon_update_desc')}</div>
      <div class="form-group mb-2">
        <label for="dash_addon_update_local_root" class="mb-1">${t('addon_update_local_root_label')}</label>
        <div class="input-group input-group-sm">
          <input id="dash_addon_update_local_root" type="text" class="form-control form-control-sm" placeholder="${escapeHtml(ADDON_UPDATE_DEFAULT_LOCAL_ROOT)}">
          <div class="input-group-append">
            <button id="dash_addon_update_local_root_browse" type="button" class="btn btn-outline-secondary">${t('addon_update_local_root_browse_btn')}</button>
          </div>
        </div>
        <input id="dash_addon_update_local_root_picker" type="file" class="d-none" webkitdirectory directory multiple>
        <div class="small text-muted mt-1">${t('addon_update_local_root_hint')}</div>
      </div>
      <div class="form-row align-items-end">
        <div class="form-group col-md-7 mb-2">
          <label for="dash_addon_update_repo" class="mb-1">${t('addon_update_repo_label')}</label>
          <input id="dash_addon_update_repo" type="text" class="form-control form-control-sm" placeholder="Raph563/Grocy">
          <div class="small text-muted mt-1">${t('addon_update_repo_hint')}</div>
        </div>
        <div class="form-group col-md-5 mb-2 d-flex flex-wrap justify-content-md-end align-items-end">
          <button id="dash_addon_update_check_stable" type="button" class="btn btn-outline-info btn-sm mr-2 mb-1">${t('addon_update_check_stable_btn')}</button>
          <button id="dash_addon_update_check_prerelease" type="button" class="btn btn-outline-warning btn-sm mr-2 mb-1">${t('addon_update_check_prerelease_btn')}</button>
          <button id="dash_addon_update_test_bridge" type="button" class="btn btn-outline-secondary btn-sm mr-2 mb-1">${t('addon_update_bridge_test_btn')}</button>
          <button id="dash_addon_update_run_bridge" type="button" class="btn btn-success btn-sm mr-2 mb-1">${t('addon_update_run_bridge_btn')}</button>
          <a id="dash_addon_update_open_release" href="#" target="_blank" rel="noopener noreferrer" class="btn btn-outline-secondary btn-sm d-none">${t('addon_update_open_release_btn')}</a>
        </div>
      </div>
      <div class="form-group mb-2">
        <label class="mb-1">${t('addon_update_release_list_label')}</label>
        <div id="dash_addon_update_release_choices" class="d-flex flex-wrap align-items-start"></div>
      </div>
      <div class="form-group mb-2">
        <label class="mb-1">${t('addon_update_changelog_label')}</label>
        <div id="dash_addon_update_changelog"></div>
      </div>
      <div class="form-group mb-2">
        <label for="dash_addon_update_cmd_ps" class="mb-1">${t('addon_update_cmd_ps_label')}</label>
        <div class="input-group input-group-sm">
          <input id="dash_addon_update_cmd_ps" type="text" class="form-control form-control-sm" readonly>
          <div class="input-group-append">
            <button id="dash_addon_update_copy_ps" type="button" class="btn btn-outline-secondary">${t('addon_update_copy_btn')}</button>
          </div>
        </div>
      </div>
      <div class="form-group mb-1">
        <label for="dash_addon_update_cmd_sh" class="mb-1">${t('addon_update_cmd_sh_label')}</label>
        <div class="input-group input-group-sm">
          <input id="dash_addon_update_cmd_sh" type="text" class="form-control form-control-sm" readonly>
          <div class="input-group-append">
            <button id="dash_addon_update_copy_sh" type="button" class="btn btn-outline-secondary">${t('addon_update_copy_btn')}</button>
          </div>
        </div>
      </div>
      <div class="small text-muted">${t('addon_update_cmd_hint')}</div>
      <div class="small text-muted mt-1">${t('addon_update_bridge_hint')}</div>
      <div id="dash_addon_update_versions" class="small mt-2 text-muted"></div>
      <div id="dash_addon_update_status" class="small mt-2 text-muted"></div>
    `;

    const compatSection = document.getElementById('dash_addon_compat_section');
    if (compatSection && compatSection.parentNode) {
      compatSection.parentNode.insertBefore(section, compatSection.nextSibling);
    } else {
      body.appendChild(section);
    }

    section.querySelector('#dash_addon_update_repo')?.addEventListener('change', (event) => {
      const target = event && event.target ? event.target : null;
      if (!target) return;
      const normalized = addonUpdateRepositoryText(target.value || '');
      target.value = normalized;
      const next = saveAddonUpdateState({ repository: normalized });
      syncAddonUpdateCommandFields(next);
      syncAddonUpdateReleaseLink(next);
      syncAddonUpdateVersionSummary(next);
      syncAddonUpdateSettingsSection();
    });
    section.querySelector('#dash_addon_update_local_root')?.addEventListener('change', (event) => {
      const target = event && event.target ? event.target : null;
      if (!target) return;
      const localRootPath = addonUpdateNormalizeLocalRootPath(target.value || '');
      target.value = localRootPath;
      const next = saveAddonUpdateState({
        localRootPath,
      });
      syncAddonUpdateCommandFields(next);
      syncAddonUpdateReleaseLink(next);
      syncAddonUpdateVersionSummary(next);
      syncAddonUpdateSettingsSection();
    });
    section.querySelector('#dash_addon_update_local_root_browse')?.addEventListener('click', () => {
      const picker = document.getElementById('dash_addon_update_local_root_picker');
      if (picker && typeof picker.click === 'function') picker.click();
    });
    section.querySelector('#dash_addon_update_local_root_picker')?.addEventListener('change', (event) => {
      const picker = event && event.target ? event.target : null;
      if (!picker) return;
      const files = Array.isArray(picker.files) ? picker.files : Array.from(picker.files || []);
      const first = files.length ? files[0] : null;
      let pickedPath = '';
      if (first && typeof first.path === 'string' && first.path) {
        const rel = typeof first.webkitRelativePath === 'string' ? first.webkitRelativePath : '';
        if (rel) {
          const escapedRel = rel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          pickedPath = first.path.replace(new RegExp(`[\\\\/]${escapedRel}$`), '');
        } else {
          pickedPath = first.path.replace(/[\\/][^\\/]+$/, '');
        }
      }
      if (!pickedPath) {
        setAddonUpdateSettingsStatus(t('addon_update_local_root_pick_fail'), 'warning');
        return;
      }
      const rootInput = document.getElementById('dash_addon_update_local_root');
      const normalized = addonUpdateNormalizeLocalRootPath(pickedPath);
      if (rootInput) rootInput.value = normalized;
      const next = saveAddonUpdateState({ localRootPath: normalized });
      syncAddonUpdateCommandFields(next);
      syncAddonUpdateVersionSummary(next);
      syncAddonUpdateSettingsSection();
    });

    section.querySelector('#dash_addon_update_check_stable')?.addEventListener('click', async () => {
      await runAddonUpdateVersionCheck({ includePrerelease: false });
    });
    section.querySelector('#dash_addon_update_check_prerelease')?.addEventListener('click', async () => {
      await runAddonUpdateVersionCheck({ includePrerelease: true });
    });
    section.querySelector('#dash_addon_update_test_bridge')?.addEventListener('click', async () => {
      const ok = await addonUpdateRelayHealthCheck();
      setAddonUpdateSettingsStatus(ok ? t('addon_update_bridge_status_ready') : t('addon_update_bridge_status_missing'), ok ? 'success' : 'warning');
    });
    section.querySelector('#dash_addon_update_run_bridge')?.addEventListener('click', async () => {
      await runAddonUpdateViaRelay();
    });
    section.querySelector('#dash_addon_update_copy_ps')?.addEventListener('click', async () => {
      await copyAddonUpdateCommandFromField('dash_addon_update_cmd_ps');
    });
    section.querySelector('#dash_addon_update_copy_sh')?.addEventListener('click', async () => {
      await copyAddonUpdateCommandFromField('dash_addon_update_cmd_sh');
    });
    section.querySelector('#dash_addon_update_release_choices')?.addEventListener('click', (event) => {
      const target = event && event.target;
      if (!target || typeof target.closest !== 'function') return;
      const button = target.closest('[data-addon-release-tag]');
      if (!button) return;
      const tag = clean(button.getAttribute('data-addon-release-tag') || '');
      if (!tag) return;
      event.preventDefault();
      selectAddonUpdateReleaseByTag(tag, { withStatus: true });
    });

    fillAddonUpdateSettingsForm();
  }

  function ensureDonneSettingsAboutInfoBlock() {
    const section = document.getElementById('dash_addon_update_section');
    if (!section) return;
    if (document.getElementById('dash_donne_about_info')) return;
    const block = document.createElement('div');
    block.id = 'dash_donne_about_info';
    block.className = 'small text-muted mt-3 pt-2 border-top';
    block.innerHTML = `
      <div class="font-weight-bold mb-1">${t('statnerd_about_title')}</div>
      <div>${escapeHtml(t('statnerd_about_author', { author: STATNERD_AUTHOR_NAME }))}</div>
      <div id="dash_statnerd_about_version_line">${escapeHtml(t('statnerd_about_version', { version: addonUpdateLocalVersionValue() }))}</div>
      <div class="mt-1 d-flex flex-wrap">
        <a class="mr-2" href="${escapeHtml(STATNERD_REPO_URL + '/releases')}" target="_blank" rel="noopener noreferrer">${escapeHtml(t('statnerd_about_release_link'))}</a>
        <a class="mr-2" href="${escapeHtml(STATNERD_CHANGELOG_URL)}" target="_blank" rel="noopener noreferrer">${escapeHtml(t('statnerd_about_changelog_link'))}</a>
        <a href="${escapeHtml(STATNERD_DOCS_URL)}" target="_blank" rel="noopener noreferrer">${escapeHtml(t('statnerd_about_docs_link'))}</a>
      </div>
      <div class="font-weight-bold mt-2 mb-1">${escapeHtml(t('statnerd_about_selected_changelog'))}</div>
      <pre id="dash_statnerd_about_changelog" class="dash-addon-update-changelog mb-0">${escapeHtml(t('addon_update_changelog_empty'))}</pre>
    `;
    section.appendChild(block);
    syncStatNerdAboutInfoBlock();
  }

  function syncStatNerdAboutInfoBlock(stateInput = null) {
    const state = normalizeAddonUpdateState(stateInput || addonUpdateState());
    const versionNode = document.getElementById('dash_statnerd_about_version_line');
    if (versionNode) {
      versionNode.textContent = t('statnerd_about_version', { version: addonUpdateLocalVersionValue(state) });
    }
    const changelogNode = document.getElementById('dash_statnerd_about_changelog');
    if (changelogNode) {
      const text = String(state.selectedChangelog || '').replace(/\r\n/g, '\n').trim();
      changelogNode.textContent = text || t('addon_update_changelog_empty');
    }
  }

  function donneSettingsGroupDefinitions() {
    return [
      {
        id: 'general',
        tabKey: 'settings_tabs_general',
        titleKey: 'settings_group_general',
        sectionIds: ['dash_settings_interface_section', 'dash_settings_runtime_section'],
      },
      {
        id: 'product_data',
        tabKey: 'settings_tabs_product_data',
        titleKey: 'settings_group_product_data',
        sectionIds: ['dash_photo_search_section', 'dash_barcode_lookup_section', 'dash_facts_api_test_section'],
      },
      {
        id: 'visuals',
        tabKey: 'settings_tabs_visuals',
        titleKey: 'settings_group_visuals',
        sectionIds: ['dash_settings_brand_logo_section', 'dash_settings_group_logo_section'],
      },
      {
        id: 'compat',
        tabKey: 'settings_tabs_compat',
        titleKey: 'settings_group_compat',
        sectionIds: ['dash_addon_compat_section'],
      },
      {
        id: 'providers',
        tabKey: 'settings_tabs_providers',
        titleKey: 'settings_group_providers',
        sectionIds: ['dash_settings_providers_section'],
      },
      {
        id: 'updates',
        tabKey: 'settings_tabs_update',
        titleKey: 'settings_group_update',
        sectionIds: ['dash_addon_update_section'],
      },
    ];
  }

  function setDonneSettingsActiveTab(tabId = '') {
    const active = clean(tabId || '');
    document.querySelectorAll('#dash_donne_settings_tabs [data-donne-settings-tab]').forEach((button) => {
      const id = clean(button.getAttribute('data-donne-settings-tab') || '');
      const selected = id && id === active;
      button.classList.toggle('btn-outline-info', selected);
      button.classList.toggle('btn-outline-secondary', !selected);
    });
  }

  function openDonneSettingsGroup(groupId = '', { scroll = true } = {}) {
    const target = clean(groupId || '');
    if (!target) return;
    const defs = donneSettingsGroupDefinitions();
    defs.forEach((def) => {
      const details = document.getElementById(`dash_donne_group_${def.id}`);
      if (!details) return;
      details.open = def.id === target;
    });
    setDonneSettingsActiveTab(target);
    const node = document.getElementById(`dash_donne_group_${target}`);
    if (node && scroll) {
      try {
        node.scrollIntoView({ behavior: 'smooth', block: 'start' });
      } catch (_err) {
        node.scrollIntoView();
      }
    }
  }

  function collapseDonneSettingsGroups() {
    const defs = donneSettingsGroupDefinitions();
    defs.forEach((def) => {
      const details = document.getElementById(`dash_donne_group_${def.id}`);
      if (!details) return;
      details.open = false;
    });
    setDonneSettingsActiveTab('');
  }

  function createDonneSettingsGroupNode(definitionInput = null) {
    const def = definitionInput && typeof definitionInput === 'object' ? definitionInput : null;
    if (!def || !def.id) return null;
    const details = document.createElement('details');
    details.id = `dash_donne_group_${def.id}`;
    details.className = 'dash-donne-group mb-2';
    details.open = false;
    details.innerHTML = `
      <summary class="dash-donne-group-summary">
        <span class="dash-donne-group-title">${escapeHtml(t(def.titleKey || ''))}</span>
        <span class="dash-donne-group-toggle small text-muted">
          <span class="dash-donne-group-when-open">${escapeHtml(t('settings_group_reduce'))}</span>
          <span class="dash-donne-group-when-closed">${escapeHtml(t('settings_group_expand'))}</span>
        </span>
      </summary>
      <div class="dash-donne-group-body pt-2"></div>
    `;
    const groupBody = details.querySelector('.dash-donne-group-body');
    const sectionIds = Array.isArray(def.sectionIds) ? def.sectionIds : [];
    sectionIds.forEach((sectionId) => {
      const node = document.getElementById(sectionId);
      if (!node || !groupBody) return;
      groupBody.appendChild(node);
    });
    return details;
  }

  function ensureDonneSettingsLayout() {
    const overlay = document.getElementById('dash_ai_settings_overlay');
    if (!overlay) return;
    const body = overlay.querySelector('.card-body');
    if (!body) return;

    const defs = donneSettingsGroupDefinitions();
    if (!defs.length) return;

    let tabs = document.getElementById('dash_donne_settings_tabs');
    if (!tabs) {
      tabs = document.createElement('div');
      tabs.id = 'dash_donne_settings_tabs';
      tabs.className = 'd-flex flex-wrap align-items-center mb-2';
      body.insertBefore(tabs, body.firstChild);
    }

    tabs.innerHTML = defs
      .map((def) => `<button type="button" class="btn btn-outline-secondary btn-sm mr-1 mb-1" data-donne-settings-tab="${escapeHtml(def.id)}">${escapeHtml(t(def.tabKey || ''))}</button>`)
      .join('');
    tabs.querySelectorAll('[data-donne-settings-tab]').forEach((button) => {
      button.addEventListener('click', (event) => {
        event.preventDefault();
        openDonneSettingsGroup(clean(button.getAttribute('data-donne-settings-tab') || ''), { scroll: true });
      });
    });

    let groupsHost = document.getElementById('dash_donne_settings_groups');
    const footerAnchor = body.querySelector('.dash-ai-settings-hint');
    if (!groupsHost) {
      groupsHost = document.createElement('div');
      groupsHost.id = 'dash_donne_settings_groups';
      if (footerAnchor && footerAnchor.parentNode === body) {
        body.insertBefore(groupsHost, footerAnchor);
      } else {
        body.appendChild(groupsHost);
      }
    } else if (footerAnchor && groupsHost.parentNode === body) {
      body.insertBefore(groupsHost, footerAnchor);
    }

    defs.forEach((def) => {
      const existing = document.getElementById(`dash_donne_group_${def.id}`);
      const node = existing || createDonneSettingsGroupNode(def);
      if (!node) return;
      if (!existing) {
        groupsHost.appendChild(node);
      } else {
        const groupBody = existing.querySelector('.dash-donne-group-body');
        (def.sectionIds || []).forEach((sectionId) => {
          const sectionNode = document.getElementById(sectionId);
          if (!groupBody || !sectionNode) return;
          if (sectionNode.parentNode !== groupBody) {
            groupBody.appendChild(sectionNode);
          }
        });
      }
    });

    collapseDonneSettingsGroups();
  }

  function initAiSettingsOverlay() {
    if (document.getElementById('dash_ai_settings_overlay')) return;
    const overlay = document.createElement('div');
    overlay.id = 'dash_ai_settings_overlay';
    overlay.className = 'd-none';
    overlay.innerHTML = `
      <div class="card dash-ai-settings-card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <div class="font-weight-bold">${t('ai_settings_title')}</div>
          <button id="dash_ai_close" type="button" class="btn btn-sm btn-outline-secondary">${t('ai_settings_close')}</button>
        </div>
        <div class="card-body">
          <div id="dash_settings_interface_section" class="dash-settings-section p-2">
            <div class="small font-weight-bold mb-2">${t('settings_section_interface')}</div>
            <div class="form-group mb-2 pb-1 border-bottom">
            <div class="custom-control custom-switch">
              <input type="checkbox" class="custom-control-input" id="dash_ai_enabled">
              <label class="custom-control-label" for="dash_ai_enabled">${t('ai_enable_focus')}</label>
            </div>
            </div>

            <div class="form-group mb-2">
            <label class="mb-1">${t('lang_mode_label')}</label>
            <div id="dash_ui_lang_switch" class="btn-group btn-group-sm d-flex dash-lang-switch" role="group" aria-label="${t('lang_mode_label')}">
              <button type="button" class="btn btn-outline-secondary" data-ui-lang="auto">AUTO</button>
              <button type="button" class="btn btn-outline-secondary" data-ui-lang="fr">FR</button>
              <button type="button" class="btn btn-outline-secondary" data-ui-lang="en">EN</button>
            </div>
            <input type="hidden" id="dash_ui_lang_mode_value" value="auto">
            <div id="dash_ui_lang_hint" class="small text-muted mt-1"></div>
            </div>

            <div class="form-group mb-2">
            <label for="dash_due_date_format" class="mb-1">${t('due_date_format_label')}</label>
            <select id="dash_due_date_format" class="form-control form-control-sm">
              <option value="auto">${t('due_date_format_auto')}</option>
              <option value="ymd">${t('due_date_format_ymd')}</option>
              <option value="dmy">${t('due_date_format_dmy')}</option>
              <option value="mdy">${t('due_date_format_mdy')}</option>
            </select>
            <div id="dash_due_date_format_hint" class="small text-muted mt-1">${t('due_date_format_hint')}</div>
            </div>

            <div class="form-group mb-2">
            <label class="mb-1">${t('ai_validation_mode_label')}</label>
            <div id="dash_ai_validation_switch" class="btn-group btn-group-sm d-flex dash-lang-switch dash-validation-switch" role="group" aria-label="${t('ai_validation_mode_label')}">
              <button type="button" class="btn btn-outline-secondary" data-ai-validation="single" title="${t('ai_validation_mode_single_tip')}">${t('ai_validation_mode_single')}</button>
              <button type="button" class="btn btn-outline-secondary" data-ai-validation="fallback_chain" title="${t('ai_validation_mode_fallback_tip')}">${t('ai_validation_mode_fallback')}</button>
            </div>
            <input type="hidden" id="dash_ai_validation_mode_value" value="single">
            <div id="dash_ai_validation_hint" class="small text-muted mt-1"></div>
            </div>
            <div class="d-flex justify-content-end">
              <button id="dash_ai_save_interface" type="button" class="btn btn-outline-secondary btn-sm">${t('settings_save_btn')}</button>
            </div>
          </div>

          <div id="dash_settings_runtime_section" class="dash-settings-section p-2 mt-3">
            <div class="small font-weight-bold mb-2">${t('settings_section_runtime')}</div>
            <div class="form-row">
            <div class="form-group col-md-4 mb-2">
              <label for="dash_ai_provider" class="mb-1">${t('ai_provider_active')}</label>
              <select id="dash_ai_provider" class="form-control form-control-sm"></select>
            </div>
            <div class="form-group col-md-3 mb-2">
              <label for="dash_ai_focus_mode" class="mb-1">${t('ai_cost_mode')}</label>
              <select id="dash_ai_focus_mode" class="form-control form-control-sm">
                <option value="performance">${t('ai_mode_perf')}</option>
                <option value="eco">${t('ai_mode_eco')}</option>
                <option value="cheapest">${t('ai_mode_cheapest')}</option>
              </select>
            </div>
            <div class="form-group col-md-2 mb-2">
              <label for="dash_ai_temp" class="mb-1">${t('ai_temperature')}</label>
              <input type="number" id="dash_ai_temp" class="form-control form-control-sm" min="0" max="1.2" step="0.05" value="0.25">
            </div>
            <div class="form-group col-md-3 mb-2">
              <label for="dash_ai_timeout" class="mb-1">${t('ai_timeout')}</label>
              <input type="number" id="dash_ai_timeout" class="form-control form-control-sm" min="3000" max="120000" step="1000" value="18000">
            </div>
          </div>

            <div id="dash_ai_fallback_section" class="form-row align-items-end mb-2">
            <div class="form-group col-md-4 mb-1">
              <div class="custom-control custom-switch">
                <input type="checkbox" class="custom-control-input" id="dash_ai_fallback_enabled">
                <label class="custom-control-label" for="dash_ai_fallback_enabled">${t('ai_fallback_enable')}</label>
              </div>
            </div>
            <div class="form-group col-md-8 mb-1">
              <label for="dash_ai_fallback_list" class="mb-1">${t('ai_fallback_order')}</label>
              <select id="dash_ai_fallback_list" class="form-control form-control-sm" multiple size="4"></select>
            </div>
            </div>
            <div class="d-flex justify-content-end">
              <button id="dash_ai_save_runtime" type="button" class="btn btn-outline-secondary btn-sm">${t('settings_save_btn')}</button>
            </div>
          </div>

          <div id="dash_settings_providers_section" class="dash-settings-section p-2 mt-3">
            <div class="small font-weight-bold mb-2">${t('settings_section_providers')}</div>
            <div class="small text-muted mb-2">${t('ai_provider_configs')}</div>
            <div id="dash_ai_provider_forms"></div>
            <div class="d-flex justify-content-end mt-2">
              <button id="dash_ai_save_providers" type="button" class="btn btn-outline-secondary btn-sm">${t('settings_save_btn')}</button>
            </div>
          </div>

          <div id="dash_settings_brand_logo_section" class="dash-brand-logo-settings dash-settings-section p-2 mt-3">
            <div class="d-flex justify-content-between align-items-center flex-wrap">
              <div class="small font-weight-bold">${t('settings_section_brand_logos')}</div>
              <div class="btn-group btn-group-sm mt-1 mt-sm-0">
                <button id="dash_brand_logo_lookup" type="button" class="btn btn-outline-info">${t('brand_logo_lookup_btn')}</button>
                <button id="dash_brand_logo_fetch_all" type="button" class="btn btn-outline-secondary">${t('brand_logo_fetch_all_btn')}</button>
              </div>
            </div>
            <div class="small text-muted mt-1 mb-2">${t('brand_logo_settings_hint')}</div>
            <div class="form-row">
              <div class="form-group col-md-8 mb-2">
                <label for="dash_brand_logo_source" class="mb-1">${t('brand_logo_source_label')}</label>
                <select id="dash_brand_logo_source" class="form-control form-control-sm"></select>
                <div id="dash_brand_logo_source_hint" class="small text-muted mt-1"></div>
              </div>
              <div class="form-group col-md-4 mb-2" id="dash_brand_logo_logodev_group">
                <label for="dash_brand_logo_logodev_token" class="mb-1">${t('brand_logo_logodev_token_label')}</label>
                <input id="dash_brand_logo_logodev_token" type="password" class="form-control form-control-sm" placeholder="pk_..." autocomplete="off">
              </div>
            </div>
            <div class="form-row">
              <div class="form-group col-md-5 mb-2">
                <label for="dash_brand_logo_brand" class="mb-1">${t('brand_logo_brand_label')}</label>
                <div class="dash-brand-logo-combo" id="dash_brand_logo_brand_combo">
                  <div class="input-group input-group-sm">
                    <input id="dash_brand_logo_brand" class="form-control form-control-sm" placeholder="${t('brand_logo_brand_placeholder')}" autocomplete="off">
                    <div class="input-group-append">
                      <button id="dash_brand_logo_brand_toggle" class="btn btn-outline-secondary" type="button" title="${t('brand_logo_brand_toggle')}">
                        <i class="fa-solid fa-chevron-down"></i>
                      </button>
                    </div>
                  </div>
                  <div id="dash_brand_logo_brand_menu" class="dash-brand-logo-menu d-none"></div>
                </div>
              </div>
              <div class="form-group col-md-7 mb-2">
                <label for="dash_brand_logo_url" class="mb-1">${t('brand_logo_url_label')}</label>
                <input id="dash_brand_logo_url" type="text" class="form-control form-control-sm" placeholder="https://...">
              </div>
            </div>
            <div class="d-flex flex-wrap align-items-center">
              <button id="dash_brand_logo_save" type="button" class="btn btn-primary btn-sm mr-2 mb-1">${t('brand_logo_save_btn')}</button>
              <button id="dash_brand_logo_clear" type="button" class="btn btn-outline-warning btn-sm mr-2 mb-1">${t('brand_logo_clear_btn')}</button>
              <button id="dash_brand_logo_reset" type="button" class="btn btn-outline-secondary btn-sm mb-1">${t('brand_logo_reset_btn')}</button>
            </div>
            <div id="dash_brand_logo_preview" class="dash-brand-logo-preview small p-2 mt-2 text-muted"></div>
            <div class="d-flex justify-content-end mt-1">
              <button id="dash_brand_logo_zoom" type="button" class="btn btn-outline-info btn-sm py-0 px-2">${t('brand_logo_preview_expand_btn')}</button>
            </div>
            <div id="dash_brand_logo_status" class="small mt-2 text-muted"></div>
            <div class="d-flex justify-content-end mt-2">
              <button id="dash_brand_logo_save_section" type="button" class="btn btn-outline-secondary btn-sm">${t('settings_save_btn')}</button>
            </div>
          </div>

          <div id="dash_settings_group_logo_section" class="dash-brand-logo-settings dash-settings-section p-2 mt-3">
            <div class="d-flex justify-content-between align-items-center flex-wrap">
              <div class="small font-weight-bold">${t('settings_section_group_logos')}</div>
            </div>
            <div class="small text-muted mt-1 mb-2">${t('group_logo_settings_hint')}</div>
            <div class="form-row">
              <div class="form-group col-md-5 mb-2">
                <label for="dash_group_logo_group" class="mb-1">${t('group_logo_group_label')}</label>
                <div class="dash-brand-logo-combo" id="dash_group_logo_group_combo">
                  <div class="input-group input-group-sm">
                    <input id="dash_group_logo_group" class="form-control form-control-sm" placeholder="${t('group_logo_group_placeholder')}" autocomplete="off">
                    <div class="input-group-append">
                      <button id="dash_group_logo_group_toggle" class="btn btn-outline-secondary" type="button" title="${t('group_logo_group_toggle')}">
                        <i class="fa-solid fa-chevron-down"></i>
                      </button>
                    </div>
                  </div>
                  <div id="dash_group_logo_group_menu" class="dash-brand-logo-menu d-none"></div>
                </div>
              </div>
              <div class="form-group col-md-7 mb-2">
                <label for="dash_group_logo_url" class="mb-1">${t('group_logo_url_label')}</label>
                <input id="dash_group_logo_url" type="text" class="form-control form-control-sm" placeholder="https://...">
              </div>
            </div>
            <div class="d-flex flex-wrap align-items-center">
              <button id="dash_group_logo_save" type="button" class="btn btn-primary btn-sm mr-2 mb-1">${t('group_logo_save_btn')}</button>
              <button id="dash_group_logo_clear" type="button" class="btn btn-outline-warning btn-sm mr-2 mb-1">${t('group_logo_clear_btn')}</button>
              <button id="dash_group_logo_reset" type="button" class="btn btn-outline-secondary btn-sm mb-1">${t('group_logo_reset_btn')}</button>
            </div>
            <div id="dash_group_logo_preview" class="dash-brand-logo-preview small p-2 mt-2 text-muted"></div>
            <div class="d-flex justify-content-end mt-1">
              <button id="dash_group_logo_zoom" type="button" class="btn btn-outline-info btn-sm py-0 px-2">${t('group_logo_preview_expand_btn')}</button>
            </div>
            <div id="dash_group_logo_status" class="small mt-2 text-muted"></div>
            <div class="d-flex justify-content-end mt-2">
              <button id="dash_group_logo_save_section" type="button" class="btn btn-outline-secondary btn-sm">${t('settings_save_btn')}</button>
            </div>
          </div>

          <div class="small dash-ai-settings-hint">
            ${t('ai_local_key_hint')}
          </div>
          <div id="dash_ai_status" class="small mt-2 text-muted"></div>
          <div class="d-flex justify-content-end mt-3">
            <button id="dash_ai_save" type="button" class="btn btn-primary btn-sm">${t('settings_save_all_btn')}</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    ensureBarcodeLookupSettingsSection();
    ensureFactsApiTestSection();
    ensurePhotoSearchSettingsSection();
    ensureAddonCompatibilitySection();
    ensureAddonUpdateSettingsSection();
    ensureDonneSettingsAboutInfoBlock();
    ensureDonneSettingsLayout();

    document.getElementById('dash_ai_close')?.addEventListener('click', closeAiSettingsOverlay);
    document.getElementById('dash_ai_provider')?.addEventListener('change', () => {
      syncAiProviderUiFromSelection();
      syncAiProviderBadges();
      clearAiProviderValidationUi();
      saveAiNonProviderSettingsFromForm('');
    });
    document.getElementById('dash_ai_enabled')?.addEventListener('change', () => {
      saveAiNonProviderSettingsFromForm('');
    });
    document.querySelectorAll('#dash_ui_lang_switch [data-ui-lang]').forEach((button) => {
      button.addEventListener('click', (event) => {
        event.preventDefault();
        applyUiLanguageModeInstant(button.dataset.uiLang || 'auto', { reload: false });
      });
    });
    document.getElementById('dash_due_date_format')?.addEventListener('change', () => {
      syncDueDateDisplayFormat(document.getElementById('dash_due_date_format')?.value || 'auto');
      saveAiNonProviderSettingsFromForm('');
    });
    document.querySelectorAll('#dash_ai_validation_switch [data-ai-validation]').forEach((button) => {
      button.addEventListener('click', (event) => {
        event.preventDefault();
        syncValidationModeButtons(button.dataset.aiValidation || 'single');
        syncAiProviderUiFromSelection();
        clearAiProviderValidationUi();
        saveAiNonProviderSettingsFromForm('');
      });
    });
    document.getElementById('dash_ai_save_interface')?.addEventListener('click', () => {
      saveAiNonProviderSettingsFromForm(t('settings_section_interface'));
    });
    document.getElementById('dash_ai_save_runtime')?.addEventListener('click', () => {
      saveAiNonProviderSettingsFromForm(t('settings_section_runtime'));
    });
    document.getElementById('dash_photo_search_engine')?.addEventListener('change', () => {
      syncPhotoSearchSettingsHint();
      savePhotoSearchSettingsFromForm(false);
    });
    document.getElementById('dash_photo_search_off_name_fallback')?.addEventListener('change', () => {
      savePhotoSearchSettingsFromForm(false);
    });
    document.getElementById('dash_photo_search_save')?.addEventListener('click', () => {
      savePhotoSearchSettingsFromForm(true);
    });
    document.getElementById('dash_barcode_lookup_provider')?.addEventListener('change', () => {
      syncBarcodeLookupSettingsHint();
      saveBarcodeLookupSettingsFromForm(false);
    });
    document.getElementById('dash_barcode_lookup_enabled')?.addEventListener('change', () => {
      syncBarcodeLookupSettingsHint();
      saveBarcodeLookupSettingsFromForm(false);
    });
    document.getElementById('dash_barcode_lookup_auto_fallback')?.addEventListener('change', () => {
      syncBarcodeLookupSettingsHint();
      saveBarcodeLookupSettingsFromForm(false);
    });
    document.getElementById('dash_barcode_lookup_save')?.addEventListener('click', () => {
      saveBarcodeLookupSettingsFromForm(true);
    });
    document.getElementById('dash_facts_test_off')?.addEventListener('click', () => {
      runFactsProviderApiTest('openfoodfacts');
    });
    document.getElementById('dash_facts_test_opf')?.addEventListener('click', () => {
      runFactsProviderApiTest('openproductsfacts');
    });
    document.getElementById('dash_facts_test_active')?.addEventListener('click', () => {
      runFactsActiveOrderApiTest();
    });
    document.getElementById('dash_ai_save_providers')?.addEventListener('click', () => {
      saveAiSettingsFromCurrentForm(t('settings_section_providers'));
    });
    document.getElementById('dash_ai_focus_mode')?.addEventListener('change', () => {
      const mode = aiFocusModeDef(document.getElementById('dash_ai_focus_mode')?.value || 'eco');
      const goal = mode.id === 'performance'
        ? t('ai_mode_goal_perf')
        : (mode.id === 'eco' ? t('ai_mode_goal_eco') : t('ai_mode_goal_cheapest'));
      setAiSettingsStatus(t('ai_mode_changed', { mode: mode.label, goal }), 'info');
      saveAiNonProviderSettingsFromForm('');
    });
    document.getElementById('dash_ai_temp')?.addEventListener('change', () => {
      saveAiNonProviderSettingsFromForm('');
    });
    document.getElementById('dash_ai_timeout')?.addEventListener('change', () => {
      saveAiNonProviderSettingsFromForm('');
    });
    document.getElementById('dash_ai_fallback_enabled')?.addEventListener('change', () => {
      syncAiProviderUiFromSelection();
      syncAiProviderBadges();
      clearAiProviderValidationUi();
      saveAiNonProviderSettingsFromForm('');
    });
    document.getElementById('dash_ai_fallback_list')?.addEventListener('change', () => {
      updateFallbackOrderStateFromUi();
      clearAiProviderValidationUi();
      saveAiNonProviderSettingsFromForm('');
    });
    document.getElementById('dash_ai_provider_forms')?.addEventListener('input', (event) => {
      syncAiProviderBadges();
      const target = event && event.target;
      if (!target || !target.id) return;
      AI_PROVIDER_DEFS.forEach((def) => {
        Object.keys(def.defaults || {}).forEach((fieldName) => {
          if (target.id === providerFormFieldId(def.id, fieldName)) {
            setAiProviderFieldError(def.id, fieldName, '');
            setAiProviderValidationState(def.id, 'none', '');
          }
        });
      });
    });
    document.getElementById('dash_ai_provider_forms')?.addEventListener('click', (event) => {
      const target = event && event.target;
      if (!target || typeof target.closest !== 'function') return;
      const button = target.closest('[data-ai-provider-test]');
      if (!button) return;
      const providerId = clean(button.getAttribute('data-ai-provider-test') || '');
      if (!providerId) return;
      event.preventDefault();
      testAiProvider(providerId);
    });
    document.getElementById('dash_brand_logo_brand')?.addEventListener('focus', (event) => {
      const brandInput = event?.target;
      if (brandInput && typeof brandInput.select === 'function') {
        if (clean(brandInput.value || '')) {
          brandInput.select();
          brandInput.dataset.clearOnType = '1';
        } else {
          brandInput.dataset.clearOnType = '0';
        }
      }
      setBrandLogoMenuOpen(true);
      renderBrandLogoEditor({ keepUrl: true, keepMenuOpen: true });
      renderBrandLogoBrandMenu(knownBrandsForLogoEditor(), '');
    });
    document.getElementById('dash_brand_logo_brand')?.addEventListener('input', (event) => {
      const brandInput = event?.target;
      if (brandInput && brandInput.dataset) brandInput.dataset.clearOnType = '0';
      setBrandLogoMenuOpen(true);
      renderBrandLogoEditor({ keepUrl: true, keepMenuOpen: true });
    });
    document.getElementById('dash_brand_logo_brand')?.addEventListener('keydown', (event) => {
      if (!event) return;
      const brandInput = document.getElementById('dash_brand_logo_brand');
      if (brandInput && brandInput.dataset && brandInput.dataset.clearOnType === '1' && isDirectEditKey(event.key)) {
        brandInput.value = '';
        brandInput.dataset.clearOnType = '0';
      }
      if (event.key === 'Escape') {
        event.preventDefault();
        setBrandLogoMenuOpen(false);
        return;
      }
      if (event.key !== 'Enter') return;
      const typed = clean(brandInput?.value || '');
      if (!typed) return;
      const brands = knownBrandsForLogoEditor();
      const matches = filteredBrandsForLogoEditor(brands, typed);
      if (!matches.length) return;
      event.preventDefault();
      selectBrandFromBrandLogoMenu(matches[0]);
    });
    document.getElementById('dash_brand_logo_brand_toggle')?.addEventListener('click', () => {
      const opening = !isBrandLogoMenuOpen();
      setBrandLogoMenuOpen(opening);
      renderBrandLogoEditor({ keepUrl: true, keepMenuOpen: opening });
      if (opening) renderBrandLogoBrandMenu(knownBrandsForLogoEditor(), '');
      if (opening) {
        document.getElementById('dash_brand_logo_brand')?.focus();
      }
    });
    document.getElementById('dash_brand_logo_brand_menu')?.addEventListener('click', (event) => {
      const target = event && event.target;
      if (!target || typeof target.closest !== 'function') return;
      const option = target.closest('[data-brand-option]');
      if (!option) return;
      const brand = clean(option.getAttribute('data-brand-option') || '');
      if (!brand) return;
      event.preventDefault();
      selectBrandFromBrandLogoMenu(brand);
    });
    document.getElementById('dash_brand_logo_url')?.addEventListener('input', () => {
      renderBrandLogoEditor({ keepUrl: true });
    });
    document.getElementById('dash_brand_logo_source')?.addEventListener('change', () => {
      applyBrandLogoSectionFormToState();
      renderBrandLogoEditor({ keepUrl: true, keepMenuOpen: isBrandLogoMenuOpen() });
      saveBrandLogoSectionSettings(false);
    });
    document.getElementById('dash_brand_logo_logodev_token')?.addEventListener('change', () => {
      applyBrandLogoSectionFormToState();
      saveBrandLogoSectionSettings(false);
    });
    document.getElementById('dash_brand_logo_save_section')?.addEventListener('click', () => {
      saveBrandLogoSectionSettings(true);
      renderBrandLogoEditor({ keepUrl: true, keepMenuOpen: isBrandLogoMenuOpen() });
    });
    document.getElementById('dash_brand_logo_preview')?.addEventListener('click', (event) => {
      const target = event && event.target;
      if (!target || typeof target.closest !== 'function') return;
      const openBtn = target.closest('[data-brand-logo-open]');
      if (!openBtn) return;
      event.preventDefault();
      openBrandLogoLightboxFromState();
    });
    document.getElementById('dash_brand_logo_zoom')?.addEventListener('click', () => {
      openBrandLogoLightboxFromState();
    });
    document.getElementById('dash_brand_logo_lookup')?.addEventListener('click', async () => {
      applyBrandLogoSectionFormToState();
      const source = normalizeBrandLogoSource(S.brandLogoSource || readBrandLogoSourceFromUi());
      if (source === 'database') {
        enableBrandLogoLookupFromUserAction();
        saveBrandLogoSectionSettings(false);
        renderBrandLogoEditor();
        scheduleRender();
        return;
      }

      const brand = clean(document.getElementById('dash_brand_logo_brand')?.value || '');
      if (!brand) {
        setBrandLogoEditorStatus(t('brand_logo_status_missing_brand'), 'warning');
        return;
      }

      const sourceLabel = brandLogoSourceLabel(source);
      setBrandLogoEditorStatus(t('brand_logo_fetch_running', { brand, source: sourceLabel }), 'info');
      try {
        const result = await fetchBrandLogoFromSelectedSource(brand);
        const logoUrl = clean(result && result.url ? result.url : '');
        if (!logoUrl) {
          setBrandLogoEditorStatus(t('brand_logo_fetch_none', { brand, source: sourceLabel }), 'warning');
          return;
        }

        const urlInput = document.getElementById('dash_brand_logo_url');
        if (urlInput) urlInput.value = logoUrl;
        setBrandLogoOverride(brand, logoUrl);
        saveBrandLogoSectionSettings(false);
        setBrandLogoEditorStatus(t('brand_logo_fetch_success', { brand, source: sourceLabel }), 'success');
        renderBrandLogoEditor({ keepUrl: true });
        scheduleRender();
      } catch (error) {
        const message = clean(error && error.message ? error.message : String(error || ''));
        setBrandLogoEditorStatus(t('brand_logo_fetch_fail', { source: sourceLabel, msg: message || t('focus_unknown_error') }), 'danger');
      }
    });
    document.getElementById('dash_brand_logo_fetch_all')?.addEventListener('click', async () => {
      applyBrandLogoSectionFormToState();
      const source = normalizeBrandLogoSource(S.brandLogoSource || readBrandLogoSourceFromUi());
      if (source === 'database') {
        enableBrandLogoLookupFromUserAction();
        saveBrandLogoSectionSettings(false);
        renderBrandLogoEditor();
        scheduleRender();
        return;
      }

      const brands = knownBrandsForLogoEditor();
      const targets = brands.filter((brand) => brandLogoNeedsFetch(brand));
      if (!targets.length) {
        setBrandLogoEditorStatus(t('brand_logo_fetch_all_none'), 'info');
        return;
      }

      const sourceLabel = brandLogoSourceLabel(source);
      const delay = brandLogoFetchDelayMs(source);
      const btn = document.getElementById('dash_brand_logo_fetch_all');
      if (btn) btn.disabled = true;
      let ok = 0;
      let skipped = 0;
      let failed = 0;

      for (let i = 0; i < targets.length; i += 1) {
        const brand = targets[i];
        setBrandLogoEditorStatus(t('brand_logo_fetch_all_running', {
          index: fmt(i + 1, 0),
          total: fmt(targets.length, 0),
          brand,
          source: sourceLabel,
        }), 'info');
        try {
          const result = await fetchBrandLogoFromSelectedSource(brand);
          const logoUrl = clean(result && result.url ? result.url : '');
          if (!logoUrl) {
            skipped += 1;
          } else {
            setBrandLogoOverride(brand, logoUrl);
            ok += 1;
          }
        } catch (_err) {
          failed += 1;
        }
        if (delay > 0) {
          await waitMs(delay);
        }
      }

      if (btn) btn.disabled = false;
      saveBrandLogoSectionSettings(false);
      renderBrandLogoEditor({ keepUrl: true });
      scheduleRender();
      setBrandLogoEditorStatus(t('brand_logo_fetch_all_done', {
        ok: fmt(ok, 0),
        skipped: fmt(skipped, 0),
        failed: fmt(failed, 0),
      }), failed > 0 ? 'warning' : 'success');
    });
    document.getElementById('dash_brand_logo_save')?.addEventListener('click', () => {
      const brand = clean(document.getElementById('dash_brand_logo_brand')?.value || '');
      const url = clean(document.getElementById('dash_brand_logo_url')?.value || '');
      if (!brand) {
        setBrandLogoEditorStatus(t('brand_logo_status_missing_brand'), 'warning');
        return;
      }
      if (!url) {
        setBrandLogoEditorStatus(t('brand_logo_status_missing_url'), 'warning');
        return;
      }
      setBrandLogoOverride(brand, url);
      setBrandLogoEditorStatus(t('brand_logo_status_saved', { brand }), 'success');
      renderBrandLogoEditor();
      scheduleRender();
    });
    document.getElementById('dash_brand_logo_clear')?.addEventListener('click', () => {
      const brand = clean(document.getElementById('dash_brand_logo_brand')?.value || '');
      if (!brand) {
        setBrandLogoEditorStatus(t('brand_logo_status_missing_brand'), 'warning');
        return;
      }
      clearBrandLogoForBrand(brand);
      setBrandLogoEditorStatus(t('brand_logo_status_cleared', { brand }), 'info');
      renderBrandLogoEditor();
      scheduleRender();
    });
    document.getElementById('dash_brand_logo_reset')?.addEventListener('click', () => {
      const brand = clean(document.getElementById('dash_brand_logo_brand')?.value || '');
      if (!brand) {
        setBrandLogoEditorStatus(t('brand_logo_status_missing_brand'), 'warning');
        return;
      }
      resetBrandLogoForBrand(brand);
      setBrandLogoEditorStatus(t('brand_logo_status_reset', { brand }), 'success');
      renderBrandLogoEditor();
      scheduleRender();
    });
    document.getElementById('dash_group_logo_group')?.addEventListener('focus', (event) => {
      const groupInput = event?.target;
      if (groupInput && typeof groupInput.select === 'function') {
        if (clean(groupInput.value || '')) {
          groupInput.select();
          groupInput.dataset.clearOnType = '1';
        } else {
          groupInput.dataset.clearOnType = '0';
        }
      }
      setGroupLogoMenuOpen(true);
      renderGroupLogoEditor({ keepUrl: true, keepMenuOpen: true });
      renderGroupLogoGroupMenu(knownGroupsForLogoEditor(), '');
    });
    document.getElementById('dash_group_logo_group')?.addEventListener('input', (event) => {
      const groupInput = event?.target;
      if (groupInput && groupInput.dataset) groupInput.dataset.clearOnType = '0';
      setGroupLogoMenuOpen(true);
      renderGroupLogoEditor({ keepUrl: true, keepMenuOpen: true });
    });
    document.getElementById('dash_group_logo_group')?.addEventListener('keydown', (event) => {
      if (!event) return;
      const groupInput = document.getElementById('dash_group_logo_group');
      if (groupInput && groupInput.dataset && groupInput.dataset.clearOnType === '1' && isDirectEditKey(event.key)) {
        groupInput.value = '';
        groupInput.dataset.clearOnType = '0';
      }
      if (event.key === 'Escape') {
        event.preventDefault();
        setGroupLogoMenuOpen(false);
        return;
      }
      if (event.key !== 'Enter') return;
      const typed = clean(groupInput?.value || '');
      if (!typed) return;
      const groups = knownGroupsForLogoEditor();
      const matches = filteredGroupsForLogoEditor(groups, typed);
      if (!matches.length) return;
      event.preventDefault();
      selectGroupFromGroupLogoMenu(matches[0]);
    });
    document.getElementById('dash_group_logo_group_toggle')?.addEventListener('click', () => {
      const opening = !isGroupLogoMenuOpen();
      setGroupLogoMenuOpen(opening);
      renderGroupLogoEditor({ keepUrl: true, keepMenuOpen: opening });
      if (opening) renderGroupLogoGroupMenu(knownGroupsForLogoEditor(), '');
      if (opening) {
        document.getElementById('dash_group_logo_group')?.focus();
      }
    });
    document.getElementById('dash_group_logo_group_menu')?.addEventListener('click', (event) => {
      const target = event && event.target;
      if (!target || typeof target.closest !== 'function') return;
      const option = target.closest('[data-group-option]');
      if (!option) return;
      const group = clean(option.getAttribute('data-group-option') || '');
      if (!group) return;
      event.preventDefault();
      selectGroupFromGroupLogoMenu(group);
    });
    document.getElementById('dash_group_logo_url')?.addEventListener('input', () => {
      renderGroupLogoEditor({ keepUrl: true });
    });
    document.getElementById('dash_group_logo_save_section')?.addEventListener('click', () => {
      saveGroupLogoSectionSettings(true);
      renderGroupLogoEditor({ keepUrl: true, keepMenuOpen: isGroupLogoMenuOpen() });
    });
    document.getElementById('dash_group_logo_preview')?.addEventListener('click', (event) => {
      const target = event && event.target;
      if (!target || typeof target.closest !== 'function') return;
      const openBtn = target.closest('[data-group-logo-open]');
      if (!openBtn) return;
      event.preventDefault();
      openGroupLogoLightboxFromState();
    });
    document.getElementById('dash_group_logo_zoom')?.addEventListener('click', () => {
      openGroupLogoLightboxFromState();
    });
    document.getElementById('dash_group_logo_save')?.addEventListener('click', () => {
      const group = clean(document.getElementById('dash_group_logo_group')?.value || '');
      const url = clean(document.getElementById('dash_group_logo_url')?.value || '');
      if (!group) {
        setGroupLogoEditorStatus(t('group_logo_status_missing_group'), 'warning');
        return;
      }
      if (!url) {
        setGroupLogoEditorStatus(t('group_logo_status_missing_url'), 'warning');
        return;
      }
      setGroupLogoOverride(group, url);
      setGroupLogoEditorStatus(t('group_logo_status_saved', { group }), 'success');
      renderGroupLogoEditor();
      scheduleRender();
    });
    document.getElementById('dash_group_logo_clear')?.addEventListener('click', () => {
      const group = clean(document.getElementById('dash_group_logo_group')?.value || '');
      if (!group) {
        setGroupLogoEditorStatus(t('group_logo_status_missing_group'), 'warning');
        return;
      }
      clearGroupLogoForGroup(group);
      setGroupLogoEditorStatus(t('group_logo_status_cleared', { group }), 'info');
      renderGroupLogoEditor();
      scheduleRender();
    });
    document.getElementById('dash_group_logo_reset')?.addEventListener('click', () => {
      const group = clean(document.getElementById('dash_group_logo_group')?.value || '');
      if (!group) {
        setGroupLogoEditorStatus(t('group_logo_status_missing_group'), 'warning');
        return;
      }
      resetGroupLogoForGroup(group);
      setGroupLogoEditorStatus(t('group_logo_status_reset', { group }), 'success');
      renderGroupLogoEditor();
      scheduleRender();
    });
    document.getElementById('dash_ai_save')?.addEventListener('click', async () => {
      if (S.aiValidationInProgress) return;
      applyBrandLogoSectionFormToState();
      const stored = normalizeAiSettings(aiSettings());
      const candidate = normalizeAiSettings(readAiSettingsForm());
      candidate.uiLanguageMode = normalizeUiLanguageMode(stored.uiLanguageMode);
      syncAiProviderBadges(candidate);
      if (!candidate.enabled) {
        const savedDisabled = saveAiSettings(candidate);
        saveBrandLogoSectionSettings(false);
        saveGroupLogoSectionSettings(false);
        savePhotoSearchSettingsFromForm(false);
        saveBarcodeLookupSettingsFromForm(false);
        syncAiProviderBadges(savedDisabled);
        syncAiSettingsButton();
        setAiSettingsStatus(t('ai_test_disabled'), 'warning');
        return;
      }
      setAiSettingsBusyState(true);
      setAiSettingsStatus(t('ai_save_running'), 'info');
      try {
        const validation = await validateProvidersForSave(candidate);
        if (!validation.ok) {
          setAiSettingsStatus(
            t('ai_save_validation_fail', { msg: validation.failures.join(' | ') || t('focus_unknown_error') }),
            'danger'
          );
          return;
        }

        const saved = saveAiSettings(candidate);
        saveBrandLogoSectionSettings(false);
        saveGroupLogoSectionSettings(false);
        savePhotoSearchSettingsFromForm(false);
        saveBarcodeLookupSettingsFromForm(false);
        const active = activeAiProvider(saved);
        const model = aiProviderModelLabel(active.id, saved);
        const mode = aiFocusModeDef(saved.focusMode);
        const validationProvider = validation.success ? validation.success.providerLabel : active.def.label;
        setAiSettingsStatus(`${t('ai_saved', {
          provider: active.def.label,
          model: model ? ` / ${model}` : '',
          mode: mode.label,
        })} ${t('ai_save_validation_ok', { provider: validationProvider })}`, 'success');
        syncAiProviderBadges(saved);
        syncAiSettingsButton();
        clearAiCache();
        if (S.overlayFocus) renderOverlayFocusCard(S.overlayFocus, true, 'manual');
      } finally {
        setAiSettingsBusyState(false);
      }
    });
    overlay.addEventListener('click', (event) => {
      const combo = document.getElementById('dash_brand_logo_brand_combo');
      if (combo && event && event.target && typeof event.target.closest === 'function' && !event.target.closest('#dash_brand_logo_brand_combo')) {
        setBrandLogoMenuOpen(false);
      }
      const groupCombo = document.getElementById('dash_group_logo_group_combo');
      if (groupCombo && event && event.target && typeof event.target.closest === 'function' && !event.target.closest('#dash_group_logo_group_combo')) {
        setGroupLogoMenuOpen(false);
      }
      if (event.target === overlay) closeAiSettingsOverlay();
    });
  }

  function openAiSettingsOverlay() {
    initAiSettingsOverlay();
    fillAiSettingsForm();
    syncAiSettingsButton();
    const overlay = document.getElementById('dash_ai_settings_overlay');
    if (overlay) overlay.classList.remove('d-none');
  }

  function openProduct(productId) {
    const id = num(productId);
    if (id <= 0) return;

    const existingTrigger = document.querySelector(`.productcard-trigger[data-product-id="${id}"]`);
    const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
    if (existingTrigger) {
      existingTrigger.dispatchEvent(clickEvent);
      return;
    }

    // Use delegated click handler used by Grocy for product cards.
    const ghostTrigger = document.createElement('span');
    ghostTrigger.className = 'productcard-trigger d-none';
    ghostTrigger.setAttribute('data-product-id', String(id));
    document.body.appendChild(ghostTrigger);
    ghostTrigger.dispatchEvent(clickEvent);
    setTimeout(() => {
      if (ghostTrigger.parentNode) ghostTrigger.parentNode.removeChild(ghostTrigger);
    }, 200);
  }

  function chartElementIndex(element) {
    if (!element) return -1;
    if (Number.isInteger(element.index)) return element.index;
    if (Number.isInteger(element._index)) return element._index;
    return -1;
  }

  function chartElementsFromEvent(chart, evt, preferAll = false) {
    if (!chart || !evt) return [];
    const nativeEvt = evt && evt.native ? evt.native : evt;
    const mode = preferAll ? 'index' : 'nearest';

    try {
      if (typeof chart.getElementsAtEventForMode === 'function') {
        let list = chart.getElementsAtEventForMode(nativeEvt, mode, { intersect: true }, false);
        if ((!Array.isArray(list) || !list.length) && !preferAll) {
          list = chart.getElementsAtEventForMode(nativeEvt, 'index', { intersect: true }, false);
        }
        if ((!Array.isArray(list) || !list.length) && !preferAll) {
          list = chart.getElementsAtEventForMode(nativeEvt, 'nearest', { intersect: false }, false);
        }
        if ((!Array.isArray(list) || !list.length) && !preferAll) {
          list = chart.getElementsAtEventForMode(nativeEvt, 'index', { intersect: false }, false);
        }
        if (Array.isArray(list) && list.length) return list;
      }
    } catch (_err) {}

    try {
      if (typeof chart.getElementAtEvent === 'function') {
        const one = chart.getElementAtEvent(nativeEvt);
        if (Array.isArray(one) && one.length) return one;
      }
    } catch (_err) {}

    try {
      if (typeof chart.getElementsAtEvent === 'function') {
        const many = chart.getElementsAtEvent(nativeEvt);
        if (Array.isArray(many) && many.length) return many;
      }
    } catch (_err) {}

    return [];
  }

  function cancelOverlayHoverClear() {
    if (!S.overlayHoverClearTimer) return;
    clearTimeout(S.overlayHoverClearTimer);
    S.overlayHoverClearTimer = null;
  }

  function scheduleOverlayHoverClear(delayMs = 70) {
    cancelOverlayHoverClear();
    const delay = Math.max(20, Math.floor(num(delayMs)) || 70);
    S.overlayHoverClearTimer = setTimeout(() => {
      S.overlayHoverClearTimer = null;
      clearOverlayChartActiveIndex();
      hideChartHoverPreview();
    }, delay);
  }

  function chartTitleById(chartId) {
    const canvas = document.getElementById(chartId);
    const card = canvas?.closest('.border.rounded');
    const dedicated = card?.querySelector(`.dash-chart-title-label[data-chart-title-for="${chartId}"]`);
    if (dedicated) return clean(dedicated.textContent || chartId);

    const titleNode = card?.querySelector('.font-weight-bold');
    if (!titleNode) return clean(chartId);

    const clone = titleNode.cloneNode(true);
    clone.querySelectorAll('.dash-chart-actions').forEach((n) => n.remove());
    return clean(clone.textContent || chartId);
  }

  function setOverlayDetailsExpanded(expanded) {
    const normalized = expanded !== false;
    S.overlayDetailsExpanded = normalized;
    const details = document.getElementById('dash_chart_overlay_details');
    if (details) {
      // Never hide this block: only change its vertical capacity.
      details.classList.remove('d-none');
      details.style.overflow = 'auto';
      details.style.maxHeight = normalized ? '44vh' : '16vh';
    }
    const btn = document.getElementById('dash_chart_overlay_details_toggle');
    if (btn) {
      const icon = normalized ? 'fa-chevron-up' : 'fa-chevron-down';
      const text = normalized ? t('overlay_details_collapse') : t('overlay_details_expand');
      btn.innerHTML = `<i class="fa-solid ${icon} mr-1"></i>${escapeHtml(text)}`;
      btn.setAttribute('aria-expanded', normalized ? 'true' : 'false');
    }
    scheduleUiStateSave();
  }

  function initChartOverlay() {
    if (document.getElementById('dash_chart_overlay')) return;
    const overlay = document.createElement('div');
    overlay.id = 'dash_chart_overlay';
    overlay.className = 'd-none';
    overlay.style.position = 'fixed';
    overlay.style.inset = '0';
    overlay.style.background = 'rgba(0, 0, 0, 0.65)';
    overlay.style.zIndex = '2500';
    overlay.style.padding = '1rem';
    overlay.innerHTML = `
      <div class="card h-100">
        <div class="card-header d-flex justify-content-between align-items-center">
          <div id="dash_chart_overlay_title" class="font-weight-bold">${t('overlay_chart_title')}</div>
          <button id="dash_chart_overlay_close" type="button" class="btn btn-sm btn-outline-secondary">${t('overlay_close')}</button>
        </div>
        <div class="card-body d-flex flex-column">
          <div id="dash_chart_overlay_controls" class="mb-3"></div>
          <div class="row flex-grow-1">
            <div class="col-12 col-xl-8 mb-3 mb-xl-0">
              <div class="dash-overlay-chart-wrap h-100 p-2">
                <div style="height:62vh"><canvas id="dash_chart_overlay_canvas"></canvas></div>
              </div>
            </div>
            <div class="col-12 col-xl-4 d-flex flex-column">
              <div class="dash-overlay-box p-2 mb-3">
                <div class="dash-overlay-box-title mb-2">${t('overlay_legend_title')}</div>
                <div id="dash_chart_overlay_legend" class="dash-overlay-box-body small"></div>
              </div>
              <div class="dash-overlay-box p-2 mb-3">
                <div class="dash-overlay-box-title mb-2">${t('overlay_explain_title')}</div>
                <div id="dash_chart_overlay_explain" class="dash-overlay-box-body small"></div>
              </div>
              <div class="dash-overlay-box p-2">
                <div class="dash-overlay-box-title mb-2">${t('overlay_takeaways_title')}</div>
                <div id="dash_chart_overlay_takeaways" class="dash-overlay-box-body small"></div>
              </div>
            </div>
          </div>
          <div class="dash-overlay-box p-2 mt-3">
            <div class="dash-overlay-section-head mb-2">
              <div class="dash-overlay-box-title mb-0">${t('overlay_details_title')}</div>
              <button id="dash_chart_overlay_details_toggle" type="button" class="btn btn-sm btn-outline-secondary dash-overlay-toggle-btn"></button>
            </div>
            <div id="dash_chart_overlay_details" class="small text-muted" style="max-height:16vh; overflow:auto;"></div>
          </div>
          <div id="dash_chart_overlay_fun" class="dash-overlay-box p-2 mt-3 d-none">
            <div class="dash-overlay-box-title mb-2">${t('overlay_fun_title')}</div>
            <div id="dash_chart_overlay_fun_body" class="small"></div>
          </div>
          <div id="dash_chart_overlay_focus_local" class="dash-overlay-box p-2 mt-3">
            <div class="dash-focus-header mb-2">
              <div class="dash-overlay-box-title mb-0">${t('overlay_focus_local_title')}</div>
              <div>
                <button id="dash_focus_open_product" type="button" class="btn btn-outline-secondary btn-sm py-0 px-2 d-none">${t('overlay_open_product')}</button>
              </div>
            </div>
            <div class="dash-focus-local">
              <div class="dash-focus-local-left">
                <div id="dash_chart_overlay_focus_local_logo" class="dash-focus-local-logo"></div>
                <div id="dash_chart_overlay_focus_local_products" class="dash-focus-local-products"></div>
              </div>
              <div class="dash-focus-local-main">
                <div id="dash_chart_overlay_focus_local_meta" class="small text-muted mb-1">${t('overlay_focus_hint')}</div>
                <div id="dash_chart_overlay_focus_local_stats" class="small"></div>
                <div id="dash_chart_overlay_focus_local_links" class="small mt-2"></div>
              </div>
            </div>
          </div>
          <div id="dash_chart_overlay_focus_ai" class="dash-overlay-box p-2 mt-3">
            <div class="dash-focus-header mb-2">
              <div class="dash-overlay-box-title mb-0">${t('overlay_focus_ai_title')}</div>
              <div class="dash-focus-ai-actions">
                <span id="dash_chart_overlay_focus_ai_state" class="small text-muted mr-2"></span>
                <button id="dash_focus_ai_settings" type="button" class="btn btn-outline-info btn-sm py-0 px-2 d-none">${t('overlay_focus_ai_settings_btn')}</button>
              </div>
            </div>
            <div id="dash_chart_overlay_focus_ai_body" class="small text-muted">${t('overlay_ai_waiting')}</div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    bindEntityHoverPreviewHandlers(overlay);
    document.getElementById('dash_chart_overlay_close')?.addEventListener('click', closeChartOverlay);
    document.getElementById('dash_focus_open_product')?.addEventListener('click', () => {
      const activeFocus = resolveOverlayLocalDisplayFocus(S.overlayFocus) || S.overlayFocus;
      if (activeFocus && num(activeFocus.productId) > 0) {
        openProduct(activeFocus.productId);
      }
    });
    document.getElementById('dash_focus_ai_settings')?.addEventListener('click', () => {
      openAiSettingsOverlay();
    });
    document.getElementById('dash_chart_overlay_details_toggle')?.addEventListener('click', () => {
      setOverlayDetailsExpanded(!S.overlayDetailsExpanded);
    });
    const onFocusLocalProductsClick = (event) => {
      const target = event && event.target;
      if (!target || typeof target.closest !== 'function') return;
      const baseFocus = S.overlayFocus;
      if (!baseFocus || !focusSupportsLocalProductList(baseFocus)) return;

      const expandBtn = target.closest('[data-focus-bucket-expand]');
      if (expandBtn) {
        event.preventDefault();
        updateOverlayBucketUiState(baseFocus, { expanded: true, showAll: false });
        renderOverlayFocusLocalSection(baseFocus);
        return;
      }

      const showAllBtn = target.closest('[data-focus-bucket-show-all]');
      if (showAllBtn) {
        event.preventDefault();
        updateOverlayBucketUiState(baseFocus, { expanded: true, showAll: true });
        renderOverlayFocusLocalSection(baseFocus);
        return;
      }

      const productBtn = target.closest('[data-focus-bucket-product-id]');
      if (!productBtn) return;
      event.preventDefault();
      const productId = num(productBtn.getAttribute('data-focus-bucket-product-id') || 0);
      if (productId <= 0) return;
      updateOverlayBucketUiState(baseFocus, { expanded: true, selectedProductId: productId });
      renderOverlayFocusLocalSection(baseFocus);
    };
    document.getElementById('dash_chart_overlay_focus_local_logo')?.addEventListener('click', (event) => {
      const baseFocus = S.overlayFocus;
      if (!baseFocus || !focusSupportsLocalProductList(baseFocus)) return;
      const target = event && event.target;
      if (target && typeof target.closest === 'function') {
        const hasActionButton = target.closest('[data-focus-bucket-expand], [data-focus-bucket-show-all], [data-focus-bucket-product-id]');
        if (hasActionButton) {
          onFocusLocalProductsClick(event);
          return;
        }
      }
      const ui = ensureOverlayBucketUiState(baseFocus) || { expanded: false };
      updateOverlayBucketUiState(baseFocus, { expanded: !(ui.expanded === true), showAll: false });
      renderOverlayFocusLocalSection(baseFocus);
    });
    document.getElementById('dash_chart_overlay_focus_local_products')?.addEventListener('click', (event) => {
      onFocusLocalProductsClick(event);
    });
    setOverlayDetailsExpanded(false);
    const bindOverlayIndexedInteractions = (rootId, selector, syncDetail) => {
      const root = document.getElementById(rootId);
      if (!root) return;

      root.addEventListener('mouseover', (event) => {
        const target = event.target;
        if (!target || typeof target.closest !== 'function') return;
        const item = target.closest(selector);
        if (!item) return;
        cancelOverlayHoverClear();
        const index = detailIndexFromElement(item);
        if (index >= 0) {
          setOverlayChartActiveIndex(index, syncDetail);
          const context = S.fullChartContext && Array.isArray(S.fullChartContext.contextData) ? S.fullChartContext.contextData : [];
          const chartId = clean((S.fullChartContext && S.fullChartContext.chartId) || S.fullChartId || '');
          showChartEntityHoverPreview(chartId, index, context, event, S.fullChart, item);
        }
      });
      root.addEventListener('focusin', (event) => {
        const target = event.target;
        if (!target || typeof target.closest !== 'function') return;
        const item = target.closest(selector);
        if (!item) return;
        cancelOverlayHoverClear();
        const index = detailIndexFromElement(item);
        if (index >= 0) {
          setOverlayChartActiveIndex(index, syncDetail);
          const context = S.fullChartContext && Array.isArray(S.fullChartContext.contextData) ? S.fullChartContext.contextData : [];
          const chartId = clean((S.fullChartContext && S.fullChartContext.chartId) || S.fullChartId || '');
          showChartEntityHoverPreview(chartId, index, context, null, S.fullChart, item);
        }
      });
      root.addEventListener('mouseleave', () => {
        cancelOverlayHoverClear();
        clearOverlayChartActiveIndex();
        hideChartHoverPreview();
      });
      root.addEventListener('focusout', (event) => {
        const next = event.relatedTarget;
        if (!next || !root.contains(next)) {
          cancelOverlayHoverClear();
          clearOverlayChartActiveIndex();
          hideChartHoverPreview();
        }
      });
    };

    bindOverlayIndexedInteractions('dash_chart_overlay_details', '.dash-detail-item', true);
    bindOverlayIndexedInteractions('dash_chart_overlay_legend', '.dash-overlay-legend-item', true);
    bindOverlayIndexedInteractions('dash_chart_overlay_takeaways', '.dash-overlay-insight-item[data-detail-index]', true);

    document.getElementById('dash_chart_overlay_details')?.addEventListener('click', (event) => {
      const target = event.target;
      if (!target || typeof target.closest !== 'function') return;
      const item = target.closest('.dash-detail-item');
      if (!item) return;
      const index = detailIndexFromElement(item);
      if (index >= 0) {
        setOverlayChartActiveIndex(index, true);
        handleOverlayChartClick(index);
      }
    });
    document.getElementById('dash_chart_overlay_legend')?.addEventListener('click', (event) => {
      const target = event.target;
      if (!target || typeof target.closest !== 'function') return;
      const item = target.closest('.dash-overlay-legend-item');
      if (!item) return;
      const index = detailIndexFromElement(item);
      if (index >= 0) {
        setOverlayChartActiveIndex(index, true);
        handleOverlayChartClick(index);
      }
    });
    document.getElementById('dash_chart_overlay_takeaways')?.addEventListener('click', (event) => {
      const target = event.target;
      if (!target || typeof target.closest !== 'function') return;
      const item = target.closest('.dash-overlay-insight-item[data-detail-index]');
      if (!item) return;
      const index = detailIndexFromElement(item);
      if (index >= 0) {
        setOverlayChartActiveIndex(index, true);
        handleOverlayChartClick(index);
      }
    });
    overlay.addEventListener('click', (event) => {
      const target = event.target;
      if (target && typeof target.closest === 'function' && handleFunPanelRandomizeClick(target, event)) {
        return;
      }
      if (target && typeof target.closest === 'function' && handleStockFacetElementClick(target, event)) {
        return;
      }
      if (event.target === overlay) closeChartOverlay();
    });
    overlay.addEventListener('wheel', (event) => {
      const body = overlay.querySelector('.card-body');
      if (!body) return;

      const target = event.target;
      const innerScrollable = target && typeof target.closest === 'function'
        ? target.closest('#dash_chart_overlay .dash-focus-bucket-list.is-scrollable, #dash_chart_overlay .dash-overlay-box-body, #dash_chart_overlay_details, #dash_chart_overlay .card-body')
        : null;

      if (!innerScrollable || innerScrollable === body) {
        body.scrollTop += event.deltaY;
        event.preventDefault();
        return;
      }

      const node = innerScrollable;
      const canScroll = node.scrollHeight > node.clientHeight;
      if (!canScroll) {
        body.scrollTop += event.deltaY;
        event.preventDefault();
        return;
      }

      if (node.classList && node.classList.contains('dash-focus-bucket-list')) {
        node.scrollTop += event.deltaY;
        event.preventDefault();
        return;
      }

      const atTop = node.scrollTop <= 0;
      const atBottom = (node.scrollTop + node.clientHeight) >= (node.scrollHeight - 1);
      if ((event.deltaY < 0 && atTop) || (event.deltaY > 0 && atBottom)) {
        body.scrollTop += event.deltaY;
        event.preventDefault();
      }
    }, { passive: false });
  }

  function destroyFullChart() {
    if (S.fullChart) {
      S.fullChart.destroy();
      S.fullChart = null;
    }
    S.overlayVisualBase = null;
  }

  function closeChartOverlay() {
    cancelOverlayHoverClear();
    destroyFullChart();
    hideChartHoverPreview();
    S.fullChartId = '';
    S.fullChartContext = null;
    S.overlayFocus = null;
    S.overlayActiveIndex = -1;
    S.aiRequestSeq += 1;
    S.aiRequestInFlight = false;
    resetOverlayAiBudget();
    const overlay = document.getElementById('dash_chart_overlay');
    if (overlay) overlay.classList.add('d-none');
    document.body.classList.remove('dash-overlay-open');
    const legend = document.getElementById('dash_chart_overlay_legend');
    if (legend) legend.innerHTML = '';
    const explain = document.getElementById('dash_chart_overlay_explain');
    if (explain) explain.innerHTML = '';
    const takeaways = document.getElementById('dash_chart_overlay_takeaways');
    if (takeaways) takeaways.innerHTML = '';
    const details = document.getElementById('dash_chart_overlay_details');
    if (details) details.innerHTML = '';
    const funWrap = document.getElementById('dash_chart_overlay_fun');
    const funBody = document.getElementById('dash_chart_overlay_fun_body');
    if (funBody) funBody.innerHTML = '';
    if (funWrap) funWrap.classList.add('d-none');
    const controls = document.getElementById('dash_chart_overlay_controls');
    if (controls) controls.innerHTML = '';
    setOverlayDetailActive(-1);
    setOverlayLegendActive(-1);
    setOverlayInsightActive(-1);
    setOverlayDetailsExpanded(S.overlayDetailsExpanded !== false);
    const focusMeta = document.getElementById('dash_chart_overlay_focus_local_meta');
    if (focusMeta) focusMeta.textContent = t('overlay_focus_hint');
    const focusLinks = document.getElementById('dash_chart_overlay_focus_local_links');
    if (focusLinks) focusLinks.innerHTML = '';
    const focusStats = document.getElementById('dash_chart_overlay_focus_local_stats');
    if (focusStats) focusStats.innerHTML = '';
    const focusLogo = document.getElementById('dash_chart_overlay_focus_local_logo');
    if (focusLogo) {
      focusLogo.innerHTML = '';
      focusLogo.classList.remove('is-clickable');
      focusLogo.removeAttribute('title');
    }
    const focusProducts = document.getElementById('dash_chart_overlay_focus_local_products');
    if (focusProducts) {
      focusProducts.innerHTML = '';
      focusProducts.classList.remove('is-open');
    }
    const focusAi = document.getElementById('dash_chart_overlay_focus_ai_body');
    if (focusAi) focusAi.textContent = t('overlay_ai_waiting');
    const focusAiState = document.getElementById('dash_chart_overlay_focus_ai_state');
    if (focusAiState) focusAiState.textContent = '';
    const focusAiPanel = document.getElementById('dash_chart_overlay_focus_ai');
    if (focusAiPanel) focusAiPanel.classList.remove('is-collapsed');
    const focusAiBtn = document.getElementById('dash_focus_ai_settings');
    if (focusAiBtn) focusAiBtn.classList.add('d-none');
    const focusBtn = document.getElementById('dash_focus_open_product');
    if (focusBtn) focusBtn.classList.add('d-none');
    scheduleUiStateSave();
  }

  function openChartOverlay(chartId) {
    if (!S.dashboardOpen) return;
    cancelOverlayHoverClear();
    S.fullChartId = chartId;
    S.overlayActiveIndex = -1;
    S.aiRequestInFlight = false;
    resetOverlayAiBudget();
    const overlay = document.getElementById('dash_chart_overlay');
    const title = document.getElementById('dash_chart_overlay_title');
    if (!overlay) return;
    if (title) title.textContent = `${chartTitleById(chartId)} (${t('overlay_full_suffix')})`;
    overlay.classList.remove('d-none');
    document.body.classList.add('dash-overlay-open');
    setOverlayDetailsExpanded(false);
    renderOverlayChartControls(chartId);
    renderExpandedChart(chartId);
    scheduleUiStateSave();
  }

  function setChartControlButtonState(button, active) {
    if (!button) return;
    button.classList.toggle('chart-ctl-active', active);
    button.setAttribute('aria-pressed', active ? 'true' : 'false');
  }

  function syncChartControls(chartId) {
    const pref = getChartPref(chartId);
    const roots = Array.from(
      document.querySelectorAll(`[data-chart-controls="${chartId}"], [data-chart-controls-overlay="${chartId}"]`)
    );
    if (!roots.length) return;
    const qtyState = chartId === 'g_qty' ? ensureGroupQtyState(chartId) : null;

    roots.forEach((root) => {
      const overlayRoot = root.hasAttribute('data-chart-controls-overlay');
      const overlayMode = getOverlayLimitMode(chartId);

      Array.from(root.querySelectorAll('button[data-chart-sort]')).forEach((button) => {
        setChartControlButtonState(button, button.dataset.chartSort === pref.sort);
      });
      Array.from(root.querySelectorAll('button[data-chart-limit]')).forEach((button) => {
        const active = overlayRoot
          ? ((overlayMode === 'top' && button.dataset.chartLimit !== '0') || (overlayMode !== 'top' && button.dataset.chartLimit === '0'))
          : (String(pref.limit) === String(button.dataset.chartLimit));
        setChartControlButtonState(button, active);
      });
      Array.from(root.querySelectorAll('button[data-chart-include-zero]')).forEach((button) => {
        setChartControlButtonState(button, pref.includeZero === true);
      });
      Array.from(root.querySelectorAll('button[data-chart-qty-mode]')).forEach((button) => {
        setChartControlButtonState(button, normalizeQtyMode(button.dataset.chartQtyMode || '') === pref.qtyMode);
      });
      Array.from(root.querySelectorAll('button[data-chart-type]')).forEach((button) => {
        setChartControlButtonState(button, button.dataset.chartType === pref.chartType);
      });
      syncQtyTotalBadge(root, chartId, qtyState);
    });
  }

  function refreshSingleChart(chartId) {
    const id = clean(chartId || '');
    if (!id || !CHART_IDS.includes(id)) return false;
    hideChartHoverPreview();

    if (!window.Chart || !S.lastMetrics) {
      scheduleRender();
      return false;
    }

    const filteredRows = Array.isArray(S.lastFilteredRows) ? S.lastFilteredRows : [];
    if (!filteredRows.length) {
      destroyChart(id);
      if (id === 'brand_rel') {
        const brandRelLabels = document.getElementById('brand_rel_labels');
        if (brandRelLabels) brandRelLabels.textContent = '';
      } else if (id === 'g_qty') {
        S.lastGroupQtyState = null;
        renderGroupQtyUnclassified(null);
      }
    } else {
      renderCompactChartById(id, S.lastMetrics);
    }

    syncChartControls(id);

    const overlay = document.getElementById('dash_chart_overlay');
    if (overlay && !overlay.classList.contains('d-none') && S.fullChartId === id) {
      renderExpandedChart(id);
    }

    return true;
  }

  function makeControlButton(text, title, classes = 'btn btn-outline-secondary btn-sm py-0 px-2') {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = classes;
    button.textContent = text;
    button.title = title;
    return button;
  }

  function chartTypeLabel(type) {
    const mode = clean(type);
    if (mode === 'donut') {
      return {
        label: t('ctl_type_donut'),
        title: t('ctl_type_donut_title'),
        icon: 'fa-solid fa-chart-pie',
      };
    }
    if (mode === 'scatter') {
      return {
        label: t('ctl_type_scatter'),
        title: t('ctl_type_scatter_title'),
        icon: 'fa-solid fa-braille',
      };
    }
    if (mode === 'bubble') {
      return {
        label: t('ctl_type_bubble'),
        title: t('ctl_type_bubble_title'),
        icon: 'fa-solid fa-circle-dot',
      };
    }
    return {
      label: t('ctl_type_bar'),
      title: t('ctl_type_bar_title'),
      icon: 'fa-solid fa-chart-column',
    };
  }

  function sortControlMeta(orderInput) {
    const order = clean(orderInput || '').toLowerCase() === 'asc' ? 'asc' : 'desc';
    if (order === 'asc') {
      return {
        order,
        label: t('ctl_sort_asc'),
        title: t('ctl_sort_asc_title'),
        icon: 'fa-solid fa-arrow-up-short-wide',
      };
    }
    return {
      order,
      label: t('ctl_sort_desc'),
      title: t('ctl_sort_desc_title'),
      icon: 'fa-solid fa-arrow-down-wide-short',
    };
  }

  function applySortButtonContent(button, meta, iconOnly = true) {
    if (!button || !meta) return;
    const iconClass = clean(meta.icon || '');
    const label = clean(meta.label || '');
    const iconHtml = iconClass ? `<i class="${escapeHtml(iconClass)}" aria-hidden="true"></i>` : '';
    const textHtml = iconOnly ? '' : `<span class="dash-sort-label">${escapeHtml(label)}</span>`;
    button.classList.add('dash-sort-btn');
    button.innerHTML = `${iconHtml}${textHtml}`;
    if (label) button.setAttribute('aria-label', label);
    if (meta.title) button.title = meta.title;
  }

  function applyChartTypeButtonContent(button, meta, iconOnly = false) {
    if (!button || !meta) return;
    const iconClass = clean(meta.icon || '');
    const label = clean(meta.label || '');
    const iconHtml = iconClass ? `<i class="${escapeHtml(iconClass)}" aria-hidden="true"></i>` : '';
    const textHtml = iconOnly ? '' : `<span class="dash-chart-type-label">${escapeHtml(label)}</span>`;
    button.innerHTML = `${iconHtml}${textHtml}`;
    if (label) button.setAttribute('aria-label', label);
  }

  function buildChartTypeControlGroup(chartId, iconOnly = false) {
    const typeOptions = chartTypeOptions(chartId);
    if (typeOptions.length <= 1) return null;
    const typeGroup = document.createElement('div');
    typeGroup.className = 'btn-group btn-group-sm dash-chart-type-group';
    typeOptions.forEach((type) => {
      const meta = chartTypeLabel(type);
      const btn = makeControlButton(meta.label, meta.title);
      btn.classList.add('dash-chart-type-btn');
      btn.dataset.chartType = type;
      applyChartTypeButtonContent(btn, meta, iconOnly);
      btn.addEventListener('click', () => {
        patchChartPref(chartId, { chartType: type });
        refreshSingleChart(chartId);
      });
      typeGroup.appendChild(btn);
    });
    return typeGroup;
  }

  function qtyModeControlMeta(modeInput) {
    const mode = normalizeQtyMode(modeInput);
    if (mode === 'mass') {
      return {
        label: t('ctl_qty_mass'),
        title: t('ctl_qty_mass_title'),
        icon: 'fa-solid fa-weight-scale',
      };
    }
    if (mode === 'volume') {
      return {
        label: t('ctl_qty_volume'),
        title: t('ctl_qty_volume_title'),
        icon: 'fa-solid fa-flask',
      };
    }
    return {
      label: t('ctl_qty_auto'),
      title: t('ctl_qty_auto_title'),
      icon: 'fa-solid fa-wand-magic-sparkles',
    };
  }

  function qtyModeButtonInnerHtml(meta) {
    const iconClass = clean(meta && meta.icon ? meta.icon : '');
    const label = clean(meta && meta.label ? meta.label : '');
    const iconHtml = iconClass ? `<i class="${escapeHtml(iconClass)}" aria-hidden="true"></i>` : '';
    const textHtml = label ? `<span class="dash-qty-mode-label">${escapeHtml(label)}</span>` : '';
    return `${iconHtml}${textHtml}`;
  }

  function applyQtyModeButtonContent(button, meta) {
    if (!button || !meta) return;
    button.classList.add('dash-qty-mode-btn');
    button.innerHTML = qtyModeButtonInnerHtml(meta);
    const label = clean(meta.label || '');
    if (label) button.setAttribute('aria-label', label);
    if (meta.title) button.title = meta.title;
  }

  function ensureGroupQtyState(chartId = 'g_qty') {
    if (!chartSupportsQtyMode(chartId)) return null;
    const rows = Array.isArray(S.lastFilteredRows) ? S.lastFilteredRows : [];
    if (!rows.length) return null;
    const state = buildGroupQtyState(rows, chartId);
    if (chartId === 'g_qty') {
      S.lastGroupQtyState = state;
    }
    return state;
  }

  function qtyTotalBadgeMeta(stateInput, chartId = 'g_qty') {
    const state = stateInput && typeof stateInput === 'object' ? stateInput : null;
    if (!chartSupportsQtyMode(chartId) || !state || !state.displaySpec) {
      return {
        text: t('chart_qty_total_badge_empty'),
        title: '',
      };
    }
    const totalDisplay = num(state.totalDisplay);
    const totalText = fmtQtyWithDisplay(totalDisplay, state.displaySpec);
    const modeText = qtyModeDisplayLabel(state.requestedMode, state.resolvedMode);
    return {
      text: t('chart_qty_total_badge', { total: totalText }),
      title: t('chart_qty_total_badge_title', { mode: modeText }),
    };
  }

  function syncQtyTotalBadge(root, chartId, stateInput = null) {
    if (!root || !chartSupportsQtyMode(chartId)) return;
    const badge = root.querySelector(`[data-chart-qty-total="${chartId}"]`);
    if (!badge) return;
    const state = stateInput || ensureGroupQtyState(chartId);
    const meta = qtyTotalBadgeMeta(state, chartId);
    badge.textContent = meta.text;
    if (meta.title) {
      badge.title = meta.title;
      badge.setAttribute('aria-label', meta.title);
    } else {
      badge.removeAttribute('title');
      badge.removeAttribute('aria-label');
    }
  }

  function buildQtyModeControlGroup(chartId) {
    if (!chartSupportsQtyMode(chartId)) return null;
    const wrap = document.createElement('div');
    wrap.className = 'dash-qty-mode-wrap';

    const group = document.createElement('div');
    group.className = 'btn-group btn-group-sm';
    QTY_MODE_IDS.forEach((mode) => {
      const meta = qtyModeControlMeta(mode);
      const btn = makeControlButton(meta.label, meta.title);
      btn.dataset.chartQtyMode = mode;
      applyQtyModeButtonContent(btn, meta);
      btn.addEventListener('click', () => {
        patchChartPref(chartId, { qtyMode: mode });
        refreshSingleChart(chartId);
      });
      group.appendChild(btn);
    });
    wrap.appendChild(group);

    const totalBadge = document.createElement('span');
    totalBadge.className = 'dash-qty-total-chip';
    totalBadge.dataset.chartQtyTotal = chartId;
    totalBadge.setAttribute('role', 'status');
    totalBadge.setAttribute('aria-live', 'polite');
    wrap.appendChild(totalBadge);

    syncQtyTotalBadge(wrap, chartId);
    return wrap;
  }

  function renderOverlayChartControls(chartId) {
    const root = document.getElementById('dash_chart_overlay_controls');
    if (!root || !chartId) return;
    root.innerHTML = '';

    const wrap = document.createElement('div');
    wrap.className = 'dash-overlay-controls';
    wrap.dataset.chartControlsOverlay = chartId;

    const label = document.createElement('span');
    label.className = 'dash-overlay-controls-label';
    label.textContent = t('overlay_controls_label');
    wrap.appendChild(label);

    const sortGroup = document.createElement('div');
    sortGroup.className = 'btn-group btn-group-sm';
    const sortDescMeta = sortControlMeta('desc');
    const sortDesc = makeControlButton(sortDescMeta.label, sortDescMeta.title);
    sortDesc.dataset.chartSort = 'desc';
    applySortButtonContent(sortDesc, sortDescMeta, true);
    sortDesc.addEventListener('click', () => {
      patchChartPref(chartId, { sort: 'desc' });
      refreshSingleChart(chartId);
    });
    const sortAscMeta = sortControlMeta('asc');
    const sortAsc = makeControlButton(sortAscMeta.label, sortAscMeta.title);
    sortAsc.dataset.chartSort = 'asc';
    applySortButtonContent(sortAsc, sortAscMeta, true);
    sortAsc.addEventListener('click', () => {
      patchChartPref(chartId, { sort: 'asc' });
      refreshSingleChart(chartId);
    });
    sortGroup.appendChild(sortDesc);
    sortGroup.appendChild(sortAsc);
    wrap.appendChild(sortGroup);

    if (chartSupportsLimit(chartId)) {
      const limitGroup = document.createElement('div');
      limitGroup.className = 'btn-group btn-group-sm';
      const allBtn = makeControlButton(t('ctl_limit_all'), t('ctl_limit_all_title'));
      allBtn.dataset.chartLimit = '0';
      allBtn.addEventListener('click', () => {
        setOverlayLimitMode(chartId, 'all');
        refreshSingleChart(chartId);
      });

      const topLimit = chartDefaultLimit(chartId);
      const topBtn = makeControlButton(
        t('ctl_limit_top'),
        t('ctl_limit_top_title', { limit: fmt(topLimit, 0) })
      );
      topBtn.dataset.chartLimit = String(topLimit);
      topBtn.addEventListener('click', () => {
        setOverlayLimitMode(chartId, 'top');
        refreshSingleChart(chartId);
      });

      limitGroup.appendChild(allBtn);
      limitGroup.appendChild(topBtn);
      wrap.appendChild(limitGroup);
    }

    const qtyModeGroupOverlay = buildQtyModeControlGroup(chartId);
    if (qtyModeGroupOverlay) {
      wrap.appendChild(qtyModeGroupOverlay);
    }

    if (chartSupportsIncludeZero(chartId)) {
      const zeroGroup = document.createElement('div');
      zeroGroup.className = 'btn-group btn-group-sm';
      const zeroBtn = makeControlButton(t('ctl_include_zero'), t('ctl_include_zero_title'));
      zeroBtn.dataset.chartIncludeZero = '1';
      zeroBtn.addEventListener('click', () => {
        const pref = getChartPref(chartId);
        patchChartPref(chartId, { includeZero: !pref.includeZero });
        refreshSingleChart(chartId);
      });
      zeroGroup.appendChild(zeroBtn);
      wrap.appendChild(zeroGroup);
    }

    const typeGroupOverlay = buildChartTypeControlGroup(chartId, false);
    if (typeGroupOverlay) wrap.appendChild(typeGroupOverlay);

    root.appendChild(wrap);
    syncChartControls(chartId);
  }

  function attachChartExpandButtons() {
    CHART_IDS.forEach((chartId) => {
      const canvas = document.getElementById(chartId);
      if (!canvas) return;
      const title = canvas.closest('.border.rounded')?.querySelector('.font-weight-bold');
      if (!title || title.querySelector(`[data-chart-controls="${chartId}"]`)) return;

      const label = document.createElement('span');
      label.textContent = clean(title.textContent);
      label.className = 'dash-chart-title-label';
      label.setAttribute('data-chart-title-for', chartId);
      title.textContent = '';
      title.classList.remove('d-flex', 'justify-content-between', 'align-items-center');
      title.classList.add('dash-chart-head');
      title.appendChild(label);

      const controls = document.createElement('div');
      controls.className = 'dash-chart-actions';
      controls.dataset.chartControls = chartId;
      const controlsRowTop = document.createElement('div');
      controlsRowTop.className = 'dash-chart-actions-row dash-chart-actions-row-top';
      const controlsRowBottom = document.createElement('div');
      controlsRowBottom.className = 'dash-chart-actions-row dash-chart-actions-row-bottom';

      const typeGroupInline = buildChartTypeControlGroup(chartId, true);
      if (typeGroupInline) {
        controlsRowTop.appendChild(typeGroupInline);
      }

      const sortGroup = document.createElement('div');
      sortGroup.className = 'btn-group btn-group-sm';
      const sortDescMeta = sortControlMeta('desc');
      const sortDesc = makeControlButton(sortDescMeta.label, sortDescMeta.title);
      sortDesc.dataset.chartSort = 'desc';
      applySortButtonContent(sortDesc, sortDescMeta, true);
      sortDesc.addEventListener('click', () => {
        patchChartPref(chartId, { sort: 'desc' });
        refreshSingleChart(chartId);
      });
      const sortAscMeta = sortControlMeta('asc');
      const sortAsc = makeControlButton(sortAscMeta.label, sortAscMeta.title);
      sortAsc.dataset.chartSort = 'asc';
      applySortButtonContent(sortAsc, sortAscMeta, true);
      sortAsc.addEventListener('click', () => {
        patchChartPref(chartId, { sort: 'asc' });
        refreshSingleChart(chartId);
      });
      sortGroup.appendChild(sortDesc);
      sortGroup.appendChild(sortAsc);
      controlsRowTop.appendChild(sortGroup);

      if (chartSupportsLimit(chartId)) {
        const limitGroup = document.createElement('div');
        limitGroup.className = 'btn-group btn-group-sm';
        const allBtn = makeControlButton(t('ctl_limit_all'), t('ctl_limit_all_title'));
        allBtn.dataset.chartLimit = '0';
        allBtn.addEventListener('click', () => {
          patchChartPref(chartId, { limit: 0 });
          refreshSingleChart(chartId);
        });
        const topLimit = chartDefaultLimit(chartId);
        const topBtn = makeControlButton(
          t('ctl_limit_top'),
          t('ctl_limit_top_title', { limit: fmt(topLimit, 0) })
        );
        topBtn.dataset.chartLimit = String(topLimit);
        topBtn.addEventListener('click', () => {
          patchChartPref(chartId, { limit: topLimit });
          refreshSingleChart(chartId);
        });
        limitGroup.appendChild(allBtn);
        limitGroup.appendChild(topBtn);
        controlsRowTop.appendChild(limitGroup);
      }

      const qtyModeGroup = buildQtyModeControlGroup(chartId);
      if (qtyModeGroup) {
        controlsRowBottom.appendChild(qtyModeGroup);
      }

      if (chartSupportsIncludeZero(chartId)) {
        const zeroGroup = document.createElement('div');
        zeroGroup.className = 'btn-group btn-group-sm';
        const zeroBtn = makeControlButton(t('ctl_include_zero'), t('ctl_include_zero_title'));
        zeroBtn.dataset.chartIncludeZero = '1';
        zeroBtn.addEventListener('click', () => {
          const pref = getChartPref(chartId);
          patchChartPref(chartId, { includeZero: !pref.includeZero });
          refreshSingleChart(chartId);
        });
        zeroGroup.appendChild(zeroBtn);
        controlsRowBottom.appendChild(zeroGroup);
      }

      const expandBtn = document.createElement('button');
      expandBtn.type = 'button';
      expandBtn.className = 'btn btn-outline-secondary btn-sm py-0 px-2 dash-chart-icon-btn';
      expandBtn.dataset.chartExpand = chartId;
      expandBtn.innerHTML = '<i class="fa-solid fa-expand"></i>';
      expandBtn.title = t('ctl_expand_title');
      expandBtn.addEventListener('click', () => openChartOverlay(chartId));
      controlsRowBottom.appendChild(expandBtn);

      if (controlsRowTop.childElementCount > 0) controls.appendChild(controlsRowTop);
      if (controlsRowBottom.childElementCount > 0) controls.appendChild(controlsRowBottom);

      title.appendChild(controls);
      syncChartControls(chartId);
    });
  }

  function rows(applied) {
    const d = dt();
    const fallback = Array.from(document.querySelectorAll('#stock-overview-table tbody tr'));

    if (!d) return fallback;

    const dtRows = applied
      ? d.rows({ search: 'applied' }).nodes().toArray()
      : d.rows().nodes().toArray();

    if (dtRows.length > 0) return dtRows;
    return fallback;
  }

  function rowProductId(row) {
    if (!row) return 0;
    const idMatch = (row.id || '').match(/product-(\d+)-row/);
    if (idMatch) return Number(idMatch[1]);
    const fromDataAttr = num(row.querySelector('[data-product-id]')?.getAttribute('data-product-id') || '');
    return fromDataAttr > 0 ? fromDataAttr : 0;
  }

  function sourceProductRows() {
    return Array.from(document.querySelectorAll('#stock-overview-table tbody tr[id^="product-"][id$="-row"]'));
  }

  function headersMeta() {
    const headers = Array.from(document.querySelectorAll('#stock-overview-table thead th'))
      .map((th) => norm(clean(th.textContent)));
    return headers;
  }

  function findHeaderIndex(headers, includeTokens, excludeTokens = []) {
    for (let i = 0; i < headers.length; i += 1) {
      const h = headers[i];
      const okInclude = includeTokens.some((t) => h.includes(t));
      const okExclude = excludeTokens.some((t) => h.includes(t));
      if (okInclude && !okExclude) return i;
    }
    return -1;
  }

  function getColumnMap() {
    const headers = headersMeta();
    const sig = headers.join('|');
    if (S.colMap && S.colSig === sig) return S.colMap;

    const caloriesIdxList = headers
      .map((h, i) => ((h.includes('calor') || h.includes('kcal')) ? i : -1))
      .filter((i) => i >= 0);

    const caloriesTotalIdx = findHeaderIndex(
      headers,
      ['calor', 'kcal'],
      ['per stock quantity unit', 'per quantity unit', 'par unite', 'par unite de stock']
    );

    const map = {
      productIdx: findHeaderIndex(headers, ['produit', 'product'], ['group', 'groupe', 'description', 'picture', 'parent']),
      groupIdx: findHeaderIndex(headers, ['groupe de produit', 'product group'], ['hidden']),
      hiddenGroupIdx: findHeaderIndex(headers, ['hidden product group']),
      valueIdx: findHeaderIndex(headers, ['valeur', 'value'], ['average', 'moyen', 'price', 'prix']),
      amountIdx: findHeaderIndex(headers, ['amount', 'quantite']),
      dueIdx: findHeaderIndex(headers, ['next due date', 'prochaine date', 'echeance'], []),
      hiddenStatusIdx: findHeaderIndex(headers, ['hidden status']),
      priceIdx: findHeaderIndex(headers, ['last price', 'dernier prix', 'prix'], ['average', 'moyen']),
      avgPriceIdx: findHeaderIndex(headers, ['average price', 'prix moyen']),
      brandIdx: findHeaderIndex(headers, ['marque', 'brand']),
      pictureIdx: findHeaderIndex(headers, ['photo produit', 'product picture', 'picture'], ['parent']),
      caloriesIdx: caloriesTotalIdx >= 0
        ? caloriesTotalIdx
        : (caloriesIdxList.length > 0 ? caloriesIdxList[caloriesIdxList.length - 1] : -1),
    };

    S.colMap = map;
    S.colSig = sig;
    return map;
  }

  function getName(cell) {
    if (!cell) return '';
    const c = cell.cloneNode(true);
    c.querySelectorAll('.d-none').forEach((n) => n.remove());
    return clean(c.textContent);
  }

  function cellNum(cell) {
    if (!cell) return 0;
    const s = cell.querySelector('.custom-sort');
    return num(s ? s.textContent : cell.textContent);
  }

  function getDate(cell) {
    if (!cell) return null;
    const t = clean(cell.querySelector('span[id$="-next-due-date"]')?.textContent || cell.textContent || '');
    if (!/^\d{4}-\d{2}-\d{2}$/.test(t)) return null;
    if (isNoDueSentinelDateValue(t)) return null;
    const d = normalizeDueDateValue(`${t}T00:00:00`);
    return d || null;
  }

  function extractStatusTokens(tr, cells, col) {
    let source = '';
    if (col.hiddenStatusIdx >= 0 && cells[col.hiddenStatusIdx]) {
      source = norm(cells[col.hiddenStatusIdx].textContent || '');
    }

    if (!source) {
      const hiddenTexts = Array.from(tr.querySelectorAll('td.d-none'))
        .map((td) => norm(td.textContent || ''));
      source = hiddenTexts.find((txt) => /instockx|belowminstockamount|duesoon|overdue|expired/.test(txt)) || '';
    }

    return new Set(source.split(/\s+/).filter(Boolean));
  }

  function extractGroupName(tr, cells, col) {
    let group = '';

    if (col.groupIdx >= 0 && cells[col.groupIdx]) {
      group = clean(cells[col.groupIdx].textContent || '');
    }

    if (!group && col.hiddenGroupIdx >= 0 && cells[col.hiddenGroupIdx]) {
      const hidden = clean(cells[col.hiddenGroupIdx].textContent || '');
      const m = hidden.match(/xx(.+?)xx/);
      if (m) group = clean(m[1]);
    }

    if (!group) {
      const hiddenCells = Array.from(tr.querySelectorAll('td.d-none'));
      for (const td of hiddenCells) {
        const txt = td.textContent || '';
        const matches = Array.from(txt.matchAll(/xx([^x]+)xx/g));
        for (const m of matches) {
          const candidate = clean(m[1]);
          const n = norm(candidate);
          if (S.groupOptionsByNorm.has(n)) {
            group = S.groupOptionsByNorm.get(n);
            break;
          }
        }
        if (group) break;
      }
    }

    return group || defaultNoGroupLabel();
  }

  function extractUnitFromDom(tr, cells, col, productId) {
    const unitSelectors = [
      `#product-${productId}-qu-name`,
      `#product-${productId}-stock-qu-name`,
      `[data-product-id="${productId}"][data-qu-name]`,
      `[data-product-id="${productId}"][data-stock-unit-name]`,
    ];

    for (const selector of unitSelectors) {
      const value = cleanUnitLabel(
        tr.querySelector(selector)?.getAttribute('data-qu-name')
        || tr.querySelector(selector)?.getAttribute('data-stock-unit-name')
        || tr.querySelector(selector)?.textContent
        || ''
      );
      if (value) return value;
    }

    const amountCell = col.amountIdx >= 0 ? cells[col.amountIdx] : null;
    if (amountCell) {
      const value = unitFromFreeText(amountCell.textContent || '');
      if (value) return value;
    }

    const amountAggNode = tr.querySelector(`#product-${productId}-amount-aggregated`);
    if (amountAggNode && amountAggNode.parentElement) {
      const value = unitFromFreeText(amountAggNode.parentElement.textContent || '');
      if (value) return value;
    }

    const amountNode = tr.querySelector(`#product-${productId}-amount`);
    if (amountNode && amountNode.parentElement) {
      const value = unitFromFreeText(amountNode.parentElement.textContent || '');
      if (value) return value;
    }

    return '';
  }

  function extractUnitIdFromDom(tr, productId) {
    const idSelectors = [
      `#product-${productId}-qu-id`,
      `#product-${productId}-stock-qu-id`,
      `[data-product-id="${productId}"][data-qu-id]`,
      `[data-product-id="${productId}"][data-stock-qu-id]`,
      `[data-product-id="${productId}"][data-stock-quantity-unit-id]`,
    ];
    for (const selector of idSelectors) {
      const node = tr.querySelector(selector);
      if (!node) continue;
      const value = num(
        node.getAttribute('data-stock-quantity-unit-id')
        || node.getAttribute('data-stock-qu-id')
        || node.getAttribute('data-qu-id')
        || node.textContent
        || ''
      );
      if (value > 0) return value;
    }
    return 0;
  }

  function toAbsoluteUrl(url) {
    const text = clean(url || '');
    if (!text) return '';
    try {
      return new URL(text, window.location.origin).toString();
    } catch (_err) {
      return text;
    }
  }

  function extractPictureUrlFromDom(tr, cells, col) {
    let img = null;
    if (col.pictureIdx >= 0 && cells[col.pictureIdx]) {
      img = cells[col.pictureIdx].querySelector('img[src]');
    }
    if (!img) {
      img = tr.querySelector('img[src*="/api/files/productpictures/"]');
    }
    if (!img) return '';
    return toAbsoluteUrl(img.getAttribute('src') || '');
  }

  function parseRow(tr, idx, col) {
    const c = tr?.cells;
    if (!c || c.length < 3) return null;
    const m = (tr.id || '').match(/product-(\d+)-row/);
    const fallbackId = idx + 1;
    const dataProductId = num(tr.querySelector('[data-product-id]')?.getAttribute('data-product-id') || '');
    const productId = m ? Number(m[1]) : (dataProductId > 0 ? dataProductId : fallbackId);

    const explicitNameCell = tr.querySelector(`td.productcard-trigger[data-product-id="${productId}"]`);
    const fallbackNameCell = tr.querySelector('td.productcard-trigger') || (col.productIdx >= 0 ? c[col.productIdx] : c[1]);
    const name = getName(explicitNameCell || fallbackNameCell);

    const valueNode = tr.querySelector(`#product-${productId}-value`);
    const amountAggNode = tr.querySelector(`#product-${productId}-amount-aggregated`);
    const amountNode = tr.querySelector(`#product-${productId}-amount`);
    const dueNode = tr.querySelector(`#product-${productId}-next-due-date`);

    let brand = '';
    if (col.brandIdx >= 0 && c[col.brandIdx]) {
      brand = clean(c[col.brandIdx].textContent || '');
    }
    if (!brand) brand = defaultNoBrandLabel();

    let price = 0;
    if (col.priceIdx >= 0 && c[col.priceIdx]) {
      price = cellNum(c[col.priceIdx]);
    } else if (col.avgPriceIdx >= 0 && c[col.avgPriceIdx]) {
      price = cellNum(c[col.avgPriceIdx]);
    }

    const amount = amountAggNode
      ? num(amountAggNode.textContent)
      : (amountNode ? num(amountNode.textContent) : (col.amountIdx >= 0 ? cellNum(c[col.amountIdx]) : 0));
    const value = valueNode
      ? num(valueNode.textContent)
      : (col.valueIdx >= 0 ? cellNum(c[col.valueIdx]) : 0);
    const due = dueNode ? getDate(dueNode) : (col.dueIdx >= 0 ? getDate(c[col.dueIdx]) : null);
    const calories = col.caloriesIdx >= 0 ? cellNum(c[col.caloriesIdx]) : 0;

    let avgPrice = col.avgPriceIdx >= 0 ? cellNum(c[col.avgPriceIdx]) : 0;
    if (avgPrice <= 0 && amount > 0 && value > 0) avgPrice = value / amount;
    if (price <= 0 && avgPrice > 0) price = avgPrice;

    const status = extractStatusTokens(tr, c, col);
    const stockUnitName = extractUnitFromDom(tr, c, col, productId);
    const stockUnitId = extractUnitIdFromDom(tr, productId);
    const pictureUrl = extractPictureUrlFromDom(tr, c, col);

    return {
      id: productId,
      name,
      group: extractGroupName(tr, c, col),
      brand,
      pictureUrl,
      stockUnitName,
      stockUnitId,
      isParent: false,
      amount,
      value,
      due,
      calories,
      price,
      avgPrice,
      below: status.has('belowminstockamount'),
      soon: status.has('duesoon'),
      overdue: status.has('overdue'),
      expired: status.has('expired'),
    };
  }

  function data(applied) {
    const col = getColumnMap();

    const allSourceRows = sourceProductRows();
    const allParsedRows = allSourceRows.map((r, i) => parseRow(r, i, col)).filter(Boolean);

    let domRows = allParsedRows;
    if (applied) {
      const d = dt();
      if (d) {
        const appliedIds = new Set(
          d.rows({ search: 'applied' })
            .nodes()
            .toArray()
            .map((r) => rowProductId(r))
            .filter((id) => id > 0)
        );
        if (appliedIds.size > 0) {
          domRows = allParsedRows.filter((row) => appliedIds.has(row.id));
        }
      }
    }

    if (!S.apiLoaded || (S.apiStockByProductId.size === 0 && S.apiBrandByProductId.size === 0)) {
      return domRows;
    }

    const mergedRows = domRows.map((row) => {
      const api = S.apiStockByProductId.get(row.id);
      const parentFlag = S.apiParentModeByProductId.get(num(row.id));
      if (!api) {
        const brandOnly = S.apiBrandByProductId.get(row.id);
        const next = brandOnly ? { ...row, brand: brandOnly } : { ...row };
        next.isParent = parentFlag === true || boolish(row && row.isParent);
        return next;
      }

      const brand = S.apiBrandByProductId.get(row.id) || row.brand;
      const mergedGroup = (api.group && !isNoGroupLabel(api.group)) ? api.group : row.group;
      return {
        ...row,
        name: api.name || row.name,
        group: mergedGroup || defaultNoGroupLabel(),
        brand,
        pictureUrl: clean(row.pictureUrl || ''),
        stockUnitName: cleanUnitLabel(api.stockUnitName || row.stockUnitName || ''),
        stockUnitId: api.stockUnitId > 0 ? api.stockUnitId : row.stockUnitId,
        isParent: parentFlag === true || boolish(api.isParent) || boolish(row.isParent),
        amount: api.amount > 0 ? api.amount : row.amount,
        value: api.value > 0 ? api.value : row.value,
        calories: api.calories > 0 ? api.calories : row.calories,
        price: api.price > 0 ? api.price : row.price,
        avgPrice: api.avgPrice > 0 ? api.avgPrice : row.avgPrice,
        due: api.due || row.due,
        below: api.below || row.below,
        soon: api.soon || row.soon,
        overdue: api.overdue || row.overdue,
        expired: api.expired || row.expired,
      };
    });

    const includeApiOnly = !applied || filtersAtGlobalDefault();
    if (!includeApiOnly || S.apiStockByProductId.size === 0) {
      return mergedRows;
    }

    const seen = new Set(mergedRows.map((row) => row.id));
    S.apiStockByProductId.forEach((api, productId) => {
      if (seen.has(productId)) return;
      mergedRows.push({
        id: productId,
        name: api.name || `${t('default_product')} ${productId}`,
        group: api.group || defaultNoGroupLabel(),
        brand: S.apiBrandByProductId.get(productId) || defaultNoBrandLabel(),
        pictureUrl: '',
        stockUnitName: cleanUnitLabel(api.stockUnitName || ''),
        stockUnitId: api.stockUnitId > 0 ? api.stockUnitId : 0,
        isParent: boolish(api.isParent) || S.apiParentModeByProductId.get(productId) === true,
        amount: api.amount || 0,
        value: api.value || 0,
        due: api.due || null,
        calories: api.calories || 0,
        price: api.price || api.avgPrice || 0,
        avgPrice: api.avgPrice || api.price || 0,
        below: !!api.below,
        soon: !!api.soon,
        overdue: !!api.overdue,
        expired: !!api.expired,
      });
    });

    return mergedRows;
  }

  function collectKnownBrands(rowsInput) {
    const rows = Array.isArray(rowsInput) ? rowsInput : [];
    const seen = new Set();
    const names = [];
    rows.forEach((row) => {
      const brand = clean(row && row.brand ? row.brand : '');
      const key = brandKey(brand);
      if (!brand || !key || isNoBrandLabel(brand) || seen.has(key)) return;
      seen.add(key);
      names.push(brand);
    });
    names.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
    return names;
  }

  function collectKnownGroups(rowsInput) {
    const rows = Array.isArray(rowsInput) ? rowsInput : [];
    const seen = new Set();
    const names = [];
    rows.forEach((row) => {
      const group = clean(row && row.group ? row.group : '');
      const key = groupKey(group);
      if (!group || !key || isNoGroupLabel(group) || seen.has(key)) return;
      seen.add(key);
      names.push(group);
    });
    names.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
    return names;
  }

  function rebuildBrandLogoDefaultCache(rowsInput = null) {
    if (!S.brandLogoLookupEnabled) {
      S.brandLogoDefaultCache = new Map();
      S.brandLogoDefaultCacheBuilt = false;
      S.brandLogoDefaultCacheSignature = '';
      return S.brandLogoDefaultCache;
    }

    const rows = Array.isArray(rowsInput) ? rowsInput : (Array.isArray(S.lastAllRows) ? S.lastAllRows : []);
    const signature = rows
      .map((row) => `${num(row && row.id)}|${brandKey(row && row.brand)}|${clean(row && row.pictureUrl)}`)
      .join(';');

    if (S.brandLogoDefaultCacheBuilt && signature === S.brandLogoDefaultCacheSignature) {
      return S.brandLogoDefaultCache;
    }

    const map = new Map();
    rows.forEach((row) => {
      const brand = clean(row && row.brand ? row.brand : '');
      if (!brand || isNoBrandLabel(brand)) return;
      const key = brandKey(brand);
      if (!key || map.has(key)) return;
      const pictureUrl = clean(row && row.pictureUrl ? row.pictureUrl : '');
      if (!pictureUrl) return;
      map.set(key, pictureUrl);
    });

    S.brandLogoDefaultCache = map;
    S.brandLogoDefaultCacheBuilt = true;
    S.brandLogoDefaultCacheSignature = signature;
    return map;
  }

  function rebuildGroupLogoDefaultCache(rowsInput = null) {
    const rows = Array.isArray(rowsInput) ? rowsInput : (Array.isArray(S.lastAllRows) ? S.lastAllRows : []);
    const signature = rows
      .map((row) => `${num(row && row.id)}|${groupKey(row && row.group)}|${clean(row && row.pictureUrl)}`)
      .join(';');

    if (S.groupLogoDefaultCacheBuilt && signature === S.groupLogoDefaultCacheSignature) {
      return S.groupLogoDefaultCache;
    }

    const map = new Map();
    rows.forEach((row) => {
      const group = clean(row && row.group ? row.group : '');
      if (!group || isNoGroupLabel(group)) return;
      const key = groupKey(group);
      if (!key || map.has(key)) return;
      const pictureUrl = clean(row && row.pictureUrl ? row.pictureUrl : '');
      if (!pictureUrl) return;
      map.set(key, pictureUrl);
    });

    S.groupLogoDefaultCache = map;
    S.groupLogoDefaultCacheBuilt = true;
    S.groupLogoDefaultCacheSignature = signature;
    return map;
  }

  function brandLogoDefaultUrl(brandName) {
    const key = brandKey(brandName);
    if (!key) return '';
    return clean(S.brandLogoDefaultCache.get(key) || '');
  }

  function brandLogoOverrideUrl(brandName) {
    const key = brandKey(brandName);
    if (!key) return '';
    const entry = S.brandLogoOverrides.get(key);
    return clean(entry && entry.url ? entry.url : '');
  }

  function brandLogoEffectiveUrl(brandName) {
    const key = brandKey(brandName);
    if (!key) return '';
    if (S.brandLogoCleared.has(key)) return '';
    const override = brandLogoOverrideUrl(brandName);
    if (override) return override;
    return clean(brandLogoDefaultUrl(brandName));
  }

  function brandLogoIconHtml(brandName, extraClass = '') {
    const url = brandLogoEffectiveUrl(brandName);
    if (!url) return '';
    const cls = clean(extraClass || '');
    const classAttr = cls ? `dash-brand-logo-inline ${cls}` : 'dash-brand-logo-inline';
    return `<span class="${escapeHtml(classAttr)}" aria-hidden="true"><img src="${escapeHtml(url)}" alt=""></span>`;
  }

  function groupLogoDefaultUrl(groupName) {
    const key = groupKey(groupName);
    if (!key) return '';
    return clean(S.groupLogoDefaultCache.get(key) || '');
  }

  function groupLogoOverrideUrl(groupName) {
    const key = groupKey(groupName);
    if (!key) return '';
    const entry = S.groupLogoOverrides.get(key);
    return clean(entry && entry.url ? entry.url : '');
  }

  function groupLogoEffectiveUrl(groupName) {
    const key = groupKey(groupName);
    if (!key) return '';
    if (S.groupLogoCleared.has(key)) return '';
    const override = groupLogoOverrideUrl(groupName);
    if (override) return override;
    return clean(groupLogoDefaultUrl(groupName));
  }

  function groupLogoIconHtml(groupName, extraClass = '') {
    const url = groupLogoEffectiveUrl(groupName);
    if (!url) return '';
    const cls = clean(extraClass || '');
    const classAttr = cls ? `dash-brand-logo-inline ${cls}` : 'dash-brand-logo-inline';
    return `<span class="${escapeHtml(classAttr)}" aria-hidden="true"><img src="${escapeHtml(url)}" alt=""></span>`;
  }

  function setGroupLogoOverride(groupName, logoUrl) {
    const group = clean(groupName || '');
    const key = groupKey(group);
    const url = clean(logoUrl || '');
    if (!group || !key || !url) return false;
    S.groupLogoOverrides.set(key, { group, url });
    S.groupLogoCleared.delete(key);
    saveBrandLogoSettings();
    return true;
  }

  function clearGroupLogoForGroup(groupName) {
    const group = clean(groupName || '');
    const key = groupKey(group);
    if (!key) return false;
    S.groupLogoOverrides.delete(key);
    S.groupLogoCleared.add(key);
    saveBrandLogoSettings();
    return true;
  }

  function resetGroupLogoForGroup(groupName) {
    const group = clean(groupName || '');
    const key = groupKey(group);
    if (!key) return false;
    S.groupLogoOverrides.delete(key);
    S.groupLogoCleared.delete(key);
    saveBrandLogoSettings();
    return true;
  }

  function setBrandLogoOverride(brandName, logoUrl) {
    const brand = clean(brandName || '');
    const key = brandKey(brand);
    const url = clean(logoUrl || '');
    if (!brand || !key || !url) return false;
    S.brandLogoOverrides.set(key, { brand, url });
    S.brandLogoCleared.delete(key);
    saveBrandLogoSettings();
    return true;
  }

  function clearBrandLogoForBrand(brandName) {
    const brand = clean(brandName || '');
    const key = brandKey(brand);
    if (!key) return false;
    S.brandLogoOverrides.delete(key);
    S.brandLogoCleared.add(key);
    saveBrandLogoSettings();
    return true;
  }

  function resetBrandLogoForBrand(brandName) {
    const brand = clean(brandName || '');
    const key = brandKey(brand);
    if (!key) return false;
    S.brandLogoOverrides.delete(key);
    S.brandLogoCleared.delete(key);
    saveBrandLogoSettings();
    return true;
  }

  function aggregate(list) {
    const M = {
      n: list.length,
      value: 0,
      cal: 0,
      priceSum: 0,
      priceN: 0,
      alert: 0,
      below: 0,
      soon: 0,
      overdue: 0,
      expired: 0,
      byGroupValue: new Map(),
      byGroupQty: new Map(),
      byGroupCal: new Map(),
      byBrand: new Map(),
      top: [],
      points: [],
      due: { late: 0, d3: 0, d7: 0, d30: 0, later: 0, none: 0 },
    };

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    list.forEach((r) => {
      const value = num(r && r.value);
      const calories = num(r && r.calories);
      const price = num(r && r.price);
      const amount = num(r && r.amount);
      const below = !!(r && r.below);
      const soon = !!(r && r.soon);
      const overdue = !!(r && r.overdue);
      const expired = !!(r && r.expired);

      M.value += value;
      M.cal += calories;
      if (price > 0) { M.priceSum += price; M.priceN += 1; }

      if (below) M.below += 1;
      if (soon) M.soon += 1;
      if (overdue) M.overdue += 1;
      if (expired) M.expired += 1;
      if (below || soon || overdue || expired) M.alert += 1;

      add(M.byGroupValue, r && r.group, value);
      add(M.byGroupQty, r && r.group, amount);
      add(M.byGroupCal, r && r.group, calories);

      const brandName = clean((r && r.brand) || '');
      if (brandName && !isNoBrandLabel(brandName)) {
        if (!M.byBrand.has(brandName)) M.byBrand.set(brandName, { value: 0, pSum: 0, pN: 0, n: 0 });
        const b = M.byBrand.get(brandName);
        b.value += value;
        b.n += 1;
        if (price > 0) { b.pSum += price; b.pN += 1; }
      }

      M.top.push({ id: num(r && r.id), name: clean(r && r.name), value, stockUnitName: cleanUnitLabel((r && r.stockUnitName) || '') });
      if (price > 0 && value > 0) {
        M.points.push({
          id: num(r && r.id),
          x: price,
          y: value,
          name: clean(r && r.name),
          group: clean((r && r.group) || ''),
          stockUnitName: cleanUnitLabel((r && r.stockUnitName) || ''),
        });
      }

      if (!r || !r.due) M.due.none += 1;
      else {
        const diff = Math.floor((r.due.getTime() - today.getTime()) / 86400000);
        if (diff < 0) M.due.late += 1;
        else if (diff <= 3) M.due.d3 += 1;
        else if (diff <= 7) M.due.d7 += 1;
        else if (diff <= 30) M.due.d30 += 1;
        else M.due.later += 1;
      }
    });

    M.priceAvg = M.priceN ? M.priceSum / M.priceN : 0;
    M.top.sort((a, b) => b.value - a.value);
    M.brand = Array.from(M.byBrand.entries()).map(([name, b]) => ({
      name,
      avg: b.pN ? b.pSum / b.pN : 0,
      value: b.value,
      n: b.n,
      pN: b.pN,
    }));

    return M;
  }

  function sortPairs(entries, chartId = '') {
    const pref = getChartPref(chartId);
    const out = [...entries];
    out.sort((a, b) => {
      if (pref.sort === 'asc') return a[1] - b[1];
      return b[1] - a[1];
    });
    return out;
  }

  function applyPairLimit(entries, defaultLimit = 10, others = false, forceAll = false, chartId = '') {
    const pref = getChartPref(chartId);
    let filtered = entries.filter((x) => Number.isFinite(x[1]) && (pref.includeZero || x[1] > 0));
    if (!filtered.length) return [[t('no_data'), 0]];
    filtered = sortPairs(filtered, chartId);

    const configuredLimit = pref.limit >= 0 ? pref.limit : defaultLimit;
    const limit = forceAll ? 0 : configuredLimit;
    if (!limit || filtered.length <= limit) return filtered;

    const keep = filtered.slice(0, limit);
    if (others && pref.sort !== 'asc') {
      const rest = filtered.slice(limit).reduce((sum, row) => sum + row[1], 0);
      if (rest > 0) keep.push([t('others_label'), rest]);
    }
    return keep;
  }

  function mapPairs(map) {
    return Array.from(map.entries()).map(([k, v]) => [k, Number(v) || 0]);
  }

  function topEntries(map, limit = 10, others = true) {
    const entries = mapPairs(map);
    return applyPairLimit(entries, limit, others, false, '');
  }

  function destroyChart(id) {
    if (S.charts[id]) {
      S.charts[id].destroy();
      delete S.charts[id];
    }
  }

  function clearCharts() {
    CHART_IDS.forEach(destroyChart);
    S.lastGroupQtyState = null;
    const qtyHost = document.getElementById('g_qty_unclassified');
    if (qtyHost) qtyHost.innerHTML = '';
    const calFun = document.getElementById('g_cal_fun_note');
    if (calFun) calFun.textContent = '';
    hideChartHoverPreview();
  }

  function draw(id, cfg) {
    if (!window.Chart) return;
    const c = document.getElementById(id);
    if (!c) return;
    destroyChart(id);
    S.charts[id] = new window.Chart(c.getContext('2d'), cfg);
    if (!c.dataset.hoverPreviewBound) {
      c.addEventListener('mouseleave', hideChartHoverPreview);
      c.dataset.hoverPreviewBound = '1';
    }
  }

  function aiTextFromUnknown(payload) {
    if (typeof payload === 'string') return payload.replace(/\r\n/g, '\n').trim();
    if (Array.isArray(payload)) {
      return payload
        .map((item) => aiTextFromUnknown(item))
        .filter(Boolean)
        .join('\n')
        .trim();
    }
    if (!payload || typeof payload !== 'object') return '';
    if (typeof payload.text === 'string') return aiTextFromUnknown(payload.text);
    if (typeof payload.output_text === 'string') return aiTextFromUnknown(payload.output_text);
    if (typeof payload.content === 'string') return aiTextFromUnknown(payload.content);
    if (Array.isArray(payload.parts)) return aiTextFromUnknown(payload.parts);
    if (Array.isArray(payload.content)) return aiTextFromUnknown(payload.content);
    return '';
  }

  function extractGeminiText(payload) {
    if (!payload || typeof payload !== 'object') return '';
    const candidates = Array.isArray(payload.candidates) ? payload.candidates : [];
    for (const candidate of candidates) {
      if (!candidate || typeof candidate !== 'object') continue;
      const text = aiTextFromUnknown(candidate.content);
      if (text) return text;
    }
    const promptFeedback = payload.promptFeedback;
    if (promptFeedback && clean(promptFeedback.blockReason)) {
      return langText(
        `Réponse bloquée (${clean(promptFeedback.blockReason)}).`,
        `Blocked response (${clean(promptFeedback.blockReason)}).`
      );
    }
    return '';
  }

  function extractOpenAiText(payload) {
    if (!payload || typeof payload !== 'object') return '';
    const choices = Array.isArray(payload.choices) ? payload.choices : [];
    for (const choice of choices) {
      if (!choice || typeof choice !== 'object') continue;
      const fromMessage = aiTextFromUnknown(choice.message && choice.message.content);
      if (fromMessage) return fromMessage;
      const fromDelta = aiTextFromUnknown(choice.delta && choice.delta.content);
      if (fromDelta) return fromDelta;
      const fromText = aiTextFromUnknown(choice.text);
      if (fromText) return fromText;
    }
    return aiTextFromUnknown(payload.output_text || payload.text || '');
  }

  function extractAnthropicText(payload) {
    if (!payload || typeof payload !== 'object') return '';
    const content = Array.isArray(payload.content) ? payload.content : [];
    for (const item of content) {
      if (!item || typeof item !== 'object') continue;
      if (clean(item.type) === 'text') {
        const text = aiTextFromUnknown(item.text);
        if (text) return text;
      }
    }
    return aiTextFromUnknown(payload.completion || payload.text || '');
  }

  function extractCohereText(payload) {
    if (!payload || typeof payload !== 'object') return '';
    const textFromMessage = aiTextFromUnknown(payload.message && payload.message.content);
    if (textFromMessage) return textFromMessage;
    const textFromGenerations = Array.isArray(payload.generations)
      ? payload.generations.map((g) => aiTextFromUnknown(g && g.text)).filter(Boolean).join('\n').trim()
      : '';
    if (textFromGenerations) return textFromGenerations;
    return aiTextFromUnknown(payload.text || '');
  }

  function extractOllamaText(payload) {
    if (!payload || typeof payload !== 'object') return '';
    const response = aiTextFromUnknown(payload.response);
    if (response) return response;
    return aiTextFromUnknown(payload.message && payload.message.content);
  }

  function stripTrailingSlash(url) {
    return clean(url).replace(/\/+$/, '');
  }

  function aiErrorMessageFromPayload(payload, responseText, status) {
    if (!payload || typeof payload !== 'object') {
      return clean(responseText || `HTTP ${status}`) || `HTTP ${status}`;
    }
    const errorPart = payload.error;
    if (errorPart && typeof errorPart === 'object' && clean(errorPart.message)) {
      return clean(errorPart.message);
    }
    return clean(payload.message || payload.detail || responseText || `HTTP ${status}`) || `HTTP ${status}`;
  }

  async function fetchJsonWithTimeout(url, initOptions = {}, timeoutMs = 18000) {
    const timeout = clamp(num(timeoutMs), 3000, 120000);
    const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
    const timer = controller
      ? setTimeout(() => {
        try { controller.abort(); } catch (_err) {}
      }, timeout)
      : null;

    try {
      const response = await fetch(url, {
        ...initOptions,
        signal: controller ? controller.signal : undefined,
      });
      const responseText = await response.text();
      let payload = {};
      try {
        payload = responseText ? JSON.parse(responseText) : {};
      } catch (_err) {
        payload = {};
      }

      if (!response.ok) {
        const msg = aiErrorMessageFromPayload(payload, responseText, response.status);
        throw new Error(msg);
      }

      return payload;
    } catch (error) {
      if (error && error.name === 'AbortError') {
        throw new Error(langText(
          `Timeout après ${fmt(timeout / 1000, 1)} secondes`,
          `Timeout after ${fmt(timeout / 1000, 1)} seconds`
        ));
      }
      throw error;
    } finally {
      if (timer) clearTimeout(timer);
    }
  }

  function parseExtraHeaders(rawHeaders) {
    const text = String(rawHeaders || '').trim();
    if (!text) return {};
    let parsed = null;
    try {
      parsed = JSON.parse(text);
    } catch (_err) {
      throw new Error(langText(
        'JSON invalide pour "En-têtes JSON".',
        'Invalid JSON for "JSON headers".'
      ));
    }
    if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
      throw new Error(langText(
        '"En-têtes JSON" doit être un objet JSON.',
        '"JSON headers" must be a JSON object.'
      ));
    }
    const out = {};
    Object.entries(parsed).forEach(([k, v]) => {
      const key = clean(k);
      if (!key) return;
      out[key] = String(v);
    });
    return out;
  }

  function aiRuntimeFromOptions(settingsInput, options = {}) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const temperature = clamp(num(
      Object.prototype.hasOwnProperty.call(options, 'temperature')
        ? options.temperature
        : settings.temperature
    ), 0, 1.2);
    const maxOutputTokens = Math.max(64, Math.floor(num(options.maxOutputTokens || 480) || 480));
    const timeoutMs = clamp(num(
      Object.prototype.hasOwnProperty.call(options, 'timeoutMs')
        ? options.timeoutMs
        : settings.timeoutMs
    ), 3000, 120000);
    return { temperature, maxOutputTokens, timeoutMs };
  }

  async function callGeminiProvider(providerCfg, prompt, runtime) {
    const apiKey = clean(providerCfg.apiKey);
    const model = clean(providerCfg.model || 'gemini-2.0-flash') || 'gemini-2.0-flash';
    if (!apiKey) throw new Error(langText('Clé API Gemini manquante.', 'Missing Gemini API key.'));

    const payload = {
      contents: [{
        role: 'user',
        parts: [{ text: String(prompt || '') }],
      }],
      generationConfig: {
        temperature: runtime.temperature,
        maxOutputTokens: runtime.maxOutputTokens,
      },
    };

    const urls = [
      `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`,
      `https://generativelanguage.googleapis.com/v1/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`,
    ];

    let lastError = null;
    for (const url of urls) {
      try {
        const responseJson = await fetchJsonWithTimeout(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        }, runtime.timeoutMs);
        const text = extractGeminiText(responseJson);
        if (text) return text;
        lastError = new Error(langText('Réponse Gemini vide.', 'Empty Gemini response.'));
      } catch (error) {
        lastError = error;
      }
    }

    throw lastError || new Error(langText('Échec appel Gemini.', 'Gemini call failed.'));
  }

  async function callOpenAiCompatibleProvider(providerId, providerCfg, prompt, runtime) {
    const apiKey = clean(providerCfg.apiKey);
    const model = clean(providerCfg.model || '');
    const baseUrlRaw = clean(providerCfg.baseUrl || '');
    if (!model) throw new Error(langText('Modèle manquant.', 'Missing model.'));
    if (!baseUrlRaw) throw new Error(langText('URL de base manquante.', 'Missing base URL.'));

    const def = aiProviderDef(providerId);
    const required = Array.isArray(def.required) ? def.required : [];
    if (required.includes('apiKey') && !apiKey) {
      throw new Error(langText('Clé API manquante.', 'Missing API key.'));
    }

    const normalizedBaseUrl = stripTrailingSlash(baseUrlRaw);
    const endpoint = /\/chat\/completions$/i.test(normalizedBaseUrl)
      ? normalizedBaseUrl
      : `${normalizedBaseUrl}/chat/completions`;

    const headers = { 'Content-Type': 'application/json' };
    if (apiKey) headers.Authorization = `Bearer ${apiKey}`;

    if (providerId === 'openai') {
      const org = clean(providerCfg.organization || '');
      const project = clean(providerCfg.project || '');
      if (org) headers['OpenAI-Organization'] = org;
      if (project) headers['OpenAI-Project'] = project;
    }
    if (providerId === 'openrouter') {
      const siteUrl = clean(providerCfg.siteUrl || '');
      const appName = clean(providerCfg.appName || '');
      if (siteUrl) headers['HTTP-Referer'] = siteUrl;
      if (appName) headers['X-Title'] = appName;
    }
    if (providerId === 'custom_openai') {
      Object.assign(headers, parseExtraHeaders(providerCfg.extraHeaders));
    }

    const payload = {
      model,
      messages: [{ role: 'user', content: String(prompt || '') }],
      temperature: runtime.temperature,
      max_tokens: runtime.maxOutputTokens,
      stream: false,
    };

    const responseJson = await fetchJsonWithTimeout(endpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
    }, runtime.timeoutMs);

    const text = extractOpenAiText(responseJson);
    if (text) return text;
    throw new Error(langText('Réponse fournisseur vide.', 'Empty provider response.'));
  }

  async function callAzureOpenAiProvider(providerCfg, prompt, runtime) {
    const apiKey = clean(providerCfg.apiKey);
    const deployment = clean(providerCfg.deployment || '');
    const apiVersion = clean(providerCfg.apiVersion || '2024-10-21') || '2024-10-21';
    const resource = clean(providerCfg.resource || '');
    const baseUrl = clean(providerCfg.baseUrl || '');

    if (!apiKey) throw new Error(langText('Clé API Azure manquante.', 'Missing Azure API key.'));
    if (!deployment) throw new Error(langText('Déploiement Azure manquant.', 'Missing Azure deployment.'));
    if (!baseUrl && !resource) throw new Error(langText('Ressource Azure ou URL de base requise.', 'Azure resource or base URL required.'));

    const root = baseUrl
      ? stripTrailingSlash(baseUrl)
      : `https://${resource}.openai.azure.com`;
    const endpoint = `${root}/openai/deployments/${encodeURIComponent(deployment)}/chat/completions?api-version=${encodeURIComponent(apiVersion)}`;

    const payload = {
      messages: [{ role: 'user', content: String(prompt || '') }],
      temperature: runtime.temperature,
      max_tokens: runtime.maxOutputTokens,
      stream: false,
    };

    const responseJson = await fetchJsonWithTimeout(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'api-key': apiKey,
      },
      body: JSON.stringify(payload),
    }, runtime.timeoutMs);

    const text = extractOpenAiText(responseJson);
    if (text) return text;
    throw new Error(langText('Réponse Azure OpenAI vide.', 'Empty Azure OpenAI response.'));
  }

  async function callAnthropicProvider(providerCfg, prompt, runtime) {
    const apiKey = clean(providerCfg.apiKey);
    const model = clean(providerCfg.model || '');
    const baseUrlRaw = clean(providerCfg.baseUrl || 'https://api.anthropic.com/v1');
    if (!apiKey) throw new Error(langText('Clé API Anthropic manquante.', 'Missing Anthropic API key.'));
    if (!model) throw new Error(langText('Modèle Anthropic manquant.', 'Missing Anthropic model.'));
    if (!baseUrlRaw) throw new Error(langText('URL de base Anthropic manquante.', 'Missing Anthropic base URL.'));

    const root = stripTrailingSlash(baseUrlRaw);
    const endpoint = /\/messages$/i.test(root) ? root : `${root}/messages`;

    const payload = {
      model,
      max_tokens: runtime.maxOutputTokens,
      temperature: runtime.temperature,
      messages: [{ role: 'user', content: String(prompt || '') }],
    };

    const responseJson = await fetchJsonWithTimeout(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify(payload),
    }, runtime.timeoutMs);

    const text = extractAnthropicText(responseJson);
    if (text) return text;
    throw new Error(langText('Réponse Anthropic vide.', 'Empty Anthropic response.'));
  }

  async function callCohereProvider(providerCfg, prompt, runtime) {
    const apiKey = clean(providerCfg.apiKey);
    const model = clean(providerCfg.model || '');
    const baseUrlRaw = clean(providerCfg.baseUrl || 'https://api.cohere.com/v2');
    if (!apiKey) throw new Error(langText('Clé API Cohere manquante.', 'Missing Cohere API key.'));
    if (!model) throw new Error(langText('Modèle Cohere manquant.', 'Missing Cohere model.'));
    if (!baseUrlRaw) throw new Error(langText('URL de base Cohere manquante.', 'Missing Cohere base URL.'));

    const root = stripTrailingSlash(baseUrlRaw);
    const endpoint = /\/chat$/i.test(root) ? root : `${root}/chat`;
    const payload = {
      model,
      messages: [{ role: 'user', content: String(prompt || '') }],
      temperature: runtime.temperature,
      max_tokens: runtime.maxOutputTokens,
    };

    const responseJson = await fetchJsonWithTimeout(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify(payload),
    }, runtime.timeoutMs);

    const text = extractCohereText(responseJson);
    if (text) return text;
    throw new Error(langText('Réponse Cohere vide.', 'Empty Cohere response.'));
  }

  async function callOllamaProvider(providerCfg, prompt, runtime) {
    const model = clean(providerCfg.model || '');
    const baseUrlRaw = clean(providerCfg.baseUrl || 'http://localhost:11434');
    const apiKey = clean(providerCfg.apiKey || '');
    if (!model) throw new Error(langText('Modèle Ollama manquant.', 'Missing Ollama model.'));
    if (!baseUrlRaw) throw new Error(langText('URL de base Ollama manquante.', 'Missing Ollama base URL.'));

    const endpoint = `${stripTrailingSlash(baseUrlRaw)}/api/generate`;
    const headers = { 'Content-Type': 'application/json' };
    if (apiKey) headers.Authorization = `Bearer ${apiKey}`;

    const keepAlive = clean(providerCfg.keepAlive || '');
    const payload = {
      model,
      prompt: String(prompt || ''),
      stream: false,
      options: {
        temperature: runtime.temperature,
        num_predict: runtime.maxOutputTokens,
      },
    };
    if (keepAlive) payload.keep_alive = keepAlive;

    const responseJson = await fetchJsonWithTimeout(endpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
    }, runtime.timeoutMs);

    const text = extractOllamaText(responseJson);
    if (text) return text;
    throw new Error(langText('Réponse Ollama vide.', 'Empty Ollama response.'));
  }

  function resolveAiProviderOrder(settingsInput, options = {}) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const forced = clean(options.forceProvider || '');
    const first = normalizeProviderId(forced || settings.activeProvider);
    const ordered = [];
    const push = (id) => {
      const normalized = normalizeProviderId(id);
      if (!normalized) return;
      if (!ordered.includes(normalized)) ordered.push(normalized);
    };

    push(first);
    if (options.allowFallback !== false && settings.useFallback) {
      (settings.fallbackProviders || []).forEach(push);
    }

    return ordered;
  }

  async function callAiProviderText(providerId, settingsInput, prompt, runtime) {
    const id = normalizeProviderId(providerId);
    const def = aiProviderDef(id);
    const providerCfg = aiProviderSettings(settingsInput, id);

    if (def.kind === 'gemini') {
      return callGeminiProvider(providerCfg, prompt, runtime);
    }
    if (def.kind === 'azure_openai') {
      return callAzureOpenAiProvider(providerCfg, prompt, runtime);
    }
    if (def.kind === 'anthropic') {
      return callAnthropicProvider(providerCfg, prompt, runtime);
    }
    if (def.kind === 'cohere') {
      return callCohereProvider(providerCfg, prompt, runtime);
    }
    if (def.kind === 'ollama') {
      return callOllamaProvider(providerCfg, prompt, runtime);
    }
    return callOpenAiCompatibleProvider(id, providerCfg, prompt, runtime);
  }

  async function callAiText(settingsInput, prompt, options = {}) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    const runtime = aiRuntimeFromOptions(settings, options);
    const order = resolveAiProviderOrder(settings, options);
    const failures = [];

    for (const providerId of order) {
      const label = aiProviderLabel(providerId);
      if (!isAiProviderConfigured(settings, providerId)) {
        failures.push(langText(`${label}: configuration incomplète`, `${label}: incomplete configuration`));
        continue;
      }

      try {
        const text = await callAiProviderText(providerId, settings, prompt, runtime);
        const normalizedText = aiTextFromUnknown(text);
        if (!normalizedText) {
          failures.push(langText(`${label}: réponse vide`, `${label}: empty response`));
          continue;
        }

        return {
          text: normalizedText,
          providerId,
          providerLabel: label,
          model: aiProviderModelLabel(providerId, settings),
        };
      } catch (error) {
        const msg = clean(error && error.message ? error.message : String(error));
        failures.push(`${label}: ${msg || t('focus_unknown_error')}`);
      }
    }

    throw new Error(failures.length ? failures.join(' | ') : langText('Aucun fournisseur IA disponible.', 'No AI provider available.'));
  }

  function ensureChartJsLoaded() {
    if (window.Chart) return Promise.resolve(true);
    if (S.chartLoadPromise) return S.chartLoadPromise;

    const baseUrl = (window.Grocy && window.Grocy.BaseUrl) ? window.Grocy.BaseUrl : '/';
    const normalizedBase = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;
    const src = `${normalizedBase}packages/chart.js/dist/Chart.min.js?v=${Date.now()}`;

    S.chartLoadPromise = new Promise((resolve) => {
      if (document.querySelector(`script[src^="${normalizedBase}packages/chart.js/dist/Chart.min.js"]`)) {
        const waitForChart = () => {
          if (window.Chart) resolve(true);
          else setTimeout(waitForChart, 100);
        };
        waitForChart();
        return;
      }

      const script = document.createElement('script');
      script.src = src;
      script.async = true;
      script.onload = () => resolve(true);
      script.onerror = () => resolve(false);
      document.head.appendChild(script);
    });

    return S.chartLoadPromise;
  }

  function apiBaseUrl() {
    const baseUrl = (window.Grocy && window.Grocy.BaseUrl) ? window.Grocy.BaseUrl : '/';
    return baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;
  }

  async function fetchJson(relativePath) {
    const path = relativePath.startsWith('/') ? relativePath.slice(1) : relativePath;
    const response = await fetch(`${apiBaseUrl()}${path}`, {
      credentials: 'same-origin',
      headers: { Accept: 'application/json' },
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status} on ${relativePath}`);
    }

    return response.json();
  }

  function extractArray(payload) {
    if (Array.isArray(payload)) return payload;
    if (payload && Array.isArray(payload.data)) return payload.data;
    if (payload && Array.isArray(payload.result)) return payload.result;
    if (payload && payload.data && Array.isArray(payload.data.items)) return payload.data.items;
    if (payload && payload.result && Array.isArray(payload.result.items)) return payload.result.items;
    if (payload && payload.response && Array.isArray(payload.response)) return payload.response;
    if (payload && payload.list && Array.isArray(payload.list)) return payload.list;
    return [];
  }

  function deepCollectObjects(payload, predicate, limit = 5000) {
    const result = [];
    const stack = [payload];
    const seen = new Set();

    while (stack.length > 0 && result.length < limit) {
      const current = stack.pop();
      if (!current || typeof current !== 'object') continue;
      if (seen.has(current)) continue;
      seen.add(current);

      if (!Array.isArray(current) && predicate(current)) {
        result.push(current);
      }

      if (Array.isArray(current)) {
        for (const item of current) stack.push(item);
      } else {
        for (const value of Object.values(current)) stack.push(value);
      }
    }

    return result;
  }

  function hasAnyKey(obj, keys) {
    return keys.some((k) => Object.prototype.hasOwnProperty.call(obj, k));
  }

  function boolish(value) {
    if (value === true || value === 1 || value === '1' || value === 'true') return true;
    return false;
  }

  function pickFirstNumber(object, keys) {
    for (const key of keys) {
      if (object && Object.prototype.hasOwnProperty.call(object, key)) {
        const n = num(object[key]);
        if (Number.isFinite(n) && n !== 0) return n;
      }
    }
    return 0;
  }

  function pickFirstString(object, keys) {
    for (const key of keys) {
      if (object && Object.prototype.hasOwnProperty.call(object, key)) {
        const v = clean(object[key]);
        if (v) return v;
      }
    }
    return '';
  }

  function parseApiDate(value) {
    const text = clean(value);
    if (!text) return null;
    const normalized = text.length >= 10 ? text.slice(0, 10) : text;
    if (!/^\d{4}-\d{2}-\d{2}$/.test(normalized)) return null;
    if (isNoDueSentinelDateValue(normalized)) return null;
    const date = normalizeDueDateValue(`${normalized}T00:00:00`);
    return date || null;
  }

  function computeDueFlags(item) {
    const now = new Date();
    now.setHours(0, 0, 0, 0);
    const date = item.due;
    if (!date || item.amount <= 0) return;

    const diffDays = Math.floor((date.getTime() - now.getTime()) / 86400000);
    if (diffDays < 0) {
      if (item.dueType === 1) item.overdue = true;
      else item.expired = true;
      return;
    }

    if (diffDays <= S.dueSoonDays) {
      item.soon = true;
    }
  }

  function normalizeApiStockRows(rawRows, groupMap = new Map(), quantityUnitMap = new Map()) {
    const byProduct = new Map();

    for (const row of rawRows) {
      const productId = pickFirstNumber(row, ['product_id', 'productId', 'id']);
      if (!productId) continue;
      const product = row && typeof row.product === 'object' ? row.product : null;

      if (!byProduct.has(productId)) {
        byProduct.set(productId, {
          id: productId,
          name: '',
          group: defaultNoGroupLabel(),
          stockUnitName: '',
          stockUnitId: 0,
          isParent: false,
          amount: 0,
          value: 0,
          calories: 0,
          price: 0,
          avgPrice: 0,
          due: null,
          dueType: 2,
          below: false,
          soon: false,
          overdue: false,
          expired: false,
        });
      }

      const current = byProduct.get(productId);
      const groupId = pickFirstNumber(row, ['product_group_id']) || pickFirstNumber(product, ['product_group_id']);
      const groupFromId = groupMap.get(groupId) || '';
      const name = pickFirstString(row, ['product_name', 'name']) || pickFirstString(product, ['name']);
      const group = pickFirstString(row, ['product_group_name', 'group_name']) || pickFirstString(product, ['product_group_name', 'group_name']) || groupFromId;
      const unitId = pickFirstNumber(row, ['qu_id_stock', 'stock_qu_id', 'stock_quantity_unit_id'])
        || pickFirstNumber(product, ['qu_id_stock', 'stock_qu_id', 'qu_id', 'stock_quantity_unit_id']);
      const unitFromId = quantityUnitMap.get(unitId) || '';
      const unitName = pickFirstString(
        row,
        ['stock_qu_name', 'qu_name', 'stock_unit_name', 'quantity_unit_name', 'stock_quantity_unit_name', 'unit_name']
      ) || pickFirstString(
        product,
        ['stock_qu_name', 'qu_name', 'stock_unit_name', 'quantity_unit_name', 'stock_quantity_unit_name', 'unit_name']
      ) || unitFromId;
      if (name) current.name = name;
      if (group) current.group = group;
      if (unitName) current.stockUnitName = cleanUnitLabel(unitName) || current.stockUnitName;
      if (unitId > 0) current.stockUnitId = unitId;
      if (boolish(row.no_own_stock) || boolish(product && product.no_own_stock) || boolish(row.is_parent) || boolish(product && product.is_parent)) {
        current.isParent = true;
      }

      const amount = pickFirstNumber(row, ['amount_aggregated', 'amount']);
      const value = pickFirstNumber(row, ['value']);
      const unitCalories = pickFirstNumber(row, ['product_calories', 'calories_per_unit']) || pickFirstNumber(product, ['calories']);
      let calories = pickFirstNumber(row, ['calories']);
      if (calories <= 0 && unitCalories > 0 && amount > 0) calories = unitCalories * amount;
      const lastPrice = pickFirstNumber(row, ['last_price', 'price']);
      const avgPrice = pickFirstNumber(row, ['average_price']);
      const computedPrice = (amount > 0 && value > 0) ? (value / amount) : 0;

      current.amount += amount;
      current.value += value;
      current.calories += calories;
      if (lastPrice > 0) current.price = lastPrice;
      else if (computedPrice > 0 && current.price <= 0) current.price = computedPrice;
      if (avgPrice > 0) current.avgPrice = avgPrice;
      else if (computedPrice > 0 && current.avgPrice <= 0) current.avgPrice = computedPrice;

      const dueDate = parseApiDate(row.best_before_date || row.next_due_date || row.due_date || '');
      if (dueDate && (!current.due || dueDate < current.due)) current.due = dueDate;

      const dueType = pickFirstNumber(row, ['due_type']);
      if (dueType > 0) current.dueType = dueType;

      if (boolish(row.product_missing) || boolish(row.below_min_stock_amount) || boolish(row.is_below_min_stock)) {
        current.below = true;
      }
      if (boolish(row.due_soon) || boolish(row.is_due_soon)) current.soon = true;
      if (boolish(row.overdue) || boolish(row.is_overdue)) current.overdue = true;
      if (boolish(row.expired) || boolish(row.is_expired)) current.expired = true;
    }

    byProduct.forEach((item) => {
      if (!item.value || item.value <= 0) {
        const fallbackPrice = item.price > 0 ? item.price : item.avgPrice;
        if (fallbackPrice > 0 && item.amount > 0) item.value = fallbackPrice * item.amount;
      }
      if ((!item.price || item.price <= 0) && item.amount > 0 && item.value > 0) {
        item.price = item.value / item.amount;
      }
      if ((!item.avgPrice || item.avgPrice <= 0) && item.price > 0) {
        item.avgPrice = item.price;
      }
      item.stockUnitName = cleanUnitLabel(item.stockUnitName || '');
      item.stockUnitId = num(item.stockUnitId) > 0 ? num(item.stockUnitId) : 0;
      item.isParent = boolish(item.isParent);
      computeDueFlags(item);
    });

    return byProduct;
  }

  async function loadProductGroupMapFromApi() {
    const map = new Map();
    try {
      const payload = await fetchJson('api/objects/product_groups');
      let groups = extractArray(payload);
      if (groups.length === 0) {
        groups = deepCollectObjects(payload, (o) => hasAnyKey(o, ['id']) && hasAnyKey(o, ['name']));
      }

      for (const group of groups) {
        const id = num(group.id);
        const name = clean(group.name);
        if (id > 0 && name) {
          map.set(id, name);
        }
      }
    } catch (error) {
      console.warn('Dashboard: impossible de charger les groupes produits via API', error);
    }
    return map;
  }

  async function loadQuantityUnitMapFromApi() {
    const map = new Map();
    try {
      const payload = await fetchJson('api/objects/quantity_units');
      let units = extractArray(payload);
      if (units.length === 0) {
        units = deepCollectObjects(payload, (o) => hasAnyKey(o, ['id']) && hasAnyKey(o, ['name']));
      }

      for (const unit of units) {
        const id = num(unit.id);
        const name = cleanUnitLabel(unit.name);
        if (id > 0 && name) {
          map.set(id, name);
        }
      }
    } catch (error) {
      console.warn('Dashboard: impossible de charger les unités via API', error);
    }
    return map;
  }

  async function loadParentModeMapFromApi(productIdsInput = []) {
    const map = new Map();
    try {
      const productIds = Array.isArray(productIdsInput)
        ? productIdsInput.map((id) => num(id)).filter((id) => id > 0)
        : [];
      const filter = new Set(productIds);

      const payload = await fetchJson('api/objects/products');
      let rows = extractArray(payload);
      if (rows.length === 0) {
        rows = deepCollectObjects(
          payload,
          (o) => hasAnyKey(o, ['id']) && hasAnyKey(o, ['no_own_stock', 'name'])
        );
      }

      rows.forEach((row) => {
        const productId = pickFirstNumber(row, ['id', 'product_id', 'productId']);
        if (!(productId > 0)) return;
        if (filter.size > 0 && !filter.has(productId)) return;
        const isParent = boolish(row.no_own_stock)
          || boolish(row.is_parent)
          || boolish(row.parent);
        map.set(productId, isParent);
      });
    } catch (error) {
      console.warn('Dashboard: impossible de charger le mode parent produits via API', error);
    }
    return map;
  }

  function indexQuantityUnitNames(quantityUnitMapInput) {
    const map = new Map();
    if (!(quantityUnitMapInput instanceof Map)) return map;
    quantityUnitMapInput.forEach((label, idInput) => {
      const id = num(idInput);
      const key = norm(cleanUnitLabel(label || ''));
      if (!(id > 0) || !key) return;
      const list = map.get(key) || [];
      if (!list.includes(id)) list.push(id);
      map.set(key, list);
    });
    return map;
  }

  function conversionPathLength(pathInput) {
    if (Number.isFinite(pathInput)) {
      const direct = Math.floor(num(pathInput));
      return direct > 0 ? direct : 0;
    }
    const path = clean(pathInput || '');
    if (!path) return 0;
    return path.split('/').filter(Boolean).length;
  }

  function conversionCandidateScore(candidateInput) {
    const candidate = candidateInput && typeof candidateInput === 'object' ? candidateInput : {};
    const factor = num(candidate.factor);
    const pathLen = conversionPathLength(candidate.pathLen || candidate.path || '');
    const source = clean(candidate.source || '');
    const resolvedBonus = source.includes('resolved') ? 5000 : 0;
    const pathScore = pathLen > 0 ? (10000 - pathLen) : 0;
    const scaleScore = factor > 0 ? -Math.abs(Math.log10(factor)) : -1000;
    return resolvedBonus + pathScore + scaleScore;
  }

  function shouldReplaceConversionCandidate(currentInput, nextInput) {
    const current = currentInput && typeof currentInput === 'object' ? currentInput : null;
    const next = nextInput && typeof nextInput === 'object' ? nextInput : null;
    if (!next || !(num(next.factor) > 0)) return false;
    if (!current) return true;
    return conversionCandidateScore(next) > conversionCandidateScore(current);
  }

  function getConversionDomainBucket(targetMap, fromUnitIdInput) {
    const fromUnitId = num(fromUnitIdInput);
    if (!(fromUnitId > 0) || !(targetMap instanceof Map)) return null;
    let bucket = targetMap.get(fromUnitId);
    if (!bucket || typeof bucket !== 'object') {
      bucket = { mass: null, volume: null, count: null };
      targetMap.set(fromUnitId, bucket);
    }
    return bucket;
  }

  function setConversionCandidate(targetMap, fromUnitIdInput, domainInput, candidateInput) {
    const domain = normalizeQtyMode(domainInput);
    if (!['mass', 'volume', 'count'].includes(domain)) return false;
    const bucket = getConversionDomainBucket(targetMap, fromUnitIdInput);
    if (!bucket) return false;
    const candidate = candidateInput && typeof candidateInput === 'object' ? candidateInput : null;
    if (!candidate || !(num(candidate.factor) > 0)) return false;
    const next = {
      factor: num(candidate.factor),
      pathLen: conversionPathLength(candidate.pathLen || candidate.path || ''),
      source: clean(candidate.source || ''),
      toUnitName: cleanUnitLabel(candidate.toUnitName || ''),
    };
    if (shouldReplaceConversionCandidate(bucket[domain], next)) {
      bucket[domain] = next;
      return true;
    }
    return false;
  }

  function unitLabelForId(quantityUnitMapInput, unitIdInput) {
    if (!(quantityUnitMapInput instanceof Map)) return '';
    const unitId = num(unitIdInput);
    if (!(unitId > 0)) return '';
    return cleanUnitLabel(quantityUnitMapInput.get(unitId) || '');
  }

  async function loadQuantityConversionsFromApi(productIdsInput, quantityUnitMapInput) {
    const byProduct = new Map();
    const globalByUnit = new Map();
    const productIds = Array.isArray(productIdsInput)
      ? productIdsInput.map((id) => num(id)).filter((id) => id > 0)
      : [];
    const productFilter = new Set(productIds);
    const endpointCandidates = [
      'api/objects/quantity_unit_conversions_resolved',
      'api/objects/quantity_unit_conversions_resolved_raw',
      'api/objects/cache__quantity_unit_conversions_resolved',
      'api/objects/quantity_unit_conversions',
    ];
    let source = '';
    let rows = [];

    for (const endpoint of endpointCandidates) {
      try {
        const payload = await fetchJson(endpoint);
        let extracted = extractArray(payload);
        if (extracted.length === 0) {
          extracted = deepCollectObjects(
            payload,
            (o) => hasAnyKey(o, ['from_qu_id', 'to_qu_id']) && hasAnyKey(o, ['factor'])
          );
        }
        if (extracted.length > 0) {
          source = endpoint;
          rows = extracted;
          break;
        }
      } catch (_error) {
        // Try next endpoint candidate.
      }
    }

    if (!rows.length) {
      console.warn('Dashboard: conversions d’unités indisponibles via API, fallback heuristique.');
      return { byProduct, globalByUnit, source: 'none', rows: 0 };
    }

    rows.forEach((row) => {
      const fromUnitId = pickFirstNumber(row, ['from_qu_id']);
      const toUnitId = pickFirstNumber(row, ['to_qu_id']);
      const productIdRaw = pickFirstNumber(row, ['product_id']);
      const factor = num(row && row.factor);
      if (!(fromUnitId > 0) || !(factor > 0)) return;

      const toUnitName = pickFirstString(
        row,
        ['to_qu_name', 'to_qu_name_plural', 'to_quantity_unit_name', 'to_unit_name', 'to_name']
      ) || unitLabelForId(quantityUnitMapInput, toUnitId);
      const toInfo = describeQuantityUnit(toUnitName);
      if (!toInfo.domain || !(num(toInfo.factor) > 0)) return;

      const baseFactor = factor * num(toInfo.factor);
      if (!Number.isFinite(baseFactor) || !(baseFactor > 0)) return;

      const candidate = {
        factor: baseFactor,
        pathLen: conversionPathLength(row && row.path),
        source,
        toUnitName,
      };

      const productId = num(productIdRaw);
      if (productId > 0) {
        if (productFilter.size > 0 && !productFilter.has(productId)) return;
        if (!byProduct.has(productId)) byProduct.set(productId, new Map());
        const productMap = byProduct.get(productId);
        setConversionCandidate(productMap, fromUnitId, toInfo.domain, candidate);
        return;
      }

      setConversionCandidate(globalByUnit, fromUnitId, toInfo.domain, candidate);
    });

    return { byProduct, globalByUnit, source, rows: rows.length };
  }

  function detectBrandUserfieldMeta(userfields) {
    const ids = new Set();
    const namesNorm = new Set();

    for (const field of userfields) {
      const entity = norm(field.entity);
      if (entity && entity !== 'products') continue;

      const rawName = clean(field.name);
      const rawCaption = clean(field.caption);
      const nameNorm = norm(rawName);
      const captionNorm = norm(rawCaption);
      if (
        nameNorm.includes('marque')
        || nameNorm.includes('brand')
        || captionNorm.includes('marque')
        || captionNorm.includes('brand')
      ) {
        const id = num(field.id);
        if (id > 0) ids.add(id);
        if (rawName) namesNorm.add(nameNorm);
        if (rawCaption) namesNorm.add(captionNorm);
      }
    }

    namesNorm.add('marque');
    namesNorm.add('brand');
    return { ids, namesNorm };
  }

  function isBrandFieldName(name, brandFieldNamesNorm) {
    const n = norm(name);
    if (!n) return false;
    if (brandFieldNamesNorm.has(n)) return true;
    return n.includes('marque') || n.includes('brand');
  }

  function scalarToText(value) {
    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
      return clean(value);
    }
    return '';
  }

  function extractBrandValueFromUserfieldsPayload(payload, brandFieldNamesNorm, brandFieldIds) {
    if (!payload || typeof payload !== 'object') return '';

    if (!Array.isArray(payload)) {
      for (const [key, value] of Object.entries(payload)) {
        if (!isBrandFieldName(key, brandFieldNamesNorm)) continue;
        const candidate = scalarToText(value);
        if (candidate) return candidate;
      }
    }

    const valueRows = deepCollectObjects(
      payload,
      (o) => hasAnyKey(o, ['value', 'field_value', 'fieldValue', 'val'])
        && (hasAnyKey(o, ['name', 'field_name', 'caption', 'field']) || hasAnyKey(o, ['field_id', 'userfield_id']))
    );

    for (const row of valueRows) {
      const fieldId = pickFirstNumber(row, ['field_id', 'userfield_id']);
      const fieldName = pickFirstString(row, ['name', 'field_name', 'caption', 'field']);
      const matchedById = fieldId > 0 && brandFieldIds.has(fieldId);
      const matchedByName = isBrandFieldName(fieldName, brandFieldNamesNorm);
      if (!matchedById && !matchedByName) continue;

      const candidate = scalarToText(row.value ?? row.field_value ?? row.fieldValue ?? row.val ?? '');
      if (candidate) return candidate;
    }

    return '';
  }

  async function loadBrandMapByProductApi(productIds, brandFieldNamesNorm, brandFieldIds) {
    const map = new Map();
    const uniqueIds = Array.from(new Set(productIds.map((id) => num(id)).filter((id) => id > 0)));
    if (uniqueIds.length === 0) return { map, requested: 0, failed: 0 };

    let cursor = 0;
    let failed = 0;
    const workerCount = Math.min(8, uniqueIds.length);

    async function worker() {
      while (cursor < uniqueIds.length) {
        const index = cursor;
        cursor += 1;
        const productId = uniqueIds[index];
        try {
          const payload = await fetchJson(`api/userfields/products/${productId}`);
          const brand = extractBrandValueFromUserfieldsPayload(payload, brandFieldNamesNorm, brandFieldIds);
          if (brand) map.set(productId, brand);
        } catch (error) {
          failed += 1;
        }
      }
    }

    await Promise.all(Array.from({ length: workerCount }, () => worker()));
    return { map, requested: uniqueIds.length, failed };
  }

  async function loadBrandMapFromApi(productIds) {
    const map = new Map();
    try {
      let userfieldsPayload;
      try {
        userfieldsPayload = await fetchJson('api/objects/userfields?query[]=entity=products');
      } catch (error) {
        userfieldsPayload = await fetchJson('api/objects/userfields');
      }

      let userfields = extractArray(userfieldsPayload);
      if (userfields.length === 0) {
        userfields = deepCollectObjects(
          userfieldsPayload,
          (o) => hasAnyKey(o, ['id', 'name', 'caption']) && hasAnyKey(o, ['entity', 'type'])
        );
      }

      const brandMeta = detectBrandUserfieldMeta(userfields);
      S.apiBrandFieldNames = Array.from(brandMeta.namesNorm);
      if (brandMeta.namesNorm.size === 0 || productIds.length === 0) return map;

      const result = await loadBrandMapByProductApi(productIds, brandMeta.namesNorm, brandMeta.ids);
      S.apiBrandMethod = 'api/userfields/products/<id>';
      S.apiBrandRequests = result.requested;
      S.apiBrandFailures = result.failed;
      return result.map;
    } catch (error) {
      console.warn('Dashboard: impossible de charger les marques via userfields', error);
      S.apiBrandMethod = 'failed';
    }
    return map;
  }

  async function refreshApiData(force = false) {
    if (!force && S.apiLoaded) return true;
    if (!force && S.apiLoadPromise) return S.apiLoadPromise;

    if (force) {
      S.apiLoaded = false;
      S.apiStockByProductId = new Map();
      S.apiBrandByProductId = new Map();
      S.apiProductGroupById = new Map();
      S.apiQuantityUnitById = new Map();
      S.apiQuantityUnitIdsByNorm = new Map();
      S.apiQuantityConversionsByProductId = new Map();
      S.apiQuantityConversionsGlobalByUnitId = new Map();
      S.apiStockSource = '';
      S.apiStockRawRows = 0;
      S.apiQuantityConversionSource = '';
      S.apiQuantityConversionRows = 0;
      S.apiBrandMethod = '';
      S.apiBrandRequests = 0;
      S.apiBrandFailures = 0;
      S.apiBrandFieldNames = [];
      resetKpiLifetimeTotalsState();
    }

    const dueSoonRaw = document.getElementById('info-duesoon-products')?.dataset?.nextXDays;
    const dueSoonDays = parseInt(dueSoonRaw || '5', 10);
    if (Number.isFinite(dueSoonDays) && dueSoonDays > 0) {
      S.dueSoonDays = dueSoonDays;
    }

    S.apiLoadPromise = (async () => {
      let stockRows = [];
      try {
        const stockPayload = await fetchJson('api/stock');
        stockRows = extractArray(stockPayload);
        S.apiStockSource = 'api/stock';
        if (stockRows.length === 0) {
          stockRows = deepCollectObjects(
            stockPayload,
            (o) => hasAnyKey(o, ['product_id', 'productId']) && hasAnyKey(o, ['amount', 'amount_aggregated', 'value'])
          );
        }
      } catch (error) {
        const volatilePayload = await fetchJson('api/stock/volatile');
        stockRows = extractArray(volatilePayload);
        S.apiStockSource = 'api/stock/volatile';
        if (stockRows.length === 0) {
          stockRows = deepCollectObjects(
            volatilePayload,
            (o) => hasAnyKey(o, ['product_id', 'productId']) && hasAnyKey(o, ['amount', 'amount_aggregated', 'value'])
          );
        }
      }

      S.apiStockRawRows = stockRows.length;
      S.apiProductGroupById = await loadProductGroupMapFromApi();
      S.apiQuantityUnitById = await loadQuantityUnitMapFromApi();
      S.apiQuantityUnitIdsByNorm = indexQuantityUnitNames(S.apiQuantityUnitById);
      S.apiStockByProductId = normalizeApiStockRows(stockRows, S.apiProductGroupById, S.apiQuantityUnitById);
      const domProductIdsForConversions = sourceProductRows().map((r) => rowProductId(r)).filter((id) => id > 0);
      const apiProductIdsForConversions = Array.from(new Set([
        ...Array.from(S.apiStockByProductId.keys()),
        ...domProductIdsForConversions,
      ]));
      const conversionState = await loadQuantityConversionsFromApi(apiProductIdsForConversions, S.apiQuantityUnitById);
      S.apiQuantityConversionsByProductId = conversionState.byProduct;
      S.apiQuantityConversionsGlobalByUnitId = conversionState.globalByUnit;
      S.apiQuantityConversionSource = conversionState.source;
      S.apiQuantityConversionRows = conversionState.rows;
      const domProductIds = sourceProductRows().map((r) => rowProductId(r)).filter((id) => id > 0);
      const apiProductIds = Array.from(S.apiStockByProductId.keys());
      const productIds = Array.from(new Set([...domProductIds, ...apiProductIds]));
      S.apiBrandByProductId = await loadBrandMapFromApi(productIds);
      S.apiLoaded = S.apiStockByProductId.size > 0 || S.apiBrandByProductId.size > 0;
      return true;
    })().catch((error) => {
      console.warn('Dashboard: chargement API impossible, fallback DOM', error);
      S.apiLoaded = false;
      return false;
    }).finally(() => {
      S.apiLoadPromise = null;
    });

    return S.apiLoadPromise;
  }

  function colors(n, a = 0.8) {
    const out = [];
    for (let i = 0; i < n; i += 1) {
      const hex = COLORS[i % COLORS.length].replace('#', '');
      const v = parseInt(hex, 16);
      const r = (v >> 16) & 255;
      const g = (v >> 8) & 255;
      const b = v & 255;
      out.push(`rgba(${r}, ${g}, ${b}, ${a})`);
    }
    return out;
  }

  function tooltipIndex(item) {
    if (!item || typeof item !== 'object') return -1;
    if (Number.isInteger(item.dataIndex)) return item.dataIndex;
    if (Number.isInteger(item.index)) return item.index;
    return -1;
  }

  function tooltipDatasetIndex(item) {
    if (!item || typeof item !== 'object') return 0;
    return Number.isInteger(item.datasetIndex) ? item.datasetIndex : 0;
  }

  function tooltipRaw(item, data) {
    if (item && item.raw) return item.raw;
    const idx = tooltipIndex(item);
    const dsIdx = tooltipDatasetIndex(item);
    if (idx < 0) return null;
    const ds = data && data.datasets && data.datasets[dsIdx] ? data.datasets[dsIdx] : null;
    if (!ds || !Array.isArray(ds.data)) return null;
    return ds.data[idx];
  }

  function tooltipNumber(item, axisKey) {
    if (item && typeof item.parsed === 'number') return item.parsed;
    if (item && item.parsed && typeof item.parsed === 'object') {
      const parsedAxis = item.parsed[axisKey];
      if (parsedAxis !== undefined) return num(parsedAxis);
      if (axisKey === 'x' && item.parsed.x !== undefined) return num(item.parsed.x);
      if (axisKey === 'y' && item.parsed.y !== undefined) return num(item.parsed.y);
    }
    if (item && axisKey === 'x' && item.xLabel !== undefined) return num(item.xLabel);
    if (item && axisKey === 'y' && item.yLabel !== undefined) return num(item.yLabel);
    if (item && item.value !== undefined) return num(item.value);
    return 0;
  }

  function chartMajorVersion() {
    if (!window.Chart) return 3;
    const raw = window.Chart.version ? String(window.Chart.version) : '';
    if (!raw) {
      if (window.Chart.defaults && window.Chart.defaults.global) return 2;
      if (window.Chart.helpers && typeof window.Chart.helpers.configMerge === 'function') return 2;
      return 3;
    }
    const major = parseInt(raw.split('.')[0], 10);
    return Number.isFinite(major) ? major : 3;
  }

  function isChartJsV2() {
    return chartMajorVersion() < 3;
  }

  function barScales(horizontal, compact, label) {
    if (isChartJsV2()) {
      if (horizontal) {
        return {
          xAxes: [{
            ticks: { beginAtZero: true, display: !compact },
            scaleLabel: { display: !compact, labelString: label },
            gridLines: { display: !compact },
          }],
          yAxes: [{
            ticks: { display: !compact, autoSkip: true, maxTicksLimit: compact ? 8 : 40 },
            gridLines: { display: !compact },
          }],
        };
      }

      return {
        xAxes: [{
          ticks: { display: !compact, autoSkip: true, maxRotation: compact ? 0 : 60, minRotation: compact ? 0 : 0 },
          gridLines: { display: !compact },
        }],
        yAxes: [{
          ticks: { beginAtZero: true, display: !compact },
          scaleLabel: { display: !compact, labelString: label },
          gridLines: { display: !compact },
        }],
      };
    }

    return {
      x: {
        beginAtZero: true,
        title: { display: !compact, text: label },
        ticks: { display: !compact },
        grid: { display: !compact },
      },
      y: {
        beginAtZero: true,
        ticks: {
          display: !compact,
          autoSkip: true,
          maxTicksLimit: compact ? 10 : 40,
        },
        grid: { display: !compact },
      },
    };
  }

  function xyScales(xTitle, yTitle, compact) {
    if (isChartJsV2()) {
      return {
        xAxes: [{
          ticks: { beginAtZero: true, display: !compact },
          scaleLabel: { display: !compact, labelString: xTitle },
          gridLines: { display: !compact },
        }],
        yAxes: [{
          ticks: { beginAtZero: true, display: !compact },
          scaleLabel: { display: !compact, labelString: yTitle },
          gridLines: { display: !compact },
        }],
      };
    }

    return {
      x: {
        beginAtZero: true,
        title: { display: !compact, text: xTitle },
        ticks: { display: !compact },
        grid: { display: !compact },
      },
      y: {
        beginAtZero: true,
        title: { display: !compact, text: yTitle },
        ticks: { display: !compact },
        grid: { display: !compact },
      },
    };
  }

  function donutConfig(entries, suffix = '', options = {}) {
    const compact = options.compact !== false;
    const showLegendInChart = options.showLegendInChart === true;
    const disableTooltip = options.disableTooltip === true;
    const onPointHover = typeof options.onPointHover === 'function' ? options.onPointHover : null;
    const onPointLeave = typeof options.onPointLeave === 'function' ? options.onPointLeave : null;
    const onPointClick = typeof options.onPointClick === 'function' ? options.onPointClick : null;
    const labels = entries.map((e) => e[0]);
    const values = entries.map((e) => e[1]);
    const tooltipCallbacks = {
      label: (ctx, dataObj) => {
        const idx = tooltipIndex(ctx);
        const label = clean(
          (ctx && ctx.label)
          || (dataObj && dataObj.labels && idx >= 0 ? dataObj.labels[idx] : '')
        );
        const raw = tooltipRaw(ctx, dataObj);
        const value = (typeof raw === 'number') ? num(raw) : tooltipNumber(ctx, 'y');
        const decimals = /produit|product|kcal|j\b|d\b/i.test(String(suffix || '')) ? 0 : 2;
        return `${label}: ${fmt(value, decimals)}${suffix}`;
      },
    };
    return {
      type: 'doughnut',
      data: { labels, datasets: [{ data: values, backgroundColor: colors(values.length, 0.82), borderColor: colors(values.length, 1), borderWidth: 1 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        legend: { display: showLegendInChart, position: 'bottom' },
        tooltips: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        onClick: function onDonutClick(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!onPointClick || !elements || !elements.length) return;
          const index = chartElementIndex(elements[0]);
          if (index < 0 || index >= labels.length) return;
          onPointClick(index, clean(labels[index] || ''), entries[index], chart);
          if (chart && chart.canvas) chart.canvas.style.cursor = 'default';
        },
        onHover: function onDonutHover(evt, elements, chartRef) {
          const chart = chartRef || this;
          const list = Array.isArray(elements) ? elements : [];
          if (list.length > 0) {
            const index = chartElementIndex(list[0]);
            if (index >= 0 && index < labels.length) {
              if (onPointHover) onPointHover(index, clean(labels[index] || ''), entries[index], evt, chart);
              return;
            }
          }
          if (onPointLeave) onPointLeave();
          if (chart && chart.canvas) chart.canvas.style.cursor = 'default';
        },
        pieceLabel: { render: 'none' },
        plugins: {
          legend: { display: showLegendInChart, position: 'bottom' },
          tooltip: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
          datalabels: { display: false },
          outlabels: { display: false },
        },
      },
    };
  }

  function barConfig(entries, label, horizontal = false, dec = 2, options = {}) {
    const compact = options.compact !== false;
    const clickIds = Array.isArray(options.clickIds) ? options.clickIds : null;
    const onPointClick = typeof options.onPointClick === 'function' ? options.onPointClick : null;
    const onPointHover = typeof options.onPointHover === 'function' ? options.onPointHover : null;
    const onPointLeave = typeof options.onPointLeave === 'function' ? options.onPointLeave : null;
    const valueFormatter = typeof options.valueFormatter === 'function' ? options.valueFormatter : null;
    const disableTooltip = options.disableTooltip === true;
    const clickable = !!onPointClick || !!clickIds;
    const requestedLabelMax = Number.isFinite(options.labelMaxLength)
      ? Math.max(8, Math.floor(options.labelMaxLength))
      : (horizontal ? 34 : 20);
    const shortenLabel = (text) => {
      const raw = clean(text || '');
      if (!raw) return '';
      if (raw.length <= requestedLabelMax) return raw;
      return `${raw.slice(0, Math.max(1, requestedLabelMax - 1))}…`;
    };
    const labels = entries.map((e) => {
      if (!compact) return shortenLabel(e[0]);
      return shortenLabel(e[0]);
    });
    const full = entries.map((e) => e[0]);
    const values = entries.map((e) => e[1]);
    const type = horizontal && isChartJsV2() ? 'horizontalBar' : 'bar';
    const tooltipCallbacks = {
      title: (items, dataObj) => {
        const first = items && items[0] ? items[0] : null;
        if (!first) return '';
        const ds = (first.dataset && first.dataset.full)
          ? first.dataset
          : (dataObj && dataObj.datasets && dataObj.datasets[tooltipDatasetIndex(first)]);
        const idx = tooltipIndex(first);
        if (ds && ds.full && idx >= 0 && ds.full[idx]) return ds.full[idx];
        return first.label || '';
      },
      label: (ctx) => {
        const value = tooltipNumber(ctx, horizontal ? 'x' : 'y');
        if (valueFormatter) return `${label}: ${valueFormatter(value, dec)}`;
        return `${label}: ${valueWithMetricUnit(value, label, dec)}`;
      },
    };
    const cfg = {
      type,
      data: { labels, datasets: [{ label, data: values, backgroundColor: colors(values.length, 0.75), borderColor: colors(values.length, 1), borderWidth: 1, full }] },
      options: {
        indexAxis: horizontal ? 'y' : 'x',
        responsive: true,
        maintainAspectRatio: false,
        legend: { display: false },
        tooltips: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        onClick: function onBarClick(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if ((!clickable) || !elements || !elements.length) return;
          const index = chartElementIndex(elements[0]);
          if (index < 0 || index >= values.length) return;
          if (onPointClick) {
            const pointLabel = clean(full[index] || entries[index]?.[0] || '');
            onPointClick(index, pointLabel, num(values[index]), entries[index], chart);
            if (chart && chart.canvas) chart.canvas.style.cursor = 'default';
            return;
          }
          if (!clickIds || index >= clickIds.length) return;
          openProduct(clickIds[index]);
          if (chart && chart.canvas) chart.canvas.style.cursor = 'default';
        },
        onHover: function onBarHover(evt, elements, chartRef) {
          const chart = chartRef || this;
          const list = Array.isArray(elements) ? elements : [];
          let hasHoverData = false;
          if (list.length > 0) {
            const index = chartElementIndex(list[0]);
            if (index >= 0 && index < values.length) {
              hasHoverData = true;
              if (onPointHover) {
                const pointLabel = clean(full[index] || entries[index]?.[0] || '');
                onPointHover(index, pointLabel, num(values[index]), entries[index], evt, chart);
              }
            }
          }
          if (!hasHoverData && onPointLeave) onPointLeave();
          if (!chart || !chart.canvas) return;
          if (clickable) {
            chart.canvas.style.cursor = list.length ? 'pointer' : 'default';
          } else if (!list.length) {
            chart.canvas.style.cursor = 'default';
          }
        },
        plugins: {
          legend: { display: false },
          tooltip: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        },
        scales: barScales(horizontal, compact, label),
      },
    };
    const tickLabelCb = (value, index) => {
      const idx = Number.isInteger(index) ? index : parseInt(index, 10);
      if (Number.isInteger(idx) && idx >= 0 && idx < full.length) {
        return shortenLabel(full[idx]);
      }
      return shortenLabel(value);
    };
    if (isChartJsV2()) {
      if (horizontal && cfg.options.scales && cfg.options.scales.yAxes && cfg.options.scales.yAxes[0]) {
        cfg.options.scales.yAxes[0].ticks = cfg.options.scales.yAxes[0].ticks || {};
        cfg.options.scales.yAxes[0].ticks.callback = tickLabelCb;
      } else if (!horizontal && cfg.options.scales && cfg.options.scales.xAxes && cfg.options.scales.xAxes[0]) {
        cfg.options.scales.xAxes[0].ticks = cfg.options.scales.xAxes[0].ticks || {};
        cfg.options.scales.xAxes[0].ticks.maxRotation = compact ? 22 : 35;
        cfg.options.scales.xAxes[0].ticks.minRotation = compact ? 22 : 35;
        cfg.options.scales.xAxes[0].ticks.callback = tickLabelCb;
      }
    } else {
      const axisKey = horizontal ? 'y' : 'x';
      const axisCfg = (cfg.options.scales && cfg.options.scales[axisKey]) ? cfg.options.scales[axisKey] : {};
      axisCfg.ticks = axisCfg.ticks || {};
      if (!horizontal) {
        axisCfg.ticks.maxRotation = compact ? 22 : 35;
        axisCfg.ticks.minRotation = compact ? 22 : 35;
      } else {
        axisCfg.ticks.maxRotation = 0;
        axisCfg.ticks.minRotation = 0;
      }
      axisCfg.ticks.callback = tickLabelCb;
      cfg.options.scales[axisKey] = axisCfg;
    }
    return cfg;
  }

  function chartDonut(id, entries, suffix = '', options = {}) {
    draw(id, donutConfig(entries, suffix, options));
  }

  function chartBar(id, entries, label, horizontal = false, dec = 2, options = {}) {
    draw(id, barConfig(entries, label, horizontal, dec, options));
  }

  function drawOverlayChart(cfg) {
    if (!window.Chart) return;
    const canvas = document.getElementById('dash_chart_overlay_canvas');
    if (!canvas) return;
    destroyFullChart();
    S.fullChart = new window.Chart(canvas.getContext('2d'), cfg);
    captureOverlayChartVisualBase(S.fullChart);
    applyOverlayChartVisualHighlight(-1);
    if (!canvas.dataset.overlayHoverResetBound) {
      canvas.addEventListener('mouseleave', () => {
        cancelOverlayHoverClear();
        clearOverlayChartActiveIndex();
        hideChartHoverPreview();
      });
      canvas.dataset.overlayHoverResetBound = '1';
    }
  }

  function bubbleConfig(points, label = t('chart_dataset_brands'), options = {}) {
    const compact = options.compact !== false;
    const onPointClick = typeof options.onPointClick === 'function' ? options.onPointClick : null;
    const onPointHover = typeof options.onPointHover === 'function' ? options.onPointHover : null;
    const onPointLeave = typeof options.onPointLeave === 'function' ? options.onPointLeave : null;
    const disableTooltip = options.disableTooltip === true;
    const tooltipCallbacks = {
      label: (ctx, dataObj) => {
        const r = tooltipRaw(ctx, dataObj) || {};
        const x = r.x !== undefined ? num(r.x) : tooltipNumber(ctx, 'x');
        const y = r.y !== undefined ? num(r.y) : tooltipNumber(ctx, 'y');
        const name = clean(r.brand || r.name || label.slice(0, -1));
        const count = num(r.n || 0);
        return `${name}: ${t('metric_price_prefix')} ${fmtMoney(x)} | ${t('metric_value_prefix')} ${fmtMoney(y)} | ${fmtProducts(count)}`;
      },
    };
    return {
      type: 'bubble',
      data: { datasets: [{ label, data: points, backgroundColor: 'rgba(13,110,253,0.35)', borderColor: 'rgba(13,110,253,0.95)', borderWidth: 1 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        legend: { display: false },
        tooltips: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        onClick: function onBubbleClick(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!onPointClick || !elements || !elements.length) return;
          const index = chartElementIndex(elements[0]);
          const ds = chart && chart.data && chart.data.datasets ? chart.data.datasets[0] : null;
          const data = ds && Array.isArray(ds.data) ? ds.data : [];
          if (index < 0 || index >= data.length) return;
          onPointClick(index, data[index], chart);
          if (chart && chart.canvas) chart.canvas.style.cursor = 'default';
        },
        onHover: function onBubbleHover(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!chart || !chart.canvas) return;
          const list = Array.isArray(elements) ? elements : [];
          if (list.length > 0) {
            const index = chartElementIndex(list[0]);
            const data = chart && chart.data && chart.data.datasets && chart.data.datasets[0]
              ? chart.data.datasets[0].data
              : [];
            if (index >= 0 && index < data.length && onPointHover) {
              onPointHover(index, data[index], _evt, chart);
            }
          } else if (onPointLeave) {
            onPointLeave();
          }
          chart.canvas.style.cursor = (onPointClick && list.length) ? 'pointer' : 'default';
        },
        plugins: {
          legend: { display: false },
          tooltip: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        },
        scales: xyScales(t('chart_axis_avg_unit_price'), t('chart_axis_stock_value'), compact),
      },
    };
  }

  function scatterConfig(points, options = {}) {
    const compact = options.compact !== false;
    const openOnClick = options.openOnClick === true;
    const onPointHover = typeof options.onPointHover === 'function' ? options.onPointHover : null;
    const onPointLeave = typeof options.onPointLeave === 'function' ? options.onPointLeave : null;
    const disableTooltip = options.disableTooltip === true;
    const tooltipCallbacks = {
      label: (ctx, dataObj) => {
        const r = tooltipRaw(ctx, dataObj) || {};
        const x = r.x !== undefined ? num(r.x) : tooltipNumber(ctx, 'x');
        const y = r.y !== undefined ? num(r.y) : tooltipNumber(ctx, 'y');
        const name = clean(r.name || t('default_product'));
        return `${name}: ${t('metric_price_prefix')} ${fmtMoney(x)} | ${t('metric_value_prefix')} ${fmtMoney(y)}`;
      },
    };
    return {
      type: 'scatter',
      data: { datasets: [{ label: t('chart_dataset_products'), data: points, backgroundColor: 'rgba(220,53,69,0.35)', borderColor: 'rgba(220,53,69,0.8)', pointRadius: compact ? 3 : 4 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        legend: { display: false },
        tooltips: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        onClick: function onScatterClick(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!openOnClick || !elements || !elements.length) return;
          const first = elements[0];
          const index = chartElementIndex(first);
          const data = chart && chart.data && chart.data.datasets && chart.data.datasets[0]
            ? chart.data.datasets[0].data
            : [];
          if (index < 0 || index >= data.length) return;
          const raw = data[index];
          openProduct(raw && raw.id ? raw.id : 0);
        },
        onHover: function onScatterHover(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!chart || !chart.canvas) return;
          const list = Array.isArray(elements) ? elements : [];
          const data = chart && chart.data && chart.data.datasets && chart.data.datasets[0]
            ? chart.data.datasets[0].data
            : [];
          if (list.length > 0) {
            const index = chartElementIndex(list[0]);
            if (index >= 0 && index < data.length && onPointHover) {
              onPointHover(index, data[index], _evt, chart);
            }
          } else if (onPointLeave) {
            onPointLeave();
          }
          chart.canvas.style.cursor = (openOnClick && list.length) ? 'pointer' : 'default';
        },
        plugins: {
          legend: { display: false },
          tooltip: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        },
        scales: xyScales(t('chart_axis_unit_price'), t('chart_axis_stock_value'), compact),
      },
    };
  }

  function bubbleRadiusFromValue(value) {
    const v = Math.max(0, num(value));
    return Math.max(4, Math.min(18, 3 + Math.sqrt(v)));
  }

  function productBubbleConfig(points, options = {}) {
    const compact = options.compact !== false;
    const openOnClick = options.openOnClick === true;
    const onPointHover = typeof options.onPointHover === 'function' ? options.onPointHover : null;
    const onPointLeave = typeof options.onPointLeave === 'function' ? options.onPointLeave : null;
    const disableTooltip = options.disableTooltip === true;
    const mapped = points.map((p) => ({
      ...p,
      r: bubbleRadiusFromValue(p.y),
    }));
    const tooltipCallbacks = {
      label: (ctx, dataObj) => {
        const r = tooltipRaw(ctx, dataObj) || {};
        const x = r.x !== undefined ? num(r.x) : tooltipNumber(ctx, 'x');
        const y = r.y !== undefined ? num(r.y) : tooltipNumber(ctx, 'y');
        const name = clean(r.name || t('default_product'));
        return `${name}: ${t('metric_price_prefix')} ${fmtMoney(x)} | ${t('metric_value_prefix')} ${fmtMoney(y)}`;
      },
    };
    return {
      type: 'bubble',
      data: { datasets: [{ label: t('chart_dataset_products'), data: mapped, backgroundColor: 'rgba(220,53,69,0.35)', borderColor: 'rgba(220,53,69,0.8)', borderWidth: 1 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        legend: { display: false },
        tooltips: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        onClick: function onBubbleClick(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!openOnClick || !elements || !elements.length) return;
          const index = chartElementIndex(elements[0]);
          const data = chart && chart.data && chart.data.datasets && chart.data.datasets[0]
            ? chart.data.datasets[0].data
            : [];
          if (index < 0 || index >= data.length) return;
          const raw = data[index];
          openProduct(raw && raw.id ? raw.id : 0);
        },
        onHover: function onBubbleHover(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!chart || !chart.canvas) return;
          const list = Array.isArray(elements) ? elements : [];
          const data = chart && chart.data && chart.data.datasets && chart.data.datasets[0]
            ? chart.data.datasets[0].data
            : [];
          if (list.length > 0) {
            const index = chartElementIndex(list[0]);
            if (index >= 0 && index < data.length && onPointHover) {
              onPointHover(index, data[index], _evt, chart);
            }
          } else if (onPointLeave) {
            onPointLeave();
          }
          chart.canvas.style.cursor = (openOnClick && list.length) ? 'pointer' : 'default';
        },
        plugins: {
          legend: { display: false },
          tooltip: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        },
        scales: xyScales(t('chart_axis_unit_price'), t('chart_axis_stock_value'), compact),
      },
    };
  }

  function brandRelScatterConfig(points, options = {}) {
    const compact = options.compact !== false;
    const onPointClick = typeof options.onPointClick === 'function' ? options.onPointClick : null;
    const onPointHover = typeof options.onPointHover === 'function' ? options.onPointHover : null;
    const onPointLeave = typeof options.onPointLeave === 'function' ? options.onPointLeave : null;
    const disableTooltip = options.disableTooltip === true;
    const tooltipCallbacks = {
      label: (ctx, dataObj) => {
        const r = tooltipRaw(ctx, dataObj) || {};
        const x = r.x !== undefined ? num(r.x) : tooltipNumber(ctx, 'x');
        const y = r.y !== undefined ? num(r.y) : tooltipNumber(ctx, 'y');
        const name = clean(r.brand || r.name || t('default_brand'));
        const count = num(r.n || 0);
        return `${name}: ${t('metric_price_prefix')} ${fmtMoney(x)} | ${t('metric_value_prefix')} ${fmtMoney(y)} | ${fmtProducts(count)}`;
      },
    };
    return {
      type: 'scatter',
      data: { datasets: [{ label: t('chart_dataset_brands'), data: points, backgroundColor: 'rgba(13,110,253,0.35)', borderColor: 'rgba(13,110,253,0.95)', pointRadius: compact ? 4 : 5 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        legend: { display: false },
        tooltips: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        onClick: function onScatterClick(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!onPointClick || !elements || !elements.length) return;
          const index = chartElementIndex(elements[0]);
          const data = chart && chart.data && chart.data.datasets && chart.data.datasets[0]
            ? chart.data.datasets[0].data
            : [];
          if (index < 0 || index >= data.length) return;
          onPointClick(index, data[index], chart);
          if (chart && chart.canvas) chart.canvas.style.cursor = 'default';
        },
        onHover: function onScatterHover(_evt, elements, chartRef) {
          const chart = chartRef || this;
          if (!chart || !chart.canvas) return;
          const list = Array.isArray(elements) ? elements : [];
          const data = chart && chart.data && chart.data.datasets && chart.data.datasets[0]
            ? chart.data.datasets[0].data
            : [];
          if (list.length > 0) {
            const index = chartElementIndex(list[0]);
            if (index >= 0 && index < data.length && onPointHover) {
              onPointHover(index, data[index], _evt, chart);
            }
          } else if (onPointLeave) {
            onPointLeave();
          }
          chart.canvas.style.cursor = (onPointClick && list.length) ? 'pointer' : 'default';
        },
        plugins: {
          legend: { display: false },
          tooltip: { enabled: !disableTooltip, callbacks: tooltipCallbacks },
        },
        scales: xyScales(t('chart_axis_avg_unit_price'), t('chart_axis_stock_value'), compact),
      },
    };
  }

  function rankedMapEntries(map, defaultLimit = 10, others = true, forceAll = false, chartId = '') {
    const id = clean(chartId || '');
    let useOthers = others;
    if (!forceAll && (id === 'g_val' || id === 'g_cal')) {
      const pref = getChartPref(id);
      if (pref.limit > 0) useOthers = false;
    }
    return applyPairLimit(mapPairs(map), defaultLimit, useOthers, forceAll, chartId);
  }

  function rankedPairs(entries, defaultLimit = 12, others = false, forceAll = false, chartId = '') {
    return applyPairLimit(entries.map((row) => [row[0], Number(row[1]) || 0]), defaultLimit, others, forceAll, chartId);
  }

  function rankedBrandPrice(M, forceAll = false, chartId = 'brand_price') {
    const pref = getChartPref(chartId);
    const pairs = M.brand
      .filter((b) => Number.isFinite(b.avg) && (pref.includeZero || b.avg > 0))
      .map((b) => [b.name, b.avg]);
    return rankedPairs(pairs, 12, false, forceAll, chartId);
  }

  function rankedBrandBubble(M, forceAll = false, chartId = 'brand_rel') {
    const pref = getChartPref(chartId);
    let points = M.brand
      .filter((b) => Number.isFinite(b.avg) && Number.isFinite(b.value) && (pref.includeZero || (b.avg > 0 && b.value > 0)))
      .map((b) => ({ x: b.avg, y: b.value, r: Math.max(4, Math.min(20, 3 + b.n * 1.4)), brand: b.name, n: b.n }));

    points.sort((a, b) => (pref.sort === 'asc' ? a.y - b.y : b.y - a.y));
    const limit = forceAll ? 0 : pref.limit;
    if (limit > 0 && points.length > limit) points = points.slice(0, limit);
    return points;
  }

  function rankedTopProducts(M, forceAll = false, chartId = 'top_val') {
    return rankedTopProductsDetailed(M, forceAll, chartId).map((p) => [p.name, p.value]);
  }

  function rankedTopProductsDetailed(M, forceAll = false, chartId = 'top_val') {
    const pref = getChartPref(chartId);
    let items = M.top
      .filter((p) => Number.isFinite(p.value) && (pref.includeZero || p.value > 0))
      .map((p) => ({ id: p.id, name: p.name, value: p.value, stockUnitName: cleanUnitLabel(p.stockUnitName || '') }));
    items.sort((a, b) => (pref.sort === 'asc' ? a.value - b.value : b.value - a.value));
    const limit = forceAll ? 0 : pref.limit;
    if (limit > 0 && items.length > limit) items = items.slice(0, limit);
    return items;
  }

  function rankedScatterPoints(M, forceAll = false, chartId = 'price_val') {
    const pref = getChartPref(chartId);
    let points = M.points
      .filter((p) => Number.isFinite(p.x) && Number.isFinite(p.y) && (pref.includeZero || (p.x > 0 && p.y > 0)))
      .map((p) => ({ id: p.id, x: p.x, y: p.y, name: p.name, group: p.group, stockUnitName: cleanUnitLabel(p.stockUnitName || '') }));
    points.sort((a, b) => (pref.sort === 'asc' ? a.y - b.y : b.y - a.y));
    const limit = forceAll ? 0 : pref.limit;
    if (limit > 0 && points.length > limit) points = points.slice(0, limit);
    return points;
  }

  function overlayDetailFacetType(chartIdInput = '') {
    const chartId = clean(chartIdInput || '');
    if (chartId === 'brand_price' || chartId === 'brand_rel') return 'brand';
    if (chartId === 'g_val' || chartId === 'g_qty' || chartId === 'g_cal') return 'group';
    return '';
  }

  function overlayDetailFacetLabel(chartIdInput = '', entryInput = null) {
    const chartId = clean(chartIdInput || '');
    const entry = entryInput;
    if (!entry) return '';
    if (chartId === 'brand_rel' && entry && typeof entry === 'object' && !Array.isArray(entry)) {
      return clean(entry.brand || entry.name || '');
    }
    if (Array.isArray(entry)) return clean(entry[0] || '');
    if (entry && typeof entry === 'object') return clean(entry.label || entry.name || entry.brand || entry.group || '');
    return '';
  }

  function overlayDetailThumbForRow(rowInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const name = clean(row.name || t('default_product'));
    const pictureUrl = clean(row.pictureUrl || '');
    if (pictureUrl) {
      return `<span class="dash-detail-thumb" title="${escapeHtml(name)}"><img src="${escapeHtml(pictureUrl)}" alt=""></span>`;
    }
    const initials = name ? name.slice(0, 1).toUpperCase() : '?';
    return `<span class="dash-detail-thumb dash-detail-thumb-fallback" title="${escapeHtml(name)}">${escapeHtml(initials)}</span>`;
  }

  function overlayDetailFacetThumbsHtml(chartIdInput = '', entryInput = null, limitInput = 5) {
    const chartId = clean(chartIdInput || '');
    const facetType = overlayDetailFacetType(chartId);
    const facetValue = overlayDetailFacetLabel(chartId, entryInput);
    if (!facetType || !facetValue) return '';
    if (norm(facetValue) === norm(t('others_label')) || norm(facetValue) === norm(t('no_data'))) return '';

    const rows = hoverPreviewFacetRows(facetType, facetValue);
    if (!Array.isArray(rows) || rows.length === 0) return '';
    const metricCfg = hoverFacetMetricConfig(facetType, chartId);
    const limit = Math.max(1, Math.floor(num(limitInput)) || 5);
    const scoredRows = topRowsForFacetByMetric(rows, metricCfg, limit);
    if (!Array.isArray(scoredRows) || scoredRows.length === 0) return '';

    const thumbs = scoredRows
      .map((entry) => overlayDetailThumbForRow(entry && entry.row ? entry.row : null))
      .filter(Boolean)
      .join('');
    if (!thumbs) return '';
    return `<span class="dash-detail-thumbs" aria-hidden="true">${thumbs}</span>`;
  }

  function formatLinesForOverlay(entries, formatter, options = null) {
    if (!entries.length) return `<div class="text-muted">${escapeHtml(t('no_data'))}</div>`;
    const opts = options && typeof options === 'object' ? options : {};
    const chartId = clean(opts.chartId || '');
    const withFacetThumbs = opts.showFacetThumbs === true;
    const rows = entries.map((entry, idx) => {
      const color = COLORS[idx % COLORS.length];
      const line = escapeHtml(String(formatter(entry, idx) || ''));
      const thumbsHtml = withFacetThumbs ? overlayDetailFacetThumbsHtml(chartId, entry, 5) : '';
      return `
        <div class="dash-detail-item" data-detail-index="${idx}" tabindex="0">
          <span class="dash-detail-dot" style="background:${color}"></span>
          <span class="dash-detail-rank">${idx + 1}.</span>
          <span class="dash-detail-main">
            <span class="dash-detail-text">${line}</span>
          </span>
          ${thumbsHtml}
        </div>
      `;
    }).join('');
    return `<div class="dash-detail-list">${rows}</div>`;
  }

  function detailIndexFromElement(element) {
    if (!element || typeof element.getAttribute !== 'function') return -1;
    const index = parseInt(element.getAttribute('data-detail-index') || '-1', 10);
    return Number.isInteger(index) && index >= 0 ? index : -1;
  }

  function overlayHighlightColor(index) {
    const idx = Number.isInteger(index) ? index : -1;
    if (idx < 0) return '#0d6efd';
    const mapped = overlayLogicalToDatasetIndex(S.fullChart, idx);
    const colorIndex = mapped >= 0 ? mapped : idx;

    const base = S.overlayVisualBase;
    if (base && Number.isInteger(base.datasetLength) && colorIndex < base.datasetLength) {
      const border = Array.isArray(base.borderColor) ? clean(base.borderColor[colorIndex] || '') : clean(base.borderColor || '');
      const background = Array.isArray(base.backgroundColor) ? clean(base.backgroundColor[colorIndex] || '') : clean(base.backgroundColor || '');
      if (border) return setColorAlpha(border, 1);
      if (background) return setColorAlpha(background, 1);
    }

    const chart = S.fullChart;
    const ds = chart && chart.data && Array.isArray(chart.data.datasets) ? chart.data.datasets[0] : null;
    if (!ds) return '#0d6efd';
    const border = Array.isArray(ds.borderColor) ? clean(ds.borderColor[colorIndex] || '') : clean(ds.borderColor || '');
    const background = Array.isArray(ds.backgroundColor) ? clean(ds.backgroundColor[colorIndex] || '') : clean(ds.backgroundColor || '');
    return border ? setColorAlpha(border, 1) : (background ? setColorAlpha(background, 1) : '#0d6efd');
  }

  function clearOverlayActiveAccent(element) {
    if (!element || !element.style) return;
    element.style.removeProperty('--dash-active-color');
    element.style.removeProperty('--dash-active-color-soft');
    element.style.removeProperty('--dash-active-color-faint');
  }

  function applyOverlayActiveAccent(element, colorInput) {
    if (!element || !element.style) return;
    const color = clean(colorInput || '') || '#0d6efd';
    element.style.setProperty('--dash-active-color', setColorAlpha(color, 0.98));
    element.style.setProperty('--dash-active-color-soft', setColorAlpha(color, 0.34));
    element.style.setProperty('--dash-active-color-faint', setColorAlpha(color, 0.2));
  }

  function setOverlayDetailActive(index) {
    const root = document.getElementById('dash_chart_overlay_details');
    if (!root) return;

    Array.from(root.querySelectorAll('.dash-detail-item.is-active')).forEach((item) => {
      item.classList.remove('is-active');
      clearOverlayActiveAccent(item);
    });

    if (!Number.isInteger(index) || index < 0) return;
    const active = root.querySelector(`.dash-detail-item[data-detail-index="${index}"]`);
    if (active) {
      active.classList.add('is-active');
      applyOverlayActiveAccent(active, overlayHighlightColor(index));
    }
  }

  function setOverlayLegendActive(index) {
    const root = document.getElementById('dash_chart_overlay_legend');
    if (!root) return;

    Array.from(root.querySelectorAll('.dash-overlay-legend-item.is-active')).forEach((item) => {
      item.classList.remove('is-active');
      clearOverlayActiveAccent(item);
    });

    if (!Number.isInteger(index) || index < 0) return;
    const active = root.querySelector(`.dash-overlay-legend-item[data-detail-index="${index}"]`);
    if (active) {
      active.classList.add('is-active');
      applyOverlayActiveAccent(active, overlayHighlightColor(index));
    }
  }

  function setOverlayInsightActive(index) {
    const root = document.getElementById('dash_chart_overlay_takeaways');
    if (!root) return;

    Array.from(root.querySelectorAll('.dash-overlay-insight-item.is-active')).forEach((item) => {
      item.classList.remove('is-active');
      clearOverlayActiveAccent(item);
    });

    if (!Number.isInteger(index) || index < 0) return;
    const active = root.querySelector(`.dash-overlay-insight-item[data-detail-index="${index}"]`);
    if (active) {
      active.classList.add('is-active');
      applyOverlayActiveAccent(active, overlayHighlightColor(index));
    }
  }

  function updateOverlayChartNow(chart) {
    if (!chart || typeof chart.update !== 'function') return;
    try {
      chart.update('none');
    } catch (_err) {
      try { chart.update(0); } catch (_err2) {}
    }
  }

  function setColorAlpha(color, alpha) {
    const normalizedAlpha = clamp(num(alpha), 0.02, 1);
    const text = clean(color || '');
    if (!text) return `rgba(108, 117, 125, ${normalizedAlpha})`;

    const rgba = text.match(/^rgba?\(([^)]+)\)$/i);
    if (rgba) {
      const parts = rgba[1].split(',').map((p) => p.trim());
      if (parts.length >= 3) {
        return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${normalizedAlpha})`;
      }
    }

    const hex = text.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
    if (hex) {
      let raw = hex[1];
      if (raw.length === 3) raw = raw.split('').map((x) => `${x}${x}`).join('');
      const value = parseInt(raw, 16);
      const r = (value >> 16) & 255;
      const g = (value >> 8) & 255;
      const b = value & 255;
      return `rgba(${r}, ${g}, ${b}, ${normalizedAlpha})`;
    }

    return text;
  }

  function normalizeOverlayVisualArray(source, length, fallback = '') {
    if (length <= 0) return [];
    if (Array.isArray(source)) {
      if (source.length === 0) return Array.from({ length }, () => fallback);
      return Array.from({ length }, (_unused, idx) => source[idx % source.length] || fallback);
    }
    const value = clean(source || '') || fallback;
    return Array.from({ length }, () => value);
  }

  function normalizeOverlayNumberArray(source, length, fallback = 1) {
    if (length <= 0) return [];
    if (Array.isArray(source)) {
      if (source.length === 0) return Array.from({ length }, () => fallback);
      return Array.from({ length }, (_unused, idx) => {
        const n = num(source[idx % source.length]);
        return n > 0 ? n : fallback;
      });
    }
    const n = num(source);
    const value = n > 0 ? n : fallback;
    return Array.from({ length }, () => value);
  }

  function chartElementProp(element, key, fallback = null) {
    if (!element) return fallback;
    try {
      if (typeof element.getProps === 'function') {
        const props = element.getProps([key], true);
        if (props && props[key] !== undefined) return props[key];
      }
    } catch (_err) {}
    if (element[key] !== undefined) return element[key];
    const model = element._model || element._view || element._options || null;
    if (model && model[key] !== undefined) return model[key];
    return fallback;
  }

  function overlayElementGeometry(chart, index) {
    if (!chart || !Number.isInteger(index) || index < 0 || typeof chart.getDatasetMeta !== 'function') return null;
    const meta = chart.getDatasetMeta(0);
    const elements = meta && Array.isArray(meta.data) ? meta.data : [];
    if (index >= elements.length) return null;
    const element = elements[index];
    if (!element) return null;

    const type = clean(chart && chart.config && chart.config.type ? chart.config.type : '');
    if (type === 'doughnut' || type === 'pie' || type === 'polarArea') {
      const x = num(chartElementProp(element, 'x'));
      const y = num(chartElementProp(element, 'y'));
      const innerRadius = Math.max(0, num(chartElementProp(element, 'innerRadius')));
      const outerRadius = Math.max(0, num(chartElementProp(element, 'outerRadius')));
      const startAngle = num(chartElementProp(element, 'startAngle'));
      const endAngle = num(chartElementProp(element, 'endAngle'));
      if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(startAngle) || !Number.isFinite(endAngle) || outerRadius <= 0) return null;
      return { kind: 'arc', x, y, innerRadius, outerRadius, startAngle, endAngle };
    }

    if (type === 'bubble' || type === 'scatter') {
      const x = num(chartElementProp(element, 'x'));
      const y = num(chartElementProp(element, 'y'));
      const optionRadius = num(chartElementProp(element, 'radius'));
      const ds = chart && chart.data && chart.data.datasets ? chart.data.datasets[0] : null;
      let radius = optionRadius;
      if (!(radius > 0) && ds) {
        const fromDs = Array.isArray(ds.pointRadius) ? num(ds.pointRadius[index]) : num(ds.pointRadius);
        if (fromDs > 0) radius = fromDs;
      }
      if (!(radius > 0)) radius = 4;
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { kind: 'point', x, y, radius };
    }

    const x = num(chartElementProp(element, 'x'));
    const y = num(chartElementProp(element, 'y'));
    const base = num(chartElementProp(element, 'base'));
    const width = Math.max(1, num(chartElementProp(element, 'width')));
    const height = Math.max(1, num(chartElementProp(element, 'height')));
    if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(base)) return null;

    const indexAxis = clean(chart && chart.options && chart.options.indexAxis ? chart.options.indexAxis : '');
    const horizontal = indexAxis === 'y' || type === 'horizontalBar';
    if (horizontal) {
      const left = Math.min(x, base);
      const top = y - (height / 2);
      return { kind: 'rect', x: left, y: top, w: Math.max(2, Math.abs(x - base)), h: Math.max(2, height) };
    }
    const left = x - (width / 2);
    const top = Math.min(y, base);
    return { kind: 'rect', x: left, y: top, w: Math.max(2, width), h: Math.max(2, Math.abs(base - y)) };
  }

  function pathRoundedRect(ctx, x, y, w, h, radius = 6) {
    const r = Math.max(0, Math.min(num(radius), Math.abs(w) / 2, Math.abs(h) / 2));
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function drawOverlayChartActiveOutline(chart, index, colorInput = '') {
    const geometry = overlayElementGeometry(chart, index);
    if (!geometry || !chart || !chart.ctx) return;

    const color = clean(colorInput || '') || overlayHighlightColor(index) || '#0d6efd';
    const stroke = setColorAlpha(color, 0.98);
    const glow = setColorAlpha(color, 0.58);
    const fill = setColorAlpha(color, 0.16);
    const ctx = chart.ctx;

    ctx.save();
    ctx.strokeStyle = stroke;
    ctx.shadowColor = glow;
    ctx.shadowBlur = 14;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    if (geometry.kind === 'arc') {
      const outer = Math.max(geometry.outerRadius + 6, 4);
      const inner = Math.max(geometry.innerRadius - 6, 0);
      ctx.lineWidth = 3.4;
      ctx.beginPath();
      ctx.arc(geometry.x, geometry.y, outer, geometry.startAngle, geometry.endAngle);
      if (inner > 0) {
        ctx.arc(geometry.x, geometry.y, inner, geometry.endAngle, geometry.startAngle, true);
      } else {
        ctx.lineTo(geometry.x, geometry.y);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.restore();
      return;
    }

    if (geometry.kind === 'point') {
      ctx.lineWidth = 3.4;
      ctx.beginPath();
      ctx.arc(geometry.x, geometry.y, geometry.radius + 7, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.fillStyle = fill;
      ctx.beginPath();
      ctx.arc(geometry.x, geometry.y, geometry.radius + 5.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      return;
    }

    const pad = 5;
    const x = geometry.x - pad;
    const y = geometry.y - pad;
    const w = geometry.w + pad * 2;
    const h = geometry.h + pad * 2;
    ctx.lineWidth = 3.4;
    pathRoundedRect(ctx, x, y, w, h, 8);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.fillStyle = fill;
    pathRoundedRect(ctx, x + 1.2, y + 1.2, Math.max(2, w - 2.4), Math.max(2, h - 2.4), 7);
    ctx.fill();
    ctx.restore();
  }

  function captureOverlayChartVisualBase(chart) {
    const ds = chart && chart.data && Array.isArray(chart.data.datasets) ? chart.data.datasets[0] : null;
    const length = ds && Array.isArray(ds.data) ? ds.data.length : 0;
    if (!ds || length <= 0) {
      S.overlayVisualBase = null;
      return;
    }

    const chartType = clean(chart && chart.config && chart.config.type ? chart.config.type : '');
    const isCircular = chartType === 'doughnut' || chartType === 'pie' || chartType === 'polarArea';
    S.overlayVisualBase = {
      datasetLength: length,
      chartType,
      isCircular,
      backgroundColor: normalizeOverlayVisualArray(ds.backgroundColor, length, 'rgba(13,110,253,0.6)'),
      borderColor: normalizeOverlayVisualArray(ds.borderColor, length, 'rgba(13,110,253,0.95)'),
      borderWidth: normalizeOverlayNumberArray(ds.borderWidth, length, 1),
      pointRadius: normalizeOverlayNumberArray(ds.pointRadius, length, 3),
      pointHoverRadius: normalizeOverlayNumberArray(ds.pointHoverRadius, length, 5),
      hasPointRadius: Object.prototype.hasOwnProperty.call(ds, 'pointRadius'),
      hoverOffset: normalizeOverlayNumberArray(ds.hoverOffset, length, 0),
      hasHoverOffset: Object.prototype.hasOwnProperty.call(ds, 'hoverOffset'),
      offset: normalizeOverlayNumberArray(ds.offset, length, 0),
      hasOffset: Object.prototype.hasOwnProperty.call(ds, 'offset'),
    };
  }

  function overlayDatasetLength(chart) {
    const ds = chart && chart.data && Array.isArray(chart.data.datasets) ? chart.data.datasets[0] : null;
    if (ds && Array.isArray(ds.data)) return ds.data.length;
    if (typeof chart?.getDatasetMeta === 'function') {
      try {
        const meta = chart.getDatasetMeta(0);
        const data = meta && Array.isArray(meta.data) ? meta.data : [];
        return data.length;
      } catch (_err) {}
    }
    return 0;
  }

  function overlayIsHorizontalReversed(chart) {
    if (!chart || typeof chart.getDatasetMeta !== 'function') return false;
    const type = clean(chart?.config?.type || '');
    const indexAxis = clean(chart?.options?.indexAxis || '');
    const horizontal = type === 'horizontalBar' || indexAxis === 'y';
    if (!horizontal) return false;
    const meta = chart.getDatasetMeta(0);
    const elements = meta && Array.isArray(meta.data) ? meta.data : [];
    if (elements.length < 2) return false;
    const firstY = num(chartElementProp(elements[0], 'y'));
    const lastY = num(chartElementProp(elements[elements.length - 1], 'y'));
    if (!Number.isFinite(firstY) || !Number.isFinite(lastY)) return false;
    return firstY > lastY;
  }

  function overlayLogicalToDatasetIndex(chart, logicalIndex) {
    const idx = Number.isInteger(logicalIndex) ? logicalIndex : -1;
    if (idx < 0) return -1;
    const len = overlayDatasetLength(chart);
    if (!(len > 0) || idx >= len) return idx;
    if (!overlayIsHorizontalReversed(chart)) return idx;
    return (len - 1) - idx;
  }

  function overlayDatasetToLogicalIndex(chart, datasetIndex) {
    const idx = Number.isInteger(datasetIndex) ? datasetIndex : -1;
    if (idx < 0) return -1;
    const len = overlayDatasetLength(chart);
    if (!(len > 0) || idx >= len) return idx;
    if (!overlayIsHorizontalReversed(chart)) return idx;
    return (len - 1) - idx;
  }

  function applyOverlayChartVisualHighlight(index) {
    const chart = S.fullChart;
    const ds = chart && chart.data && Array.isArray(chart.data.datasets) ? chart.data.datasets[0] : null;
    const base = S.overlayVisualBase;
    if (!chart || !ds || !base || !Number.isInteger(base.datasetLength) || base.datasetLength <= 0) return;

    const length = base.datasetLength;
    const active = Number.isInteger(index) && index >= 0 && index < length;
    // Always start from base visual to keep the chart stable and avoid hover jitter.
    ds.backgroundColor = [...base.backgroundColor];
    ds.borderColor = [...base.borderColor];
    ds.borderWidth = [...base.borderWidth];
    if (base.hasPointRadius) {
      ds.pointRadius = [...base.pointRadius];
      ds.pointHoverRadius = [...base.pointHoverRadius];
    }
    if (base.hasHoverOffset) {
      ds.hoverOffset = [...base.hoverOffset];
    }
    if (base.hasOffset) {
      ds.offset = [...base.offset];
    }

    ds.hidden = false;
    if (typeof chart.getDatasetMeta === 'function') {
      try {
        const meta = chart.getDatasetMeta(0);
        if (meta) meta.hidden = false;
      } catch (_err) {}
    }

    if (active) {
      const activeAlpha = base.isCircular ? 0.98 : 0.96;
      const inactiveAlpha = base.isCircular ? 0.2 : 0.16;
      const inactiveBorderAlpha = 0.22;
      ds.backgroundColor = base.backgroundColor.map((c, idx) => (
        idx === index ? setColorAlpha(c, activeAlpha) : setColorAlpha(c, inactiveAlpha)
      ));
      ds.borderColor = base.borderColor.map((c, idx) => (
        idx === index ? setColorAlpha(c, 1) : setColorAlpha(c, inactiveBorderAlpha)
      ));
      ds.borderWidth = base.borderWidth.map((w, idx) => (idx === index ? Math.max(3, num(w) + 1.4) : Math.max(1, num(w))));
      // Keep geometry identical to base (no offset/radius jump) to avoid flicker/glitch.
      if (base.hasPointRadius) {
        ds.pointRadius = [...base.pointRadius];
        ds.pointHoverRadius = [...base.pointHoverRadius];
      }
      if (base.hasHoverOffset) ds.hoverOffset = [...base.hoverOffset];
      if (base.hasOffset) ds.offset = [...base.offset];
    }

    updateOverlayChartNow(chart);
    if (active) {
      drawOverlayChartActiveOutline(chart, index, overlayHighlightColor(index));
    }
  }

  function setOverlayChartActiveIndex(index, _syncDetail = true) {
    const logicalIndex = Number.isInteger(index) && index >= 0 ? index : -1;
    const changed = logicalIndex !== S.overlayActiveIndex;
    S.overlayActiveIndex = logicalIndex;
    setOverlayDetailActive(logicalIndex);
    setOverlayLegendActive(logicalIndex);
    setOverlayInsightActive(logicalIndex);
    if (S.fullChartId) {
      if (logicalIndex >= 0) {
        S.overlayActiveIndexByChart[S.fullChartId] = logicalIndex;
      } else if (Object.prototype.hasOwnProperty.call(S.overlayActiveIndexByChart, S.fullChartId)) {
        delete S.overlayActiveIndexByChart[S.fullChartId];
      }
      scheduleUiStateSave();
    }
    const datasetIndex = logicalIndex >= 0 ? overlayLogicalToDatasetIndex(S.fullChart, logicalIndex) : -1;
    if (changed || logicalIndex === -1) applyOverlayChartVisualHighlight(datasetIndex);
  }

  function clearOverlayChartActiveIndex() {
    setOverlayChartActiveIndex(-1, true);
  }

  function escapeHtml(value) {
    return (value || '').toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function stockFacetLinkHtml(type, value, label, extraClass = '') {
    const facetType = normalizeFacetType(type);
    const facetValue = clean(value || '');
    const facetLabel = clean(label || facetValue);
    if (!facetType || !facetValue || !facetLabel) return '';
    const cls = `dash-stock-facet-link ${clean(extraClass)}`.trim();
    let icon = '';
    if (facetType === 'brand') icon = brandLogoIconHtml(facetValue);
    if (facetType === 'group') icon = groupLogoIconHtml(facetValue);
    return `<button type="button" class="${escapeHtml(cls)}" data-facet-type="${escapeHtml(facetType)}" data-facet-value="${escapeHtml(facetValue)}">${icon}<span class="dash-stock-facet-label">${escapeHtml(facetLabel)}</span></button>`;
  }

  function stockFacetFromElement(element) {
    if (!element || typeof element.getAttribute !== 'function') return null;
    const type = normalizeFacetType(element.getAttribute('data-facet-type') || '');
    const value = clean(element.getAttribute('data-facet-value') || '');
    if (!type || !value) return null;
    return { type, value };
  }

  function handleStockFacetElementClick(target, event) {
    if (!target || typeof target.closest !== 'function') return false;
    const facetElement = target.closest('.dash-stock-facet-link');
    if (!facetElement) return false;
    const facet = stockFacetFromElement(facetElement);
    if (!facet) return false;
    if (event) event.preventDefault();
    openStockFacetView(facet.type, facet.value);
    return true;
  }

  function linesToHtml(lines, emptyText = t('no_info_available')) {
    if (!Array.isArray(lines) || lines.length === 0) {
      return `<div class="text-muted">${escapeHtml(emptyText)}</div>`;
    }
    return `<ul class="mb-0 pl-3">${lines.map((line) => `<li>${escapeHtml(line)}</li>`).join('')}</ul>`;
  }

  function overlayColorAt(colorSource, index) {
    if (Array.isArray(colorSource)) {
      if (colorSource.length === 0) return '#6c757d';
      return colorSource[index % colorSource.length] || '#6c757d';
    }
    if (typeof colorSource === 'string' && colorSource.trim()) return colorSource;
    return '#6c757d';
  }

  function overlayValueLabel(chartId, value) {
    const n = num(value);
    if (chartId === 'risk' || chartId === 'due') return fmtProducts(n);
    if (chartId === 'g_cal') return fmtKcal(n);
    if (chartId === 'g_qty') return fmtQtyWithCurrentMode(n);
    if (chartId === 'brand_price') return `${t('metric_avg_price_prefix')} ${fmtMoney(n)}`;
    if (chartId === 'g_val' || chartId === 'top_val') return `${t('metric_value_prefix')} ${fmtMoney(n)}`;
    return fmt(n, 2);
  }

  function buildOverlayLegendItems(chartId, cfg) {
    const data = cfg && cfg.data ? cfg.data : {};
    const ds = data && Array.isArray(data.datasets) ? data.datasets[0] : null;
    if (!ds) return [];

    const points = Array.isArray(ds.data) ? ds.data : [];
    const labels = Array.isArray(data.labels) ? data.labels : [];
    const fullLabels = Array.isArray(ds.full) ? ds.full : [];
    const usableLabels = fullLabels.length === points.length ? fullLabels : labels;
    const items = [];

    if (chartId === 'brand_rel') {
      points.forEach((p, idx) => {
        if (!p || typeof p !== 'object') return;
        items.push({
          label: clean(p.brand || p.name || `${t('default_brand')} ${idx + 1}`),
          value: `${t('metric_price_prefix')} ${fmtMoney(num(p.x))} | ${t('metric_value_prefix')} ${fmtMoney(num(p.y))} | ${fmtProducts(num(p.n))}`,
          color: overlayColorAt(ds.backgroundColor, idx),
        });
      });
      return items;
    }

    if (chartId === 'price_val') {
      points.forEach((p, idx) => {
        if (!p || typeof p !== 'object') return;
        const groupPart = clean(p.group) ? ` | ${t('metric_group_prefix')} ${clean(p.group)}` : '';
        items.push({
          label: clean(p.name || `${t('default_product')} ${idx + 1}`),
          value: `${t('metric_price_prefix')} ${fmtMoney(num(p.x))} | ${t('metric_value_prefix')} ${fmtMoney(num(p.y))}${groupPart}`,
          color: overlayColorAt(ds.backgroundColor, idx),
        });
      });
      return items;
    }

    points.forEach((raw, idx) => {
      const label = clean(usableLabels[idx] || `${clean(ds.label || t('default_item'))} ${idx + 1}`);
      const value = (raw && typeof raw === 'object') ? (raw.y ?? raw.value ?? raw.x ?? 0) : raw;
      items.push({
        label,
        value: overlayValueLabel(chartId, value),
        color: overlayColorAt(ds.backgroundColor, idx),
      });
    });
    return items;
  }

  function renderOverlayLegend(chartId, cfg) {
    const container = document.getElementById('dash_chart_overlay_legend');
    if (!container) return;
    container.innerHTML = '';

    const items = buildOverlayLegendItems(chartId, cfg);
    if (!items.length) {
      container.innerHTML = `<div class="text-muted">${escapeHtml(t('no_data'))}</div>`;
      return;
    }

    const fragment = document.createDocumentFragment();
    items.forEach((item, idx) => {
      const row = document.createElement('div');
      row.className = 'dash-overlay-legend-item';
      row.setAttribute('data-detail-index', String(idx));
      row.setAttribute('tabindex', '0');

      const dot = document.createElement('span');
      dot.className = 'dash-overlay-legend-dot';
      dot.style.background = item.color || '#6c757d';
      dot.style.border = '1px solid rgba(255,255,255,0.28)';

      const text = document.createElement('div');
      text.className = 'dash-overlay-legend-main';
      const label = document.createElement('div');
      label.textContent = item.label || t('default_item');
      const value = document.createElement('div');
      value.className = 'dash-overlay-legend-value';
      value.textContent = item.value || '';

      text.appendChild(label);
      text.appendChild(value);
      row.appendChild(dot);
      row.appendChild(text);
      fragment.appendChild(row);
    });

    container.appendChild(fragment);
  }

  function narrativeLine(text, index = -1) {
    return {
      text: clean(text || ''),
      index: Number.isInteger(index) && index >= 0 ? index : -1,
    };
  }

  function narrativeLineText(line) {
    if (line && typeof line === 'object') return clean(line.text || line.label || '');
    return clean(line || '');
  }

  function narrativeLineIndex(line) {
    if (line && typeof line === 'object' && Number.isInteger(line.index) && line.index >= 0) return line.index;
    return -1;
  }

  function overlayTakeawaysToHtml(lines, emptyText = t('no_info_available')) {
    const rows = (Array.isArray(lines) ? lines : [])
      .map((line) => {
        const text = narrativeLineText(line);
        const index = narrativeLineIndex(line);
        if (!text) return '';
        const indexed = index >= 0;
        const attr = indexed ? ` data-detail-index="${index}" tabindex="0"` : '';
        return `
          <div class="dash-overlay-insight-item"${attr}>
            <span class="dash-overlay-insight-bullet">&#8226;</span>
            <span class="dash-overlay-insight-text">${escapeHtml(text)}</span>
          </div>
        `;
      })
      .filter(Boolean);

    if (!rows.length) {
      return `<div class="text-muted">${escapeHtml(emptyText)}</div>`;
    }
    return `<div class="dash-overlay-insight-list">${rows.join('')}</div>`;
  }

  function buildOverlayNarrative(chartId, M, contextData) {
    const explain = [];
    const takeaways = [];
    const en = resolveUiLanguage() === 'en';

    if (chartId === 'g_val') {
      const entries = Array.isArray(contextData) ? contextData : [];
      const total = entries.reduce((sum, e) => sum + num(e[1]), 0);
      const top = entries[0];
      const top3 = entries.slice(0, 3).reduce((sum, e) => sum + num(e[1]), 0);
      explain.push(en
        ? 'Each bar represents the value locked per group (higher bar = stronger budget weight).'
        : 'Chaque barre représente la valeur immobilisée par groupe (plus la barre est haute, plus le groupe pèse dans le budget stock).');
      explain.push(en
        ? 'Use this chart to see whether your budget is concentrated on a few groups or spread out.'
        : 'Utilise ce graphe pour voir si ton budget est concentré sur peu de groupes ou bien réparti.');
      if (top && total > 0) {
        takeaways.push(narrativeLine((en
          ? `Dominant group: ${top[0]} with ${fmtMoney(top[1])} (${fmtPercent((num(top[1]) / total) * 100)}).`
          : `Groupe dominant: ${top[0]} avec ${fmtMoney(top[1])} (${fmtPercent((num(top[1]) / total) * 100)}).`), entries.indexOf(top)));
      }
      if (total > 0 && entries.length >= 3) {
        takeaways.push(en
          ? `Top 3 groups account for ${fmtPercent((top3 / total) * 100)} of total value.`
          : `Les 3 premiers groupes cumulent ${fmtPercent((top3 / total) * 100)} de la valeur totale.`);
      }
    } else if (chartId === 'g_qty') {
      const entries = Array.isArray(contextData) ? contextData : [];
      const total = entries.reduce((sum, e) => sum + num(e[1]), 0);
      const top = entries[0];
      const qtyState = S.lastGroupQtyState && typeof S.lastGroupQtyState === 'object' ? S.lastGroupQtyState : null;
      explain.push(en
        ? 'Each bar shows total available quantity by group.'
        : 'Chaque barre montre la quantité totale disponible par groupe.');
      explain.push(en
        ? 'Comparing this chart with "Value by group" reveals bulky but low-cost groups.'
        : 'Comparer ce graphe avec "Valeur par groupe" permet de détecter les groupes volumineux mais peu coûteux.');
      if (qtyState && qtyState.unitBadgeText) {
        explain.push(en
          ? `Active quantity scope: ${qtyState.unitBadgeText}.`
          : `Périmètre quantité actif: ${qtyState.unitBadgeText}.`);
      }
      if (top && total > 0) {
        takeaways.push(narrativeLine((en
          ? `Largest-volume group: ${top[0]} with ${fmtQtyByChart('g_qty', top[1])} (${fmtPercent((num(top[1]) / total) * 100)}).`
          : `Groupe le plus volumineux: ${top[0]} avec ${fmtQtyByChart('g_qty', top[1])} (${fmtPercent((num(top[1]) / total) * 100)}).`), entries.indexOf(top)));
      }
      if (qtyState && Array.isArray(qtyState.unclassified) && qtyState.unclassified.length > 0) {
        takeaways.push(en
          ? `${fmtProducts(qtyState.unclassified.length)} are not classifiable in this unit mode.`
          : `${fmtProducts(qtyState.unclassified.length)} ne sont pas classables dans ce mode d’unité.`);
      }
    } else if (chartId === 'risk') {
      const entries = Array.isArray(contextData) ? contextData : [];
      const total = entries.reduce((sum, e) => sum + num(e[1]), 0);
      const top = [...entries].sort((a, b) => num(b[1]) - num(a[1]))[0];
      explain.push(en
        ? 'This donut splits stock alerts: below stock, due soon, overdue and expired.'
        : 'Ce donut ventile les alertes stock: sous-stock, proche date, retard et expiré.');
      explain.push(en
        ? 'The larger a section is, the higher its operational priority.'
        : 'Plus une section est grande, plus cette catégorie doit être traitée en priorité.');
      if (total > 0 && top) {
        takeaways.push(narrativeLine((en
          ? `Priority alert: ${top[0]} (${fmtProducts(top[1])}, ${fmtPercent((num(top[1]) / total) * 100)} of alerts).`
          : `Alerte prioritaire: ${top[0]} (${fmtProducts(top[1])}, ${fmtPercent((num(top[1]) / total) * 100)} des alertes).`), entries.indexOf(top)));
      } else {
        takeaways.push(en ? 'No alert in the current view.' : 'Aucune alerte en cours sur la vue actuelle.');
      }
    } else if (chartId === 'due') {
      const entries = Array.isArray(contextData) ? contextData : [];
      const total = entries.reduce((sum, e) => sum + num(e[1]), 0);
      const map = new Map(entries.map((e) => [clean(e[0]), num(e[1])]));
      const late = map.get(clean(t('due_over'))) || 0;
      const nodate = map.get(clean(t('due_none'))) || 0;
      const lateIndex = entries.findIndex((e) => clean(e[0]) === clean(t('due_over')));
      const nodateIndex = entries.findIndex((e) => clean(e[0]) === clean(t('due_none')));
      explain.push(en
        ? 'This chart distributes products by due horizon (overdue, short, medium, long term).'
        : 'Ce graphe répartit les produits selon leur échéance (dépassé, court terme, moyen terme, long terme).');
      explain.push(en
        ? 'Use it to plan actions: consume first, donate, or adjust purchases.'
        : 'Il sert à anticiper les actions: priorité consommation, dons, ou ajustement des achats.');
      if (total > 0) {
        takeaways.push(narrativeLine((en
          ? `Overdue products: ${fmtProducts(late)} (${fmtPercent((late / total) * 100)} of the view).`
          : `Produits dépassés: ${fmtProducts(late)} (${fmtPercent((late / total) * 100)} de la vue).`), lateIndex));
        takeaways.push(narrativeLine((en
          ? `Products without date: ${fmtProducts(nodate)} (${fmtPercent((nodate / total) * 100)}).`
          : `Produits sans date: ${fmtProducts(nodate)} (${fmtPercent((nodate / total) * 100)}).`), nodateIndex));
      }
    } else if (chartId === 'brand_price') {
      const entries = Array.isArray(contextData) ? contextData : [];
      const high = [...entries].sort((a, b) => num(b[1]) - num(a[1]))[0];
      const low = [...entries].sort((a, b) => num(a[1]) - num(b[1]))[0];
      explain.push(en
        ? 'Each bar compares average unit price by brand.'
        : 'Chaque barre compare le prix unitaire moyen par marque.');
      explain.push(en
        ? 'This quickly highlights premium brands and cheaper alternatives.'
        : 'Il permet de détecter rapidement les marques premium et les alternatives économiques.');
      if (high && low) {
        takeaways.push(narrativeLine((en ? `Most expensive brand: ${high[0]} (${fmtMoney(high[1])}).` : `Marque la plus chère: ${high[0]} (${fmtMoney(high[1])}).`), entries.indexOf(high)));
        takeaways.push(narrativeLine((en ? `Least expensive brand: ${low[0]} (${fmtMoney(low[1])}).` : `Marque la moins chère: ${low[0]} (${fmtMoney(low[1])}).`), entries.indexOf(low)));
      }
    } else if (chartId === 'brand_rel') {
      const points = Array.isArray(contextData) ? contextData : [];
      const topValue = [...points].sort((a, b) => num(b.y) - num(a.y))[0];
      const topPrice = [...points].sort((a, b) => num(b.x) - num(a.x))[0];
      explain.push(en
        ? 'Each bubble is a brand: X = average price, Y = stock value, size = product count.'
        : 'Chaque bulle représente une marque: X = prix moyen, Y = valeur stock, taille = nombre de produits.');
      explain.push(en
        ? 'Top-right bubbles deserve review: expensive and heavily immobilized.'
        : 'Les bulles en haut à droite méritent une revue: chères et fortement immobilisées.');
      if (topValue) takeaways.push(narrativeLine((en
        ? `Brand with highest stock value: ${topValue.brand} (${fmtMoney(topValue.y)}).`
        : `Marque avec plus forte valeur stock: ${topValue.brand} (${fmtMoney(topValue.y)}).`), points.indexOf(topValue)));
      if (topPrice) takeaways.push(narrativeLine((en
        ? `Brand with highest average price: ${topPrice.brand} (${fmtMoney(topPrice.x)}).`
        : `Marque au prix moyen le plus élevé: ${topPrice.brand} (${fmtMoney(topPrice.x)}).`), points.indexOf(topPrice)));
    } else if (chartId === 'top_val') {
      const entries = Array.isArray(contextData) ? contextData : [];
      const values = entries.map((e) => (Array.isArray(e) ? { name: e[0], value: num(e[1]) } : { name: e.name, value: num(e.value) }));
      const total = values.reduce((sum, e) => sum + num(e.value), 0);
      const first = values[0];
      const top5 = values.slice(0, 5).reduce((sum, e) => sum + num(e.value), 0);
      explain.push(en
        ? 'Ranking of products that lock the most stock value.'
        : 'Classement des produits qui immobilisent le plus de valeur en stock.');
      explain.push(en
        ? 'Clicking a product opens its product card for quick action.'
        : 'Un clic sur un produit ouvre sa fiche produit pour action rapide.');
      if (first && total > 0) takeaways.push(narrativeLine((en
        ? `Highest locked product: ${first.name} (${fmtMoney(first.value)}).`
        : `Produit le plus immobilisant: ${first.name} (${fmtMoney(first.value)}).`), 0));
      if (total > 0 && values.length >= 5) takeaways.push(en
        ? `Top 5 = ${fmtPercent((top5 / total) * 100)} of this chart value.`
        : `Top 5 = ${fmtPercent((top5 / total) * 100)} de la valeur de ce graphe.`);
    } else if (chartId === 'price_val') {
      const points = Array.isArray(contextData) ? contextData : [];
      const heavy = [...points].sort((a, b) => num(b.y) - num(a.y))[0];
      const costly = [...points].sort((a, b) => num(b.x) - num(a.x))[0];
      const critical = [...points].sort((a, b) => (num(b.x) * num(b.y)) - (num(a.x) * num(a.y)))[0];
      explain.push(en
        ? 'Each point = one product (X unit price, Y locked value).'
        : 'Chaque point = un produit (X prix unitaire, Y valeur immobilisée).');
      explain.push(en
        ? 'Top-right points are the most sensitive for budget/rotation optimization.'
        : 'Les points en haut à droite sont les plus sensibles pour l’optimisation budget/rotation.');
      if (heavy) takeaways.push(narrativeLine((en
        ? `Highest locked value: ${heavy.name} (${fmtMoney(heavy.y)}).`
        : `Plus forte valeur immobilisée: ${heavy.name} (${fmtMoney(heavy.y)}).`), points.indexOf(heavy)));
      if (costly) takeaways.push(narrativeLine((en
        ? `Highest unit price: ${costly.name} (${fmtMoney(costly.x)}).`
        : `Prix unitaire le plus élevé: ${costly.name} (${fmtMoney(costly.x)}).`), points.indexOf(costly)));
      if (critical) takeaways.push(narrativeLine((en ? `Critical price*value point: ${critical.name}.` : `Point critique prix*valeur: ${critical.name}.`), points.indexOf(critical)));
    } else if (chartId === 'g_cal') {
      const entries = Array.isArray(contextData) ? contextData : [];
      const total = entries.reduce((sum, e) => sum + num(e[1]), 0);
      const top = entries[0];
      explain.push(en
        ? 'Total calorie distribution by product group.'
        : 'Répartition calorique totale par groupe de produits.');
      explain.push(en
        ? 'Tracks the global nutritional impact of stock, not only quantities.'
        : 'Permet de suivre l’impact nutritionnel global du stock, pas seulement les quantités.');
      if (top && total > 0) {
        takeaways.push(narrativeLine((en
          ? `Dominant calorie group: ${top[0]} (${fmtKcal(top[1])}, ${fmtPercent((num(top[1]) / total) * 100)}).`
          : `Groupe calorique dominant: ${top[0]} (${fmtKcal(top[1])}, ${fmtPercent((num(top[1]) / total) * 100)}).`), entries.indexOf(top)));
      }
      const calFun = calorieFunSummaryText(total, 2);
      if (calFun) {
        takeaways.push(en
          ? `Fun calorie comparison: ${calFun}.`
          : `Comparaison calories: ${calFun}.`);
      }
    } else {
      explain.push(en
        ? 'Chart reading rule: the higher the value, the higher the impact.'
        : 'Lecture du graphe: plus une valeur monte, plus son impact est important.');
      takeaways.push(en ? `Visible products: ${fmtProducts(M ? M.n : 0)}.` : `Produits visibles: ${fmtProducts(M ? M.n : 0)}.`);
    }

    if (takeaways.length === 0) {
      takeaways.push(en ? 'No strong takeaway detected in the current view.' : 'Aucune conclusion forte détectée sur la vue actuelle.');
    }

    return { explain, takeaways };
  }

  function renderOverlayNarrative(chartId, M, contextData) {
    const explainEl = document.getElementById('dash_chart_overlay_explain');
    const takeawaysEl = document.getElementById('dash_chart_overlay_takeaways');
    if (!explainEl || !takeawaysEl) return;

    const narrative = buildOverlayNarrative(chartId, M, contextData);
    explainEl.innerHTML = linesToHtml((narrative.explain || []).map((line) => narrativeLineText(line)).filter(Boolean));
    takeawaysEl.innerHTML = overlayTakeawaysToHtml(narrative.takeaways);
  }

  function dueDateDisplayFormat(settingsInput = null) {
    const settings = normalizeAiSettings(settingsInput || aiSettings());
    return normalizeDueDateDisplayFormat(settings.dueDateDisplayFormat || 'auto');
  }

  function formatDueDate(date, settingsInput = null) {
    const d = normalizeDueDateValue(date);
    if (!d) return t('due_none');
    const mode = dueDateDisplayFormat(settingsInput);
    if (mode === 'ymd') {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    }
    const locale = mode === 'dmy'
      ? 'fr-FR'
      : (mode === 'mdy' ? 'en-US' : (resolveUiLanguage(settingsInput || aiSettings()) === 'en' ? 'en-US' : 'fr-FR'));
    return d.toLocaleDateString(locale, { year: 'numeric', month: '2-digit', day: '2-digit' });
  }

  function dueDeltaSpanText(diffInput = 0) {
    const abs = Math.abs(Math.floor(num(diffInput)));
    let count = abs;
    let unit = langText(abs <= 1 ? 'jour' : 'jours', abs === 1 ? 'day' : 'days');
    if (abs > 365) {
      count = Math.max(1, Math.round(abs / 365));
      unit = langText(count <= 1 ? 'an' : 'ans', count === 1 ? 'year' : 'years');
    } else if (abs > 30) {
      count = Math.max(1, Math.round(abs / 30));
      unit = langText('mois', count === 1 ? 'month' : 'months');
    } else if (abs > 7) {
      count = Math.max(1, Math.round(abs / 7));
      unit = langText(count <= 1 ? 'semaine' : 'semaines', count === 1 ? 'week' : 'weeks');
    }
    return `${fmt(count, 0)} ${unit}`;
  }

  function formatDueDateWithRelative(date, settingsInput = null) {
    const d = normalizeDueDateValue(date);
    if (!d) return t('due_none');
    const base = formatDueDate(d, settingsInput);
    const diff = dueDiffDays(d);
    if (!Number.isFinite(diff)) return base;
    if (diff === 0) return `${base} (${t('due_today')})`;
    if (diff < 0) return `${base} (${t('due_over_by_span', { span: dueDeltaSpanText(diff) })})`;
    return `${base} (${t('due_in_span', { span: dueDeltaSpanText(diff) })})`;
  }

  function ensureHoverPreviewElement() {
    let element = document.getElementById('dash_hover_preview');
    if (element) return element;
    element = document.createElement('div');
    element.id = 'dash_hover_preview';
    element.className = 'd-none';
    document.body.appendChild(element);
    return element;
  }

  function hideChartHoverPreview() {
    const element = document.getElementById('dash_hover_preview');
    if (!element) return;
    element.classList.add('d-none');
    element.innerHTML = '';
    S.hoverPreviewKey = '';
    S.hoverPreviewContextKey = '';
    S.hoverPreviewRenderToken += 1;
  }

  function hoverPreviewPointFromElement(element) {
    if (!element || typeof element.getBoundingClientRect !== 'function') return null;
    const rect = element.getBoundingClientRect();
    if (!rect) return null;
    const x = rect.left + Math.min(rect.width * 0.58, 36);
    const y = rect.top + Math.min(rect.height * 0.7, 24);
    if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
    return { x, y };
  }

  function hoverPreviewRowsSource() {
    if (Array.isArray(S.lastFilteredRows) && S.lastFilteredRows.length > 0) return S.lastFilteredRows;
    return Array.isArray(S.lastAllRows) ? S.lastAllRows : [];
  }

  function mapArrayPushUnique(map, keyInput, valueInput) {
    const key = num(keyInput);
    const value = clean(valueInput || '');
    if (key <= 0 || !value) return;
    if (!map.has(key)) map.set(key, []);
    const list = map.get(key);
    if (!Array.isArray(list)) {
      map.set(key, [value]);
      return;
    }
    if (!list.includes(value)) list.push(value);
  }

  function finalizeStringArrayMap(mapInput) {
    const map = mapInput instanceof Map ? mapInput : new Map();
    map.forEach((list, key) => {
      const sorted = (Array.isArray(list) ? list : [])
        .map((item) => clean(item || ''))
        .filter(Boolean)
        .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      map.set(key, sorted);
    });
    return map;
  }

  function updatePriceRangeMap(mapInput, productId, priceValue) {
    const map = mapInput instanceof Map ? mapInput : new Map();
    const id = num(productId);
    const price = num(priceValue);
    if (id <= 0 || price <= 0) return map;
    const current = map.get(id) || { min: 0, max: 0 };
    if (current.min <= 0 || price < current.min) current.min = price;
    if (current.max <= 0 || price > current.max) current.max = price;
    map.set(id, current);
    return map;
  }

  function updatePurchaseStatsMap(mapInput, productId, amountInput) {
    const map = mapInput instanceof Map ? mapInput : new Map();
    const id = num(productId);
    const amount = Math.abs(num(amountInput));
    if (id <= 0 || amount <= 0) return map;
    const current = map.get(id) || { amount: 0, count: 0 };
    current.amount += amount;
    current.count += 1;
    map.set(id, current);
    return map;
  }

  function recipeNameFromResolvedRow(row) {
    if (!row || typeof row !== 'object') return '';
    const direct = pickFirstString(row, ['recipe_name', 'recipeName', 'recipe']);
    if (direct) return direct;
    if (row.recipe && typeof row.recipe === 'object') {
      return pickFirstString(row.recipe, ['name', 'recipe_name']);
    }
    return '';
  }

  async function loadHoverRecipeMapFromApi() {
    const map = new Map();

    try {
      const payload = await fetchJson('api/objects/recipes_pos_resolved');
      let rows = extractArray(payload);
      if (!rows.length) {
        rows = deepCollectObjects(
          payload,
          (o) => hasAnyKey(o, ['product_id', 'productId']) && (hasAnyKey(o, ['recipe_name', 'recipeName']) || (o.recipe && typeof o.recipe === 'object'))
        );
      }
      rows.forEach((row) => {
        const productId = pickFirstNumber(row, ['product_id', 'productId']);
        const recipeName = recipeNameFromResolvedRow(row);
        mapArrayPushUnique(map, productId, recipeName);
      });
      if (map.size > 0) return finalizeStringArrayMap(map);
    } catch (error) {
      console.warn('Dashboard: impossible de charger recipes_pos_resolved', error);
    }

    try {
      const [posPayload, recipesPayload] = await Promise.all([
        fetchJson('api/objects/recipes_pos'),
        fetchJson('api/objects/recipes'),
      ]);
      let posRows = extractArray(posPayload);
      if (!posRows.length) {
        posRows = deepCollectObjects(posPayload, (o) => hasAnyKey(o, ['product_id', 'productId']) && hasAnyKey(o, ['recipe_id', 'recipeId']));
      }
      let recipeRows = extractArray(recipesPayload);
      if (!recipeRows.length) {
        recipeRows = deepCollectObjects(recipesPayload, (o) => hasAnyKey(o, ['id']) && hasAnyKey(o, ['name']));
      }
      const recipeNameById = new Map();
      recipeRows.forEach((recipe) => {
        const recipeId = pickFirstNumber(recipe, ['id', 'recipe_id', 'recipeId']);
        const recipeName = pickFirstString(recipe, ['name', 'recipe_name']);
        if (recipeId > 0 && recipeName) recipeNameById.set(recipeId, recipeName);
      });
      posRows.forEach((row) => {
        const productId = pickFirstNumber(row, ['product_id', 'productId']);
        const recipeId = pickFirstNumber(row, ['recipe_id', 'recipeId']);
        const recipeName = recipeNameById.get(recipeId) || recipeNameFromResolvedRow(row);
        mapArrayPushUnique(map, productId, recipeName);
      });
    } catch (error) {
      console.warn('Dashboard: impossible de charger recipes_pos/recipes', error);
    }

    return finalizeStringArrayMap(map);
  }

  function ensureHoverRecipeMapLoaded() {
    if (S.hoverRecipeMapLoaded) return Promise.resolve(S.hoverRecipeMapByProductId);
    if (S.hoverRecipeMapPromise) return S.hoverRecipeMapPromise;
    S.hoverRecipeMapPromise = loadHoverRecipeMapFromApi()
      .then((map) => {
        S.hoverRecipeMapByProductId = map instanceof Map ? map : new Map();
        S.hoverRecipeMapLoaded = true;
        return S.hoverRecipeMapByProductId;
      })
      .catch((error) => {
        console.warn('Dashboard: erreur chargement recettes pour survol', error);
        S.hoverRecipeMapLoaded = true;
        return S.hoverRecipeMapByProductId;
      })
      .finally(() => {
        S.hoverRecipeMapPromise = null;
      });
    return S.hoverRecipeMapPromise;
  }

  async function loadHoverPriceRangeMapFromApi() {
    const map = new Map();

    try {
      const payload = await fetchJson('api/objects/products_price_history');
      let rows = extractArray(payload);
      if (!rows.length) {
        rows = deepCollectObjects(payload, (o) => hasAnyKey(o, ['product_id', 'productId']) && hasAnyKey(o, ['price']));
      }
      rows.forEach((row) => {
        const productId = pickFirstNumber(row, ['product_id', 'productId']);
        const price = pickFirstNumber(row, ['price', 'last_price']);
        updatePriceRangeMap(map, productId, price);
      });
      if (map.size > 0) return map;
    } catch (error) {
      console.warn('Dashboard: impossible de charger products_price_history', error);
    }

    try {
      const payload = await fetchJson('api/objects/stock_log');
      let rows = extractArray(payload);
      if (!rows.length) {
        rows = deepCollectObjects(payload, (o) => hasAnyKey(o, ['product_id', 'productId']) && hasAnyKey(o, ['price']));
      }
      rows.forEach((row) => {
        const productId = pickFirstNumber(row, ['product_id', 'productId']);
        const price = pickFirstNumber(row, ['price']);
        const tx = norm(pickFirstString(row, ['transaction_type', 'transactionType']));
        if (tx.includes('consume') || tx.includes('spoil') || tx.includes('used')) return;
        updatePriceRangeMap(map, productId, price);
      });
    } catch (error) {
      console.warn('Dashboard: impossible de charger stock_log (prix)', error);
    }

    return map;
  }

  function ensureHoverPriceRangeMapLoaded() {
    if (S.hoverPriceRangeLoaded) return Promise.resolve(S.hoverPriceRangeByProductId);
    if (S.hoverPriceRangePromise) return S.hoverPriceRangePromise;
    S.hoverPriceRangePromise = loadHoverPriceRangeMapFromApi()
      .then((map) => {
        S.hoverPriceRangeByProductId = map instanceof Map ? map : new Map();
        S.hoverPriceRangeLoaded = true;
        return S.hoverPriceRangeByProductId;
      })
      .catch((error) => {
        console.warn('Dashboard: erreur chargement prix mini/maxi pour survol', error);
        S.hoverPriceRangeLoaded = true;
        return S.hoverPriceRangeByProductId;
      })
      .finally(() => {
        S.hoverPriceRangePromise = null;
      });
    return S.hoverPriceRangePromise;
  }

  function isLikelyPurchaseTransaction(row) {
    const tx = norm(pickFirstString(row, ['transaction_type', 'transactionType']));
    const amount = num(row && row.amount);
    if (amount <= 0) return false;
    if (tx) {
      if (tx.includes('consume') || tx.includes('used') || tx.includes('spoil') || tx.includes('open') || tx.includes('correction') || tx.includes('transfer')) {
        return false;
      }
      if (tx.includes('purchase') || tx.includes('stock') || tx.includes('add') || tx.includes('buy')) {
        return true;
      }
    }
    const purchasedDate = pickFirstString(row, ['purchased_date', 'purchasedDate']);
    const usedDate = pickFirstString(row, ['used_date', 'usedDate']);
    if (purchasedDate && !usedDate) return true;
    return !usedDate;
  }

  async function loadHoverPurchaseStatsMapFromApi() {
    const map = new Map();

    try {
      const payload = await fetchJson('api/objects/stock_log');
      let rows = extractArray(payload);
      if (!rows.length) {
        rows = deepCollectObjects(payload, (o) => hasAnyKey(o, ['product_id', 'productId']) && hasAnyKey(o, ['amount']));
      }
      rows.forEach((row) => {
        if (!isLikelyPurchaseTransaction(row)) return;
        const productId = pickFirstNumber(row, ['product_id', 'productId']);
        const amount = num(row && row.amount);
        updatePurchaseStatsMap(map, productId, amount);
      });
      if (map.size > 0) return map;
    } catch (error) {
      console.warn('Dashboard: impossible de charger stock_log (achats)', error);
    }

    try {
      const payload = await fetchJson('api/objects/products_last_purchased');
      let rows = extractArray(payload);
      if (!rows.length) {
        rows = deepCollectObjects(payload, (o) => hasAnyKey(o, ['product_id', 'productId']) && hasAnyKey(o, ['amount']));
      }
      rows.forEach((row) => {
        const productId = pickFirstNumber(row, ['product_id', 'productId']);
        const amount = pickFirstNumber(row, ['amount']);
        updatePurchaseStatsMap(map, productId, amount);
      });
    } catch (error) {
      console.warn('Dashboard: impossible de charger products_last_purchased', error);
    }

    if (map.size === 0) {
      hoverPreviewRowsSource().forEach((row) => {
        updatePurchaseStatsMap(map, num(row && row.id), num(row && row.amount));
      });
    }

    return map;
  }

  function ensureHoverPurchaseStatsMapLoaded() {
    if (S.hoverPurchaseStatsLoaded) return Promise.resolve(S.hoverPurchaseStatsByProductId);
    if (S.hoverPurchaseStatsPromise) return S.hoverPurchaseStatsPromise;
    S.hoverPurchaseStatsPromise = loadHoverPurchaseStatsMapFromApi()
      .then((map) => {
        S.hoverPurchaseStatsByProductId = map instanceof Map ? map : new Map();
        S.hoverPurchaseStatsLoaded = true;
        return S.hoverPurchaseStatsByProductId;
      })
      .catch((error) => {
        console.warn('Dashboard: erreur chargement stats achats pour survol', error);
        S.hoverPurchaseStatsLoaded = true;
        return S.hoverPurchaseStatsByProductId;
      })
      .finally(() => {
        S.hoverPurchaseStatsPromise = null;
      });
    return S.hoverPurchaseStatsPromise;
  }

  function ensureHoverEnrichmentDataLoaded() {
    ensureHoverRecipeMapLoaded();
    ensureHoverPriceRangeMapLoaded();
    ensureHoverPurchaseStatsMapLoaded();
  }

  function resetHoverEnrichmentDataCaches() {
    S.hoverRecipeMapByProductId = new Map();
    S.hoverRecipeMapLoaded = false;
    S.hoverRecipeMapPromise = null;
    S.hoverPriceRangeByProductId = new Map();
    S.hoverPriceRangeLoaded = false;
    S.hoverPriceRangePromise = null;
    S.hoverPurchaseStatsByProductId = new Map();
    S.hoverPurchaseStatsLoaded = false;
    S.hoverPurchaseStatsPromise = null;
  }

  function findProductRowByName(nameInput) {
    const target = norm(nameInput || '');
    if (!target) return null;
    const rows = hoverPreviewRowsSource();
    return rows.find((row) => norm(row && row.name ? row.name : '') === target) || null;
  }

  function hoverPreviewRowPrice(row) {
    const price = num(row && row.price);
    if (price > 0) return price;
    const avgPrice = num(row && row.avgPrice);
    if (avgPrice > 0) return avgPrice;
    const value = num(row && row.value);
    const amount = num(row && row.amount);
    if (value > 0 && amount > 0) return value / amount;
    return 0;
  }

  function hoverPriceRangeForProduct(productId, rowInput = null) {
    const id = num(productId);
    const current = S.hoverPriceRangeByProductId.get(id) || null;
    let low = current ? num(current.min) : 0;
    let high = current ? num(current.max) : 0;
    const fallbackPrice = hoverPreviewRowPrice(rowInput);
    if (fallbackPrice > 0) {
      if (low <= 0 || fallbackPrice < low) low = fallbackPrice;
      if (high <= 0 || fallbackPrice > high) high = fallbackPrice;
    }
    return { low, high };
  }

  function hoverRecipesForProduct(productId, limit = 3) {
    const id = num(productId);
    const all = Array.isArray(S.hoverRecipeMapByProductId.get(id))
      ? S.hoverRecipeMapByProductId.get(id)
      : [];
    const safeLimit = Math.max(1, Math.floor(num(limit)));
    return {
      names: all.slice(0, safeLimit),
      more: Math.max(0, all.length - safeLimit),
    };
  }

  function hoverPreviewFacetRows(facetTypeInput, facetValueInput) {
    const facetType = normalizeFacetType(facetTypeInput);
    const facetValue = clean(facetValueInput || '');
    const valueNorm = norm(facetValue);
    if (!facetType || !facetValue || !valueNorm) return [];
    return hoverPreviewRowsSource().filter((row) => {
      if (!row || typeof row !== 'object') return false;
      if (facetType === 'brand') return norm(clean(row.brand || '')) === valueNorm;
      if (facetType === 'group') return norm(clean(row.group || '')) === valueNorm;
      return false;
    });
  }

  function stripParentheticalSegments(textInput = '') {
    const source = clean(textInput || '');
    if (!source) return '';
    return clean(source.replace(/\s*\([^)]*\)\s*/g, ' '));
  }

  function hoverEquivalentLabel(entryInput, countInput, langInput = '') {
    const entry = entryInput && typeof entryInput === 'object' ? entryInput : {};
    const count = Math.abs(num(countInput));
    const lang = langInput || resolveUiLanguage();
    const singular = lang === 'en'
      ? clean(entry.enSingular || entry.frSingular || '')
      : clean(entry.frSingular || entry.enSingular || '');
    const plural = lang === 'en'
      ? clean(entry.enPlural || `${singular}s`)
      : clean(entry.frPlural || `${singular}s`);
    if (count >= 2) return stripParentheticalSegments(plural || singular);
    return stripParentheticalSegments(singular || plural);
  }

  function hoverEquivalentCountText(countInput) {
    const count = Math.abs(num(countInput));
    if (!Number.isFinite(count) || count <= 0) return fmt(0, 0);
    if (count >= 1000) return fmt(count, 0);
    if (count >= 100) return fmt(count, 1);
    if (count >= 10) return fmt(count, 1);
    return fmt(count, 2);
  }

  function hoverEquivalentBucket(countInput) {
    const count = Math.abs(num(countInput));
    if (count < 1) return 0;
    if (count < 5) return 1;
    if (count < 20) return 2;
    if (count < 100) return 3;
    if (count < 1000) return 4;
    return 5;
  }

  function computeHoverEquivalents(totalInput, catalogInput, maxItems = 7) {
    const total = Math.abs(num(totalInput));
    const catalog = Array.isArray(catalogInput) ? catalogInput : [];
    if (!(total > 0) || catalog.length === 0) return [];

    const values = catalog
      .map((entry) => {
        const unitValue = num(entry && entry.unitValue);
        if (!(unitValue > 0)) return null;
        const count = total / unitValue;
        if (!(count > 0)) return null;
        return { entry, count };
      })
      .filter(Boolean)
      .sort((a, b) => Math.abs(Math.log10(a.count) - 1) - Math.abs(Math.log10(b.count) - 1));

    const targetCount = Math.max(2, Math.floor(num(maxItems)));
    const selected = [];
    const usedBuckets = new Set();
    values.forEach((item) => {
      if (selected.length >= targetCount) return;
      const bucket = hoverEquivalentBucket(item.count);
      if (usedBuckets.has(bucket)) return;
      usedBuckets.add(bucket);
      selected.push(item);
    });
    if (selected.length < targetCount) {
      values.forEach((item) => {
        if (selected.length >= targetCount) return;
        if (selected.some((sel) => sel.entry === item.entry)) return;
        selected.push(item);
      });
    }
    return selected;
  }

  function hoverEquivalentPhrase(kindInput, equivalentsInput, langInput = '') {
    const kind = clean(kindInput || '');
    const equivalents = Array.isArray(equivalentsInput) ? equivalentsInput : [];
    const lang = langInput || resolveUiLanguage();
    if (equivalents.length === 0) return '';
    const dramatic = [...equivalents].sort((a, b) => num(b.count) - num(a.count))[0] || equivalents[0];
    const relatable = equivalents.find((item) => num(item.count) >= 1 && num(item.count) <= 80) || equivalents[0];
    const relTxt = `${hoverEquivalentCountText(relatable.count)} ${hoverEquivalentLabel(relatable.entry, relatable.count, lang)}`;
    const draTxt = `${hoverEquivalentCountText(dramatic.count)} ${hoverEquivalentLabel(dramatic.entry, dramatic.count, lang)}`;

    if (kind === 'calories') {
      return langText(
        `Ça représente environ ${relTxt}; version épique: ${draTxt}.`,
        `That is about ${relTxt}; epic mode: ${draTxt}.`,
        lang
      );
    }
    return langText(
      `Soit environ ${relTxt}, ou carrément ${draTxt}.`,
      `That is about ${relTxt}, or fully ${draTxt}.`,
      lang
    );
  }

  function hoverEquivalentSectionHtml(kindInput, totalInput) {
    const kind = clean(kindInput || '');
    const total = Math.abs(num(totalInput));
    if (!(total > 0)) return '';
    const lang = resolveUiLanguage();
    const isCalories = kind === 'calories';
    const catalog = isCalories ? FUN_CAL_EQUIVALENTS : FUN_PRICE_EQUIVALENTS;
    const minimum = isCalories ? 20 : 0.1;
    if (total < minimum) return '';

    const equivalents = computeHoverEquivalents(total, catalog, 7);
    if (!equivalents.length) return '';

    const title = isCalories
      ? langText(`Équivalents rigolos calories (${fmtKcal(total)})`, `Fun calorie equivalents (${fmtKcal(total)})`, lang)
      : langText(`Équivalents rigolos prix (${fmtMoneyUi(total)})`, `Fun price equivalents (${fmtMoneyUi(total)})`, lang);
    const lines = equivalents.map((item) => `
      <li>
        <strong>${escapeHtml(hoverEquivalentCountText(item.count))}</strong>
        <span>${escapeHtml(hoverEquivalentLabel(item.entry, item.count, lang))}</span>
      </li>
    `).join('');
    const phrase = hoverEquivalentPhrase(isCalories ? 'calories' : 'price', equivalents, lang);

    return `
      <div class="dash-hover-preview-fun-block">
        <div class="dash-hover-preview-fun-title">${escapeHtml(title)}</div>
        <ul class="dash-hover-preview-fun-list">${lines}</ul>
        <div class="dash-hover-preview-fun-note">${escapeHtml(phrase)}</div>
      </div>
    `;
  }

  function calorieFunSummaryText(totalInput, maxItems = 2) {
    const total = Math.abs(num(totalInput));
    if (!(total >= 20)) return '';
    const lang = resolveUiLanguage();
    const catalog = Array.isArray(FUN_CAL_EQUIVALENTS) ? FUN_CAL_EQUIVALENTS : [];
    if (!catalog.length) return '';

    let best = null;
    catalog.forEach((entry) => {
      const unitValue = num(entry && entry.unitValue);
      if (!(unitValue > 0)) return;
      const rawCount = total / unitValue;
      if (!(rawCount > 0.45)) return;
      let evenCount = Math.round(rawCount / 2) * 2;
      if (evenCount < 2) evenCount = 2;
      if (evenCount % 2 !== 0) evenCount += 1;
      const relError = Math.abs(rawCount - evenCount) / Math.max(1, rawCount);
      const rangePenalty = evenCount > 180 ? Math.min((evenCount - 180) / 220, 1.2) : 0;
      const tinyPenalty = evenCount < 2 ? 1 : 0;
      const score = relError + rangePenalty + tinyPenalty;
      if (!best || score < best.score) {
        best = { entry, evenCount, score };
      }
    });

    if (!best || !(best.evenCount >= 2)) return '';
    const countText = fmt(best.evenCount, 0);
    const labelText = hoverEquivalentLabel(best.entry, best.evenCount, lang);
    if (!labelText) return '';
    return langText(
      `Environ ${countText} ${labelText}.`,
      `About ${countText} ${labelText}.`,
      lang
    );
  }

  function defaultKpiLifetimeTotals() {
    return {
      loaded: false,
      loading: false,
      value: 0,
      calories: 0,
      transactions: 0,
      products: 0,
      source: '',
      error: '',
      updatedAt: 0,
    };
  }

  function ensureKpiLifetimeTotalsState() {
    if (!S.kpiLifetimeTotals || typeof S.kpiLifetimeTotals !== 'object') {
      S.kpiLifetimeTotals = defaultKpiLifetimeTotals();
    }
    return S.kpiLifetimeTotals;
  }

  function resetKpiLifetimeTotalsState() {
    S.kpiLifetimeTotals = defaultKpiLifetimeTotals();
    S.kpiLifetimeTotalsPromise = null;
  }

  function lifetimePricePerAmountMap() {
    const map = new Map();
    const push = (productIdInput, priceInput) => {
      const productId = num(productIdInput);
      const price = Math.abs(num(priceInput));
      if (!(productId > 0) || !(price > 0)) return;
      if (!map.has(productId)) {
        map.set(productId, price);
        return;
      }
      const current = Math.abs(num(map.get(productId)));
      if (!(current > 0)) {
        map.set(productId, price);
      }
    };

    if (S.apiStockByProductId instanceof Map) {
      S.apiStockByProductId.forEach((row, productIdInput) => {
        const rowObj = row && typeof row === 'object' ? row : {};
        const productId = num(productIdInput);
        const price = num(rowObj.price);
        const avgPrice = num(rowObj.avgPrice);
        const amount = num(rowObj.amount);
        const value = num(rowObj.value);
        push(productId, price);
        push(productId, avgPrice);
        if (amount > 0 && value > 0) push(productId, value / amount);
      });
    }

    hoverPreviewRowsSource().forEach((row) => {
      const rowObj = row && typeof row === 'object' ? row : {};
      const productId = num(rowObj.id);
      const amount = num(rowObj.amount);
      const value = num(rowObj.value);
      push(productId, num(rowObj.price));
      push(productId, num(rowObj.avgPrice));
      if (amount > 0 && value > 0) push(productId, value / amount);
    });

    return map;
  }

  function lifetimeCaloriesPerAmountMap() {
    const map = new Map();
    const push = (productIdInput, caloriesPerAmountInput) => {
      const productId = num(productIdInput);
      const caloriesPerAmount = Math.abs(num(caloriesPerAmountInput));
      if (!(productId > 0) || !(caloriesPerAmount > 0)) return;
      if (!map.has(productId)) {
        map.set(productId, caloriesPerAmount);
        return;
      }
      const current = Math.abs(num(map.get(productId)));
      if (!(current > 0)) map.set(productId, caloriesPerAmount);
    };

    if (S.apiStockByProductId instanceof Map) {
      S.apiStockByProductId.forEach((row, productIdInput) => {
        const rowObj = row && typeof row === 'object' ? row : {};
        const productId = num(productIdInput);
        const amount = num(rowObj.amount);
        const calories = num(rowObj.calories);
        if (amount > 0 && calories > 0) push(productId, calories / amount);
      });
    }

    hoverPreviewRowsSource().forEach((row) => {
      const rowObj = row && typeof row === 'object' ? row : {};
      const productId = num(rowObj.id);
      const amount = num(rowObj.amount);
      const calories = num(rowObj.calories);
      if (amount > 0 && calories > 0) push(productId, calories / amount);
    });

    return map;
  }

  function lifetimeLineValue(rowInput, fallbackPriceMapInput = null) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const product = row.product && typeof row.product === 'object' ? row.product : {};
    const amount = Math.abs(num(row.amount));
    if (!(amount > 0)) return 0;

    let value = Math.abs(pickFirstNumber(row, ['value', 'transaction_value', 'total_price', 'price_total', 'amount_price']));
    if (value > 0) return value;

    let price = Math.abs(pickFirstNumber(row, ['price', 'last_price', 'unit_price']));
    if (!(price > 0)) {
      price = Math.abs(pickFirstNumber(product, ['price', 'last_price', 'average_price']));
    }
    if (!(price > 0) && fallbackPriceMapInput instanceof Map) {
      const productId = pickFirstNumber(row, ['product_id', 'productId']);
      price = Math.abs(num(fallbackPriceMapInput.get(productId)));
    }
    if (price > 0) value = price * amount;

    return value > 0 ? value : 0;
  }

  function lifetimeLineCalories(rowInput, fallbackCaloriesMapInput = null) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const product = row.product && typeof row.product === 'object' ? row.product : {};
    const amount = Math.abs(num(row.amount));
    if (!(amount > 0)) return 0;

    let calories = Math.abs(pickFirstNumber(row, ['calories', 'energy_kcal', 'kcal']));
    if (calories > 0) return calories;

    let caloriesPerAmount = Math.abs(pickFirstNumber(row, ['product_calories', 'calories_per_unit']));
    if (!(caloriesPerAmount > 0)) {
      caloriesPerAmount = Math.abs(pickFirstNumber(product, ['calories', 'product_calories', 'calories_per_unit']));
    }
    if (!(caloriesPerAmount > 0) && fallbackCaloriesMapInput instanceof Map) {
      const productId = pickFirstNumber(row, ['product_id', 'productId']);
      caloriesPerAmount = Math.abs(num(fallbackCaloriesMapInput.get(productId)));
    }
    if (caloriesPerAmount > 0) calories = caloriesPerAmount * amount;

    return calories > 0 ? calories : 0;
  }

  async function loadKpiLifetimeTotalsFromApi() {
    const totals = defaultKpiLifetimeTotals();
    totals.loading = true;
    totals.source = 'api/objects/stock_log';
    const fallbackPriceMap = lifetimePricePerAmountMap();
    const fallbackCaloriesMap = lifetimeCaloriesPerAmountMap();
    const products = new Set();

    try {
      const payload = await fetchJson('api/objects/stock_log');
      let rows = extractArray(payload);
      if (!rows.length) {
        rows = deepCollectObjects(payload, (o) => hasAnyKey(o, ['product_id', 'productId']) && hasAnyKey(o, ['amount']));
      }

      rows.forEach((row) => {
        if (!isLikelyPurchaseTransaction(row)) return;
        const amount = Math.abs(num(row && row.amount));
        if (!(amount > 0)) return;
        const productId = pickFirstNumber(row, ['product_id', 'productId']);
        if (productId > 0) products.add(productId);

        const lineValue = lifetimeLineValue(row, fallbackPriceMap);
        if (lineValue > 0) totals.value += lineValue;

        const lineCalories = lifetimeLineCalories(row, fallbackCaloriesMap);
        if (lineCalories > 0) totals.calories += lineCalories;

        totals.transactions += 1;
      });

      totals.products = products.size;
      totals.loaded = true;
      totals.loading = false;
      totals.updatedAt = Date.now();
      return totals;
    } catch (error) {
      totals.loaded = true;
      totals.loading = false;
      totals.error = clean(error && error.message ? error.message : String(error));
      totals.updatedAt = Date.now();
      return totals;
    }
  }

  function ensureKpiLifetimeTotalsLoaded() {
    const state = ensureKpiLifetimeTotalsState();
    if (state.loaded && !state.loading) return Promise.resolve(state);
    if (S.kpiLifetimeTotalsPromise) return S.kpiLifetimeTotalsPromise;

    S.kpiLifetimeTotals = {
      ...state,
      loading: true,
      error: '',
    };

    S.kpiLifetimeTotalsPromise = loadKpiLifetimeTotalsFromApi()
      .then((totals) => {
        S.kpiLifetimeTotals = {
          ...defaultKpiLifetimeTotals(),
          ...totals,
          loaded: true,
          loading: false,
          updatedAt: Date.now(),
        };
        return S.kpiLifetimeTotals;
      })
      .catch((error) => {
        S.kpiLifetimeTotals = {
          ...defaultKpiLifetimeTotals(),
          loaded: true,
          loading: false,
          error: clean(error && error.message ? error.message : String(error)),
          updatedAt: Date.now(),
        };
        return S.kpiLifetimeTotals;
      })
      .finally(() => {
        S.kpiLifetimeTotalsPromise = null;
        scheduleRender();
      });

    return S.kpiLifetimeTotalsPromise;
  }

  function roundedCountCandidates(rawCountInput, preferEven = false) {
    const rawCount = Math.abs(num(rawCountInput));
    if (!(rawCount > 0)) return [];
    const candidates = new Set();
    const add = (valueInput) => {
      const value = Math.abs(num(valueInput));
      if (!(value > 0)) return;
      candidates.add(Number(value.toFixed(4)));
    };

    add(Math.round(rawCount));
    add(Math.floor(rawCount));
    add(Math.ceil(rawCount));
    add(Math.round(rawCount / 2) * 2);
    add(Math.round(rawCount / 5) * 5);
    add(Math.round(rawCount / 10) * 10);
    add(Math.round(rawCount / 20) * 20);
    add(Math.round(rawCount / 50) * 50);
    add(Math.round(rawCount / 100) * 100);
    if (rawCount <= 20) {
      add(Math.round(rawCount * 2) / 2);
      add(Math.round(rawCount * 4) / 4);
    }

    let list = Array.from(candidates).filter((value) => value > 0);
    if (preferEven) {
      list = list.map((value) => {
        if (value < 2) return 2;
        const roundedEven = Math.round(value / 2) * 2;
        return roundedEven >= 2 ? roundedEven : 2;
      });
    }

    return Array.from(new Set(list))
      .filter((value) => value > 0)
      .sort((a, b) => {
        const da = Math.abs(a - rawCount);
        const db = Math.abs(b - rawCount);
        if (da !== db) return da - db;
        return a - b;
      });
  }

  function computeRoundedKpiEquivalents(totalInput, catalogInput, maxItems = 12, optionsInput = null) {
    const total = Math.abs(num(totalInput));
    const catalog = Array.isArray(catalogInput) ? catalogInput : [];
    if (!(total > 0) || catalog.length === 0) return [];
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const preferEven = options.preferEven !== false;
    const maxRelError = Number.isFinite(num(options.maxRelError)) ? Math.max(0.03, num(options.maxRelError)) : 0.22;
    const maxAbsCount = Number.isFinite(num(options.maxAbsCount)) ? Math.max(4, Math.floor(num(options.maxAbsCount))) : 15000;
    const take = Math.max(2, Math.floor(num(maxItems)));

    const entryBest = [];
    catalog.forEach((entryInput) => {
      const entry = entryInput && typeof entryInput === 'object' ? entryInput : null;
      const unitValue = num(entry && entry.unitValue);
      if (!(unitValue > 0)) return;
      const rawCount = total / unitValue;
      if (!(rawCount > 0)) return;

      const candidates = roundedCountCandidates(rawCount, preferEven);
      let best = null;
      candidates.forEach((candidateCount) => {
        const count = Math.abs(num(candidateCount));
        if (!(count > 0) || count > maxAbsCount) return;
        const relError = Math.abs(rawCount - count) / Math.max(1, rawCount);
        if (relError > maxRelError && !(count <= 10 && relError <= 0.34)) return;
        const spreadPenalty = count > 3000 ? Math.min((count - 3000) / 9000, 1.2) : 0;
        const score = relError + spreadPenalty + (preferEven && Math.round(count) % 2 !== 0 ? 0.08 : 0);
        if (!best || score < best.score) {
          best = {
            entry,
            count,
            rawCount,
            relError,
            score,
          };
        }
      });
      if (best) entryBest.push(best);
    });

    const sorted = entryBest.sort((a, b) => {
      if (a.score !== b.score) return a.score - b.score;
      const aDistance = Math.abs(Math.log10(Math.max(1, a.count)) - 1);
      const bDistance = Math.abs(Math.log10(Math.max(1, b.count)) - 1);
      if (aDistance !== bDistance) return aDistance - bDistance;
      return Math.abs(a.count - a.rawCount) - Math.abs(b.count - b.rawCount);
    });

    const picked = [];
    const usedBuckets = new Set();
    sorted.forEach((item) => {
      if (picked.length >= take) return;
      const bucket = hoverEquivalentBucket(item.count);
      if (usedBuckets.has(bucket) && picked.length < Math.min(5, take - 1)) return;
      usedBuckets.add(bucket);
      picked.push(item);
    });
    if (picked.length < take) {
      sorted.forEach((item) => {
        if (picked.length >= take) return;
        if (picked.includes(item)) return;
        picked.push(item);
      });
    }
    return picked.slice(0, take);
  }

  function funCategoryLabelById(categoryIdInput = '', langInput = '') {
    const lang = langInput || resolveUiLanguage();
    const id = normalizeFunCategoryId(categoryIdInput);
    const meta = funCategoryMetaById(id);
    return lang === 'en'
      ? clean(meta.en || meta.fr || FUN_DEFAULT_CATEGORY.en)
      : clean(meta.fr || meta.en || FUN_DEFAULT_CATEGORY.fr);
  }

  function funCategoryIdForEntry(entryInput = null) {
    const entry = entryInput && typeof entryInput === 'object' ? entryInput : {};
    return normalizeFunCategoryId(entry.categoryId || FUN_DEFAULT_CATEGORY.id);
  }

  function funCategoryLabelForEntry(entryInput = null, langInput = '') {
    const entry = entryInput && typeof entryInput === 'object' ? entryInput : {};
    const lang = langInput || resolveUiLanguage();
    if (lang === 'en') {
      const label = clean(entry.categoryEn || entry.categoryFr || '');
      if (label) return label;
    } else {
      const label = clean(entry.categoryFr || entry.categoryEn || '');
      if (label) return label;
    }
    return funCategoryLabelById(funCategoryIdForEntry(entry), lang);
  }

  function funPanelCategoryOrder(kindInput = '', categoryIdsInput = []) {
    const categoryIds = Array.isArray(categoryIdsInput) ? categoryIdsInput : [];
    const kind = clean(kindInput || '') === 'calories' ? 'calories' : 'price';
    const preferred = kind === 'calories'
      ? ['cinema', 'series', 'jeux_video', 'musique', 'pop_culture', 'science_fiction', 'histoire', 'internet', 'quotidien']
      : FUN_CATEGORY_DISPLAY_ORDER;
    const out = [];
    preferred.forEach((idInput) => {
      const id = normalizeFunCategoryId(idInput);
      if (categoryIds.includes(id) && !out.includes(id)) out.push(id);
    });
    categoryIds.forEach((idInput) => {
      const id = normalizeFunCategoryId(idInput);
      if (!out.includes(id)) out.push(id);
    });
    return out;
  }

  function funEquivalentBaseLabel(entryInput = null, langInput = '') {
    const entry = entryInput && typeof entryInput === 'object' ? entryInput : {};
    const lang = langInput || resolveUiLanguage();
    const singular = lang === 'en'
      ? clean(entry.enSingular || entry.enLabel || entry.frSingular || entry.frLabel || '')
      : clean(entry.frSingular || entry.frLabel || entry.enSingular || entry.enLabel || '');
    const plural = lang === 'en'
      ? clean(entry.enPlural || singular)
      : clean(entry.frPlural || singular);
    return stripParentheticalSegments(singular || plural || '');
  }

  function normalizeFunPhotoQueryText(textInput = '') {
    const source = clean(textInput || '');
    if (!source) return '';
    let text = source
      .replace(/[\u{1F300}-\u{1FAFF}]/gu, ' ')
      .replace(/[–—]/g, '-')
      .replace(/["'`’]/g, '')
      .replace(/[()]/g, ' ')
      .replace(/\b(micro|compact|classique|classic|maxi|ultra)\b/gi, ' ')
      .replace(/[^0-9A-Za-zÀ-ÿ+\- ]+/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();
    if (!text) return '';
    try {
      text = text.normalize('NFD').replace(/[\u0300-\u036f]/g, '').trim();
    } catch (_err) {}
    return text;
  }

  function funAutoPhotoUrlForEquivalent(entryInput = null, langInput = '') {
    const entry = entryInput && typeof entryInput === 'object' ? entryInput : {};
    const explicit = clean(
      entry.photoUrl
      || entry.photo
      || entry.imageUrl
      || entry.thumbnailUrl
      || ''
    );
    if (explicit) return explicit;

    const baseLabel = normalizeFunPhotoQueryText(funEquivalentBaseLabel(entry, langInput));
    if (!baseLabel) return '';
    const terms = baseLabel
      .split(/\s+/)
      .map((term) => clean(term))
      .filter((term) => term.length >= 2)
      .slice(0, 8);
    if (!terms.length) return '';
    const query = terms.join(',');
    const lock = funSeedHash(terms.join('|')) || 1;
    return `https://loremflickr.com/320/320/${encodeURIComponent(query)}?lock=${lock}`;
  }

  function funPanelNonce(panelKeyInput = '') {
    const panelKey = clean(panelKeyInput || '');
    if (!panelKey) return 0;
    const raw = S.funPanelRandomNonceByKey && typeof S.funPanelRandomNonceByKey === 'object'
      ? S.funPanelRandomNonceByKey[panelKey]
      : 0;
    return Math.max(0, Math.floor(num(raw)) || 0);
  }

  function incrementFunPanelNonce(panelKeyInput = '') {
    const panelKey = clean(panelKeyInput || '');
    if (!panelKey) return false;
    const current = funPanelNonce(panelKey);
    S.funPanelRandomNonceByKey[panelKey] = current + 1;
    return true;
  }

  function bumpFunPanelNonce(panelKeyInput = '') {
    if (!incrementFunPanelNonce(panelKeyInput)) return;
    scheduleUiStateSave();
  }

  function buildCategorizedFunRows(kindInput, totalInput, catalogInput, panelKeyInput = '', optionsInput = null) {
    const kind = clean(kindInput || '') === 'calories' ? 'calories' : 'price';
    const total = Math.abs(num(totalInput));
    const catalog = Array.isArray(catalogInput) ? catalogInput : [];
    const panelKey = clean(panelKeyInput || '');
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const perCategoryPool = Math.max(3, Math.min(18, Math.floor(num(options.perCategoryPool)) || 8));
    const maxCategories = Math.max(3, Math.min(12, Math.floor(num(options.maxCategories)) || 9));
    const preferEven = options.preferEven !== false;
    const maxRelError = Number.isFinite(num(options.maxRelError))
      ? Math.max(0.03, num(options.maxRelError))
      : (kind === 'calories' ? 0.2 : 0.24);
    const maxAbsCount = Number.isFinite(num(options.maxAbsCount))
      ? Math.max(4, Math.floor(num(options.maxAbsCount)))
      : (kind === 'calories' ? 12000 : 22000);
    if (!(total > 0) || !catalog.length) return [];

    const lang = resolveUiLanguage();
    const byCategory = new Map();
    catalog.forEach((entryInput) => {
      const entry = entryInput && typeof entryInput === 'object' ? entryInput : null;
      if (!entry) return;
      const unitValue = num(entry.unitValue);
      if (!(unitValue > 0)) return;
      const catId = funCategoryIdForEntry(entry);
      if (!byCategory.has(catId)) byCategory.set(catId, []);
      byCategory.get(catId).push(entry);
    });
    if (!byCategory.size) return [];

    const order = funPanelCategoryOrder(kind, Array.from(byCategory.keys())).slice(0, maxCategories);
    const nonce = panelKey ? funPanelNonce(panelKey) : 0;
    const rows = [];
    order.forEach((catId) => {
      const subset = byCategory.get(catId);
      if (!subset || subset.length === 0) return;
      const candidates = computeRoundedKpiEquivalents(total, subset, perCategoryPool, {
        preferEven,
        maxRelError,
        maxAbsCount,
      });
      if (!candidates.length) return;
      const idx = panelKey
        ? funSeedHash(`${panelKey}|${catId}|${nonce}`) % candidates.length
        : 0;
      const pick = candidates[idx] || candidates[0];
      const label = funCategoryLabelForEntry(pick.entry, lang) || funCategoryLabelById(catId, lang);
      rows.push({
        categoryId: catId,
        categoryLabel: label,
        count: num(pick.count),
        entry: pick.entry,
      });
    });
    return rows;
  }

  function funPanelPhotoCandidate(kindInput = 'price', optionsInput = null) {
    const kind = clean(kindInput || '') === 'calories' ? 'calories' : 'price';
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};

    const equivalent = options.equivalent && typeof options.equivalent === 'object'
      ? options.equivalent
      : null;
    if (equivalent) {
      const eqName = clean(funEquivalentBaseLabel(equivalent) || t('kpi_fun_thumb_fallback_name'));
      const eqUrl = clean(funAutoPhotoUrlForEquivalent(equivalent) || '');
      if (eqUrl) {
        return { url: eqUrl, name: eqName };
      }
    }

    if (Array.isArray(options.equivalents)) {
      for (const entry of options.equivalents) {
        if (!entry || typeof entry !== 'object') continue;
        const eqName = clean(funEquivalentBaseLabel(entry) || t('kpi_fun_thumb_fallback_name'));
        const eqUrl = clean(funAutoPhotoUrlForEquivalent(entry) || '');
        if (eqUrl) {
          return { url: eqUrl, name: eqName };
        }
      }
    }

    const candidatesRaw = [];

    const pushRows = (rowsInput) => {
      if (!Array.isArray(rowsInput)) return;
      rowsInput.forEach((row) => {
        if (row && typeof row === 'object') candidatesRaw.push(row);
      });
    };

    if (options.row && typeof options.row === 'object') candidatesRaw.push(options.row);
    pushRows(options.rows);
    pushRows(options.photoRows);
    pushRows(S.lastFilteredRows);

    if (!candidatesRaw.length) return null;

    const unique = [];
    const seen = new Set();
    candidatesRaw.forEach((row) => {
      const pictureUrl = clean(row && row.pictureUrl ? row.pictureUrl : '');
      if (!pictureUrl) return;
      const key = `${num(row && row.id)}|${pictureUrl}`;
      if (seen.has(key)) return;
      seen.add(key);
      unique.push(row);
    });
    if (!unique.length) return null;

    let best = null;
    let bestScore = -1;
    unique.forEach((row) => {
      const primary = kind === 'calories' ? num(row.calories) : num(row.value);
      const secondary = kind === 'calories' ? num(row.value) : num(row.calories);
      const amount = num(row.amount);
      const scorePrimary = primary > 0 ? primary : 0;
      const scoreSecondary = secondary > 0 ? secondary : 0;
      const scoreAmount = amount > 0 ? amount : 0;
      const score = (scorePrimary * 1000000) + (scoreSecondary * 1000) + scoreAmount;
      if (score > bestScore) {
        bestScore = score;
        best = row;
      }
    });

    if (!best) return null;
    const url = clean(best.pictureUrl || '');
    if (!url) return null;
    const name = clean(best.name || '');
    return { url, name };
  }

  function funPanelPhotoHtml(kindInput = 'price', optionsInput = null) {
    const candidate = funPanelPhotoCandidate(kindInput, optionsInput);
    if (!candidate) return '';
    const name = clean(candidate.name || t('kpi_fun_thumb_fallback_name'));
    const url = clean(candidate.url || '');
    if (!url) return '';
    return `
      <span class="dash-kpi-fun-thumb" title="${escapeHtml(name)}">
        <img src="${escapeHtml(url)}" alt="${escapeHtml(name)}">
        <span class="dash-kpi-fun-thumb-preview">
          <img src="${escapeHtml(url)}" alt="${escapeHtml(name)}">
          <div class="dash-kpi-fun-thumb-caption">${escapeHtml(name)}</div>
          <span class="dash-kpi-fun-thumb-hint">${escapeHtml(t('kpi_fun_thumb_hover_hint'))}</span>
        </span>
      </span>
    `;
  }

  function kpiFunStateHtml(titleInput, messageInput, totalTextInput = '') {
    const title = clean(titleInput || '');
    const message = clean(messageInput || '');
    const totalText = clean(totalTextInput || '');
    return `
      <div class="dash-kpi-fun-head">
        <span class="dash-kpi-fun-title">${escapeHtml(title)}</span>
        ${totalText ? `<span class="dash-kpi-fun-total">${escapeHtml(totalText)}</span>` : ''}
      </div>
      <div class="dash-kpi-fun-empty">${escapeHtml(message || t('kpi_fun_no_data'))}</div>
    `;
  }

  function kpiFunPanelHtml(kindInput, totalInput, titleInput, optionsInput = null) {
    const kind = clean(kindInput || '') === 'calories' ? 'calories' : 'price';
    const total = Math.abs(num(totalInput));
    const title = clean(titleInput || '');
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const panelKey = clean(options.panelKey || '');
    const minimum = kind === 'calories' ? 20 : 0.1;
    const totalText = kind === 'calories' ? fmtKcal(total) : fmtMoneyUi(total);
    if (!(total >= minimum)) {
      const fallbackText = clean(options.emptyText || t('kpi_fun_no_data'));
      return kpiFunStateHtml(title, fallbackText, totalText);
    }

    const catalog = kind === 'calories' ? FUN_CAL_EQUIVALENTS : FUN_PRICE_EQUIVALENTS;
    const picks = computeRoundedKpiEquivalents(total, catalog, 10, {
      preferEven: true,
      maxRelError: kind === 'calories' ? 0.2 : 0.24,
      maxAbsCount: kind === 'calories' ? 12000 : 22000,
    });
    if (!picks.length) {
      const fallbackText = clean(options.emptyText || t('kpi_fun_no_data'));
      return kpiFunStateHtml(title, fallbackText, totalText);
    }

    const normalized = picks.map((item) => ({
      entry: item.entry,
      count: num(item.count),
    }));
    const nonce = panelKey ? funPanelNonce(panelKey) : 0;
    const startIdx = panelKey && normalized.length > 1
      ? funSeedHash(`${panelKey}|${kind}|${total.toFixed(3)}|${nonce}`) % normalized.length
      : 0;
    const rotated = startIdx > 0
      ? [...normalized.slice(startIdx), ...normalized.slice(0, startIdx)]
      : normalized;
    const head = rotated[0];
    const countText = hoverEquivalentCountText(head.count);
    const labelText = hoverEquivalentLabel(head.entry, head.count);
    const phrase = hoverEquivalentPhrase(kind, rotated.slice(0, 4), resolveUiLanguage());
    const mainLine = `${countText} ${labelText}`.trim();
    const detailsLine = phrase && norm(phrase) !== norm(mainLine) ? phrase : '';
    const photoHtml = funPanelPhotoHtml(kind, {
      ...options,
      equivalent: head.entry,
      equivalents: rotated.map((item) => item.entry).filter((entry) => entry && typeof entry === 'object'),
    });
    const wrapClass = photoHtml ? 'dash-kpi-fun-main-wrap' : 'dash-kpi-fun-main-wrap is-no-thumb';
    const randomBtnHtml = panelKey
      ? `
        <button type="button" class="btn btn-outline-secondary btn-sm py-0 px-2 dash-kpi-fun-random-btn" data-fun-panel-random="${escapeHtml(panelKey)}" title="${escapeHtml(t('kpi_fun_randomize_all'))}">
          <i class="fa-solid fa-shuffle mr-1"></i>${escapeHtml(t('kpi_fun_randomize_all'))}
        </button>
      `
      : '';

    return `
      <div class="dash-kpi-fun-head">
        <span class="dash-kpi-fun-title">${escapeHtml(title)}</span>
        <span class="dash-kpi-fun-head-right">
          <span class="dash-kpi-fun-total">${escapeHtml(totalText)}</span>
          ${randomBtnHtml}
        </span>
      </div>
      <div class="${wrapClass}">
        ${photoHtml}
        <div class="dash-kpi-fun-main-lines">
          <div class="dash-kpi-fun-empty">${escapeHtml(mainLine || t('kpi_fun_no_data'))}</div>
          ${detailsLine ? `<div class="dash-kpi-fun-empty dash-kpi-fun-empty-secondary">${escapeHtml(detailsLine)}</div>` : ''}
        </div>
      </div>
    `;
  }

  function setKpiFunNodeHtml(node, htmlInput = '') {
    const target = node && typeof node === 'object' ? node : null;
    if (!target) return;
    const html = String(htmlInput || '');
    if (target.__kpiFunHtml === html) return;
    target.innerHTML = html;
    target.__kpiFunHtml = html;
  }

  function handleFunPanelRandomizeClick(targetInput, eventInput = null) {
    const target = targetInput && typeof targetInput.closest === 'function' ? targetInput : null;
    if (!target) return false;
    const btn = target.closest('[data-fun-panel-random]');
    if (!btn) return false;
    const panelKey = clean(btn.getAttribute('data-fun-panel-random') || '');
    if (!panelKey) return false;
    if (eventInput && typeof eventInput.preventDefault === 'function') eventInput.preventDefault();
    bumpFunPanelNonce(panelKey);
    if (btn.closest('#dash_chart_overlay') && clean(S.fullChartId || '')) {
      renderExpandedChart(S.fullChartId);
    } else {
      scheduleRender();
    }
    return true;
  }

  function renderKpiFunPanels(stockValueInput, stockCaloriesInput, rowsInput = null) {
    const rows = Array.isArray(rowsInput) ? rowsInput : [];
    const valueWrap = document.getElementById('k_value_fun_stack');
    const valueStockNode = document.getElementById('k_value_fun_stock');
    const valueLifetimeNode = document.getElementById('k_value_fun_lifetime');
    const calWrap = document.getElementById('k_cal_fun_stack');
    const calStockNode = document.getElementById('k_cal_fun_stock');
    const calLifetimeNode = document.getElementById('k_cal_fun_lifetime');
    const zone = document.getElementById('dash_kpi_fun_zone');
    const toggleBtn = document.getElementById('dash_kpi_fun_toggle');

    if (!valueWrap || !valueStockNode || !valueLifetimeNode || !calWrap || !calStockNode || !calLifetimeNode) return;

    const lifetime = ensureKpiLifetimeTotalsState();
    if (!lifetime.loaded && !lifetime.loading) {
      ensureKpiLifetimeTotalsLoaded();
    }

    const stockValueHtml = kpiFunPanelHtml('price', stockValueInput, t('kpi_fun_value_stock_title'), {
      panelKey: 'stock:value:current',
      rows,
    });
    const stockCalHtml = kpiFunPanelHtml('calories', stockCaloriesInput, t('kpi_fun_cal_stock_title'), {
      panelKey: 'stock:calories:current',
      rows,
    });

    let lifetimeValueHtml = '';
    let lifetimeCalHtml = '';
    if (lifetime.loading) {
      lifetimeValueHtml = kpiFunStateHtml(t('kpi_fun_value_lifetime_title'), t('kpi_fun_loading'));
      lifetimeCalHtml = kpiFunStateHtml(t('kpi_fun_cal_lifetime_title'), t('kpi_fun_loading'));
    } else if (clean(lifetime.error)) {
      lifetimeValueHtml = kpiFunStateHtml(t('kpi_fun_value_lifetime_title'), t('kpi_fun_history_error'));
      lifetimeCalHtml = kpiFunStateHtml(t('kpi_fun_cal_lifetime_title'), t('kpi_fun_history_error'));
    } else {
      lifetimeValueHtml = kpiFunPanelHtml('price', lifetime.value, t('kpi_fun_value_lifetime_title'), {
        panelKey: 'stock:value:lifetime',
        rows,
      });
      lifetimeCalHtml = kpiFunPanelHtml('calories', lifetime.calories, t('kpi_fun_cal_lifetime_title'), {
        panelKey: 'stock:calories:lifetime',
        rows,
      });
    }

    setKpiFunNodeHtml(valueStockNode, stockValueHtml);
    setKpiFunNodeHtml(valueLifetimeNode, lifetimeValueHtml);
    setKpiFunNodeHtml(calStockNode, stockCalHtml);
    setKpiFunNodeHtml(calLifetimeNode, lifetimeCalHtml);

    const showValue = !!clean(stockValueHtml || lifetimeValueHtml);
    const showCal = !!clean(stockCalHtml || lifetimeCalHtml);
    valueWrap.classList.toggle('d-none', !showValue);
    calWrap.classList.toggle('d-none', !showCal);

    const hasAny = showValue || showCal;
    if (toggleBtn) {
      toggleBtn.classList.toggle('d-none', !hasAny);
      toggleBtn.textContent = S.kpiFunOpen ? t('kpi_fun_toggle_hide') : t('kpi_fun_toggle_show');
      toggleBtn.setAttribute('aria-expanded', S.kpiFunOpen ? 'true' : 'false');
    }
    if (zone) {
      if (!hasAny) {
        S.kpiFunOpen = false;
      }
      zone.classList.toggle('d-none', !hasAny || S.kpiFunOpen !== true);
    }
  }

  function overlayRowIdentityKey(rowInput = null) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const id = num(row.id);
    if (id > 0) return `id:${id}`;
    return `name:${norm(clean(row.name || ''))}`;
  }

  function dedupeOverlayRows(rowsInput = []) {
    const rows = Array.isArray(rowsInput) ? rowsInput : [];
    const out = [];
    const seen = new Set();
    rows.forEach((row) => {
      if (!row || typeof row !== 'object') return;
      const key = overlayRowIdentityKey(row);
      if (!key || seen.has(key)) return;
      seen.add(key);
      out.push(row);
    });
    return out;
  }

  function overlayRowsFromContext(chartIdInput = '', contextDataInput = null) {
    const chartId = clean(chartIdInput || '');
    const contextData = Array.isArray(contextDataInput) ? contextDataInput : [];
    const rows = Array.isArray(S.lastFilteredRows) ? S.lastFilteredRows : [];
    if (!rows.length) return [];

    if (chartId === 'risk' || chartId === 'due') {
      return rows;
    }

    if (chartId === 'g_val' || chartId === 'g_qty' || chartId === 'g_cal') {
      const groups = new Set(
        contextData
          .map((entry) => clean(Array.isArray(entry) ? entry[0] : ''))
          .map((name) => norm(name))
          .filter((name) => name && name !== norm(t('others_label')) && name !== norm(t('no_data')))
      );
      if (!groups.size) return [];
      return rows.filter((row) => groups.has(norm(clean((row && row.group) || ''))));
    }

    if (chartId === 'brand_price') {
      const brands = new Set(
        contextData
          .map((entry) => clean(Array.isArray(entry) ? entry[0] : ''))
          .map((name) => norm(name))
          .filter((name) => name && name !== norm(t('others_label')) && name !== norm(t('no_data')))
      );
      if (!brands.size) return [];
      return rows.filter((row) => brands.has(norm(clean((row && row.brand) || ''))));
    }

    if (chartId === 'brand_rel') {
      const brands = new Set(
        contextData
          .map((entry) => clean(entry && typeof entry === 'object' ? (entry.brand || entry.name || '') : ''))
          .map((name) => norm(name))
          .filter((name) => name && name !== norm(t('others_label')) && name !== norm(t('no_data')))
      );
      if (!brands.size) return [];
      return rows.filter((row) => brands.has(norm(clean((row && row.brand) || ''))));
    }

    if (chartId === 'top_val' || chartId === 'price_val') {
      const ids = new Set(
        contextData
          .map((entry) => num(entry && typeof entry === 'object' ? entry.id : 0))
          .filter((id) => id > 0)
      );
      const names = new Set(
        contextData
          .map((entry) => clean(entry && typeof entry === 'object' ? entry.name : ''))
          .map((name) => norm(name))
          .filter(Boolean)
      );
      return rows.filter((row) => {
        const rowId = num(row && row.id);
        const rowName = norm(clean((row && row.name) || ''));
        if (rowId > 0 && ids.has(rowId)) return true;
        if (rowName && names.has(rowName)) return true;
        return false;
      });
    }

    return rows;
  }

  function overlayContextTotals(chartIdInput = '', contextDataInput = null) {
    const selectedRows = dedupeOverlayRows(overlayRowsFromContext(chartIdInput, contextDataInput));
    const totals = selectedRows.reduce((acc, row) => {
      acc.value += num(row && row.value);
      acc.calories += num(row && row.calories);
      return acc;
    }, { value: 0, calories: 0 });
    return {
      rows: selectedRows,
      value: totals.value,
      calories: totals.calories,
    };
  }

  function overlayFunPanelTitle(baseTitleInput = '', scopeTitleInput = '') {
    const baseTitle = clean(baseTitleInput || '');
    const scopeTitle = clean(scopeTitleInput || '');
    if (!scopeTitle) return baseTitle;
    return `${baseTitle} · ${scopeTitle}`;
  }

  function renderOverlayFunComparisons(chartIdInput = '', contextDataInput = null) {
    const wrap = document.getElementById('dash_chart_overlay_fun');
    const body = document.getElementById('dash_chart_overlay_fun_body');
    if (!wrap || !body) return;

    const chartId = clean(chartIdInput || '');
    const ctxTotals = overlayContextTotals(chartId, contextDataInput);
    const lifetime = ensureKpiLifetimeTotalsState();
    if (!lifetime.loaded && !lifetime.loading) {
      ensureKpiLifetimeTotalsLoaded();
    }

    const showCaloriesPrimary = chartId === 'g_cal';
    const panels = [];

    const currentScope = t('overlay_fun_scope_current');
    const lifetimeScope = t('overlay_fun_scope_lifetime');

    const addPricePanels = () => {
      panels.push(kpiFunPanelHtml(
        'price',
        ctxTotals.value,
        overlayFunPanelTitle(t('kpi_fun_value_stock_title'), currentScope),
        {
          panelKey: `overlay:${chartId}:value:current`,
          rows: ctxTotals.rows,
        }
      ));
      if (lifetime.loading) {
        panels.push(kpiFunStateHtml(overlayFunPanelTitle(t('kpi_fun_value_lifetime_title'), lifetimeScope), t('kpi_fun_loading')));
      } else if (clean(lifetime.error)) {
        panels.push(kpiFunStateHtml(overlayFunPanelTitle(t('kpi_fun_value_lifetime_title'), lifetimeScope), t('kpi_fun_history_error')));
      } else {
        panels.push(kpiFunPanelHtml(
          'price',
          lifetime.value,
          overlayFunPanelTitle(t('kpi_fun_value_lifetime_title'), lifetimeScope),
          {
            panelKey: `overlay:${chartId}:value:lifetime`,
            rows: ctxTotals.rows,
          }
        ));
      }
    };

    const addCaloriesPanels = () => {
      panels.push(kpiFunPanelHtml(
        'calories',
        ctxTotals.calories,
        overlayFunPanelTitle(t('kpi_fun_cal_stock_title'), currentScope),
        {
          panelKey: `overlay:${chartId}:calories:current`,
          rows: ctxTotals.rows,
        }
      ));
      if (lifetime.loading) {
        panels.push(kpiFunStateHtml(overlayFunPanelTitle(t('kpi_fun_cal_lifetime_title'), lifetimeScope), t('kpi_fun_loading')));
      } else if (clean(lifetime.error)) {
        panels.push(kpiFunStateHtml(overlayFunPanelTitle(t('kpi_fun_cal_lifetime_title'), lifetimeScope), t('kpi_fun_history_error')));
      } else {
        panels.push(kpiFunPanelHtml(
          'calories',
          lifetime.calories,
          overlayFunPanelTitle(t('kpi_fun_cal_lifetime_title'), lifetimeScope),
          {
            panelKey: `overlay:${chartId}:calories:lifetime`,
            rows: ctxTotals.rows,
          }
        ));
      }
    };

    if (showCaloriesPrimary) {
      addCaloriesPanels();
      if (ctxTotals.value > 0 || num(lifetime.value) > 0 || lifetime.loading) addPricePanels();
    } else {
      addPricePanels();
      if (ctxTotals.calories > 0 || num(lifetime.calories) > 0 || lifetime.loading) addCaloriesPanels();
    }

    const usablePanels = panels.filter((html) => clean(html));
    if (!usablePanels.length) {
      body.innerHTML = `<div class="dash-overlay-fun-empty">${escapeHtml(t('overlay_fun_no_data'))}</div>`;
      wrap.classList.remove('d-none');
      return;
    }

    body.innerHTML = `
      <div class="dash-overlay-fun-grid">
        ${usablePanels.map((panelHtml) => `<div class="dash-overlay-fun-card"><div class="dash-kpi-fun-panel">${panelHtml}</div></div>`).join('')}
      </div>
    `;
    wrap.classList.remove('d-none');
  }

  function hoverPurchaseScoreForRow(row) {
    const id = num(row && row.id);
    const stats = S.hoverPurchaseStatsByProductId.get(id);
    const amountFromStats = stats ? num(stats.amount) : 0;
    const countFromStats = stats ? num(stats.count) : 0;
    const fallbackAmount = num(row && row.amount);
    const base = amountFromStats > 0 ? amountFromStats : Math.max(0, fallbackAmount);
    return (base * 1000) + countFromStats;
  }

  function topBoughtRowsForFacet(facetTypeInput, facetValueInput, limit = 5) {
    const rows = hoverPreviewFacetRows(facetTypeInput, facetValueInput);
    const sorted = [...rows].sort((a, b) => {
      const aScore = hoverPurchaseScoreForRow(a);
      const bScore = hoverPurchaseScoreForRow(b);
      if (aScore !== bScore) return bScore - aScore;
      const aValue = num(a && a.value);
      const bValue = num(b && b.value);
      if (aValue !== bValue) return bValue - aValue;
      return clean(a && a.name ? a.name : '').localeCompare(clean(b && b.name ? b.name : ''), undefined, { sensitivity: 'base' });
    });
    return sorted.slice(0, Math.max(1, Math.floor(num(limit))));
  }

  function hoverQtyStateForPreview() {
    if (S.lastGroupQtyState && typeof S.lastGroupQtyState === 'object') return S.lastGroupQtyState;
    const rows = Array.isArray(S.lastFilteredRows) ? S.lastFilteredRows : [];
    S.lastGroupQtyState = buildGroupQtyState(rows, 'g_qty');
    return S.lastGroupQtyState;
  }

  function hoverQtyMetricForRow(rowInput, qtyStateInput = null) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const amount = num(row.amount);
    if (!(amount > 0)) return 0;
    const qtyState = qtyStateInput && typeof qtyStateInput === 'object'
      ? qtyStateInput
      : hoverQtyStateForPreview();
    if (!qtyState || !qtyState.resolvedMode) return 0;
    const factors = quantityFactorCandidatesForRow(row);
    const factor = num(factors[qtyState.resolvedMode]);
    if (!(factor > 0)) return 0;
    const divisor = num(qtyState.displaySpec && qtyState.displaySpec.divisor ? qtyState.displaySpec.divisor : 1) || 1;
    return (amount * factor) / divisor;
  }

  function hoverFacetMetricConfig(facetTypeInput, chartIdInput = '') {
    const facetType = normalizeFacetType(facetTypeInput);
    const chartId = clean(chartIdInput || '');
    const chartTheme = chartId ? chartTitleById(chartId) : '';
    const generic = {
      key: chartId || 'generic',
      chartTheme,
      topLabel: t('hover_preview_top_products_label'),
      metricLabel: langText('Score', 'Score'),
      computeRowMetric: (row) => hoverPurchaseScoreForRow(row),
      formatMetric: (metricValue, row) => {
        const price = hoverPreviewRowPrice(row);
        if (price > 0) return fmtMoneyUi(price);
        return fmt(metricValue, 0);
      },
      summaryText: (rows) => `${langText('Produits', 'Products')}: ${fmtProducts((Array.isArray(rows) ? rows : []).length, 0)}`,
      showFunEquivalents: true,
    };
    if (!facetType || !chartId) return generic;

    if (chartId === 'g_val') {
      return {
        key: 'g_val',
        chartTheme,
        topLabel: langText('Top 5 produits à plus forte valeur', 'Top 5 highest-value products'),
        metricLabel: t('metric_value_prefix'),
        computeRowMetric: (row) => num(row && row.value),
        formatMetric: (metricValue) => fmtMoneyUi(metricValue),
        summaryText: (rows) => {
          const total = (Array.isArray(rows) ? rows : []).reduce((sum, row) => sum + num(row && row.value), 0);
          return `${t('kpi_total_value')}: ${fmtMoneyUi(total)}`;
        },
        showFunEquivalents: false,
      };
    }

    if (chartId === 'g_cal') {
      return {
        key: 'g_cal',
        chartTheme,
        topLabel: langText('Top 5 produits les plus caloriques', 'Top 5 highest-calorie products'),
        metricLabel: t('kpi_calories'),
        computeRowMetric: (row) => num(row && row.calories),
        formatMetric: (metricValue) => fmtKcal(metricValue),
        summaryText: (rows) => {
          const total = (Array.isArray(rows) ? rows : []).reduce((sum, row) => sum + num(row && row.calories), 0);
          return `${t('kpi_calories')}: ${fmtKcal(total)}`;
        },
        showFunEquivalents: false,
      };
    }

    if (chartId === 'g_qty') {
      const qtyState = hoverQtyStateForPreview();
      const isVolume = qtyState && qtyState.displaySpec && qtyState.displaySpec.domain === 'volume';
      const metricLabel = isVolume ? langText('Volume', 'Volume') : langText('Poids', 'Weight');
      const topLabel = isVolume
        ? langText('Top 5 produits les plus volumineux', 'Top 5 largest-volume products')
        : langText('Top 5 produits les plus lourds', 'Top 5 heaviest products');
      return {
        key: `g_qty|${clean(qtyState && qtyState.modeLabel ? qtyState.modeLabel : '')}`,
        chartTheme,
        topLabel,
        metricLabel,
        computeRowMetric: (row) => hoverQtyMetricForRow(row, qtyState),
        formatMetric: (metricValue) => fmtQtyWithDisplay(metricValue, qtyState && qtyState.displaySpec ? qtyState.displaySpec : null),
        summaryText: (rows) => {
          const total = (Array.isArray(rows) ? rows : []).reduce((sum, row) => sum + hoverQtyMetricForRow(row, qtyState), 0);
          const baseLabel = isVolume
            ? langText('Volume total', 'Total volume')
            : langText('Poids total', 'Total weight');
          const mode = clean(qtyState && qtyState.unitBadgeText ? qtyState.unitBadgeText : '');
          const main = `${baseLabel}: ${fmtQtyWithDisplay(total, qtyState && qtyState.displaySpec ? qtyState.displaySpec : null)}`;
          return mode ? `${main} | ${mode}` : main;
        },
        showFunEquivalents: false,
      };
    }

    if (chartId === 'brand_price') {
      return {
        key: 'brand_price',
        chartTheme,
        topLabel: langText('Top 5 produits au prix unitaire le plus élevé', 'Top 5 highest unit-price products'),
        metricLabel: t('metric_price_prefix'),
        computeRowMetric: (row) => hoverPreviewRowPrice(row),
        formatMetric: (metricValue) => fmtMoneyUi(metricValue),
        summaryText: (rows) => {
          const current = Array.isArray(rows) ? rows : [];
          const priced = current
            .map((row) => hoverPreviewRowPrice(row))
            .filter((price) => num(price) > 0);
          const avg = priced.length ? (priced.reduce((sum, price) => sum + num(price), 0) / priced.length) : 0;
          return `${t('kpi_avg_price')}: ${fmtMoneyUi(avg)}`;
        },
        showFunEquivalents: false,
      };
    }

    if (chartId === 'brand_rel') {
      return {
        key: 'brand_rel',
        chartTheme,
        topLabel: langText('Top 5 produits à plus forte valeur', 'Top 5 highest-value products'),
        metricLabel: t('metric_value_prefix'),
        computeRowMetric: (row) => num(row && row.value),
        formatMetric: (metricValue) => fmtMoneyUi(metricValue),
        summaryText: (rows) => {
          const current = Array.isArray(rows) ? rows : [];
          const totalValue = current.reduce((sum, row) => sum + num(row && row.value), 0);
          const priced = current
            .map((row) => hoverPreviewRowPrice(row))
            .filter((price) => num(price) > 0);
          const avg = priced.length ? (priced.reduce((sum, price) => sum + num(price), 0) / priced.length) : 0;
          return `${t('kpi_total_value')}: ${fmtMoneyUi(totalValue)} | ${t('kpi_avg_price')}: ${fmtMoneyUi(avg)}`;
        },
        showFunEquivalents: false,
      };
    }

    return generic;
  }

  function facetRowIdentity(rowInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const id = num(row.id);
    if (id > 0) return `id:${id}`;
    return `name:${norm(clean(row.name || ''))}`;
  }

  function topRowsForFacetByMetric(rowsInput, metricConfigInput, limit = 5) {
    const rows = Array.isArray(rowsInput) ? rowsInput : [];
    const cfg = metricConfigInput && typeof metricConfigInput === 'object' ? metricConfigInput : {};
    const compute = typeof cfg.computeRowMetric === 'function'
      ? cfg.computeRowMetric
      : ((row) => hoverPurchaseScoreForRow(row));
    const safeLimit = Math.max(1, Math.floor(num(limit)));

    const scored = rows
      .map((row) => ({ row, metric: num(compute(row)) }))
      .filter((entry) => !!entry.row)
      .sort((a, b) => {
        if (b.metric !== a.metric) return b.metric - a.metric;
        const aValue = num(a.row && a.row.value);
        const bValue = num(b.row && b.row.value);
        if (bValue !== aValue) return bValue - aValue;
        return clean(a.row && a.row.name ? a.row.name : '').localeCompare(clean(b.row && b.row.name ? b.row.name : ''), undefined, { sensitivity: 'base' });
      });

    const positive = scored.filter((entry) => entry.metric > 0);
    const selected = positive.slice(0, safeLimit);

    if (selected.length < safeLimit) {
      const selectedKeys = new Set(selected.map((entry) => facetRowIdentity(entry.row)));
      const fallback = [...rows].sort((a, b) => {
        const aScore = hoverPurchaseScoreForRow(a);
        const bScore = hoverPurchaseScoreForRow(b);
        if (bScore !== aScore) return bScore - aScore;
        const aValue = num(a && a.value);
        const bValue = num(b && b.value);
        return bValue - aValue;
      });
      fallback.forEach((row) => {
        if (selected.length >= safeLimit) return;
        const key = facetRowIdentity(row);
        if (selectedKeys.has(key)) return;
        selected.push({ row, metric: num(compute(row)) });
        selectedKeys.add(key);
      });
    }

    return selected.slice(0, safeLimit);
  }

  function facetLogoPreviewHtml(facetTypeInput, facetValueInput, sampleRows = []) {
    const facetType = normalizeFacetType(facetTypeInput);
    const value = clean(facetValueInput || '');
    if (!facetType || !value) return '';

    let logoUrl = '';
    if (facetType === 'brand') logoUrl = brandLogoEffectiveUrl(value);
    if (facetType === 'group') logoUrl = groupLogoEffectiveUrl(value);
    if (!logoUrl) {
      const withPicture = (Array.isArray(sampleRows) ? sampleRows : []).find((row) => clean(row && row.pictureUrl ? row.pictureUrl : ''));
      logoUrl = clean(withPicture && withPicture.pictureUrl ? withPicture.pictureUrl : '');
    }
    if (logoUrl) {
      return `<span class="dash-hover-preview-logo"><img src="${escapeHtml(logoUrl)}" alt=""></span>`;
    }

    const initial = value ? value.slice(0, 1).toUpperCase() : '?';
    return `<span class="dash-hover-preview-logo dash-hover-preview-thumb-fallback">${escapeHtml(initial)}</span>`;
  }

  function hoverPreviewThumbHtml(rowInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const name = clean(row.name || t('default_product'));
    const imageUrl = clean(row.pictureUrl || '');
    const initials = name ? name.slice(0, 1).toUpperCase() : '?';
    return imageUrl
      ? `<span class="dash-hover-preview-thumb"><img src="${escapeHtml(imageUrl)}" alt=""></span>`
      : `<span class="dash-hover-preview-thumb dash-hover-preview-thumb-fallback">${escapeHtml(initials)}</span>`;
  }

  function hoverPreviewProductItemHtml(rowInput, options = {}) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const productName = clean(row.name || t('default_product'));
    const dueText = formatDueDate(row && row.due ? row.due : null);
    const showDue = options.includeDue !== false;
    const price = hoverPreviewRowPrice(row);
    const priceText = price > 0 ? fmtMoneyUi(price) : t('default_none');
    const recipes = hoverRecipesForProduct(row.id, 3);
    const recipeText = !S.hoverRecipeMapLoaded
      ? escapeHtml(t('hover_preview_loading'))
      : (recipes.names.length
        ? `${recipes.names.map((name) => escapeHtml(name)).join(', ')}${recipes.more > 0 ? ` ${escapeHtml(t('hover_preview_recipes_more', { count: fmt(recipes.more, 0) }))}` : ''}`
        : escapeHtml(t('hover_preview_recipes_none')));
    const dueChip = showDue
      ? `<span class="dash-hover-preview-chip">${escapeHtml(t('hover_preview_due_label'))}: ${escapeHtml(dueText)}</span>`
      : '';

    return `
      <div class="dash-hover-preview-item">
        ${hoverPreviewThumbHtml(row)}
        <div class="dash-hover-preview-main">
          <div class="dash-hover-preview-name">${escapeHtml(productName)}</div>
          <div class="dash-hover-preview-meta">
            <span class="dash-hover-preview-chip">${escapeHtml(t('hover_preview_price_label'))}: ${escapeHtml(priceText)}</span>
            ${dueChip}
          </div>
          <div class="dash-hover-preview-recipes"><strong>${escapeHtml(t('hover_preview_recipes_label'))}:</strong> ${recipeText}</div>
        </div>
      </div>
    `;
  }

  function hoverPreviewFacetTopItemHtml(rowInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const productName = clean(row.name || t('default_product'));
    const range = hoverPriceRangeForProduct(row.id, row);
    const low = range.low > 0 ? fmt(range.low, 2) : fmt(0, 2);
    const high = range.high > 0 ? fmt(range.high, 2) : fmt(0, 2);
    const currency = clean(t('hover_preview_currency_symbol') || currencySymbolForUi());
    return `
      <div class="dash-hover-preview-item dash-hover-preview-item-tight">
        ${hoverPreviewThumbHtml(row)}
        <div class="dash-hover-preview-main">
          <div class="dash-hover-preview-name">${escapeHtml(productName)}</div>
          <div class="dash-hover-preview-range">
            <i class="fa-solid fa-arrow-down" aria-hidden="true"></i>
            <span title="${escapeHtml(t('hover_preview_low_label'))}">${escapeHtml(low)}</span>
            <i class="fa-solid fa-arrow-up" aria-hidden="true"></i>
            <span title="${escapeHtml(t('hover_preview_high_label'))}">${escapeHtml(high)}</span>
            <span class="dash-hover-preview-range-currency">${escapeHtml(currency)}</span>
          </div>
        </div>
      </div>
    `;
  }

  function hoverPreviewFacetMetricItemHtml(itemInput, metricConfigInput) {
    const item = itemInput && typeof itemInput === 'object' ? itemInput : {};
    const row = item.row && typeof item.row === 'object' ? item.row : {};
    const cfg = metricConfigInput && typeof metricConfigInput === 'object' ? metricConfigInput : {};
    const productName = clean(row.name || t('default_product'));
    const metricLabel = clean(cfg.metricLabel || langText('Valeur', 'Value'));
    const metricValue = typeof cfg.formatMetric === 'function'
      ? clean(cfg.formatMetric(num(item.metric), row))
      : fmt(num(item.metric), 2);
    return `
      <div class="dash-hover-preview-item dash-hover-preview-item-tight">
        ${hoverPreviewThumbHtml(row)}
        <div class="dash-hover-preview-main">
          <div class="dash-hover-preview-name">${escapeHtml(productName)}</div>
          <div class="dash-hover-preview-meta">
            <span class="dash-hover-preview-chip">${escapeHtml(metricLabel)}: ${escapeHtml(metricValue || t('default_none'))}</span>
          </div>
        </div>
      </div>
    `;
  }

  function showHoverPreviewHtml(contextKey, key, html, point) {
    if (!contextKey || !key || !html || !point) {
      hideChartHoverPreview();
      return;
    }
    if (S.hoverPreviewContextKey !== contextKey) {
      S.hoverPreviewContextKey = contextKey;
      S.hoverPreviewRenderToken += 1;
    }
    const element = ensureHoverPreviewElement();
    if (S.hoverPreviewKey !== key) {
      element.innerHTML = html;
      S.hoverPreviewKey = key;
    }
    element.classList.remove('d-none');
    placeHoverPreview(element, point);
  }

  function queueHoverPreviewRerender(contextKey, rerenderFn) {
    if (!contextKey || typeof rerenderFn !== 'function') return;
    if (S.hoverPreviewPendingContexts.has(contextKey)) return;
    S.hoverPreviewPendingContexts.add(contextKey);
    const token = S.hoverPreviewRenderToken;
    Promise.allSettled([
      ensureHoverRecipeMapLoaded(),
      ensureHoverPriceRangeMapLoaded(),
      ensureHoverPurchaseStatsMapLoaded(),
    ]).then(() => {
      S.hoverPreviewPendingContexts.delete(contextKey);
      if (S.hoverPreviewContextKey !== contextKey) return;
      if (S.hoverPreviewRenderToken !== token) return;
      rerenderFn();
    }).catch(() => {
      S.hoverPreviewPendingContexts.delete(contextKey);
    });
  }

  function showProductHoverPreview(productIdInput, evt = null, chart = null, anchorEl = null, fallbackName = '') {
    ensureHoverEnrichmentDataLoaded();
    const productId = num(productIdInput);
    let row = productId > 0 ? findProductRowById(productId) : null;
    if (!row && fallbackName) {
      row = findProductRowByName(fallbackName);
    }
    if (!row) {
      if (!fallbackName) {
        hideChartHoverPreview();
        return;
      }
      row = {
        id: productId > 0 ? productId : 0,
        name: clean(fallbackName || t('default_product')),
        pictureUrl: '',
        price: 0,
        avgPrice: 0,
        due: null,
      };
    }
    const point = hoverPreviewEventPoint(evt, chart) || hoverPreviewPointFromElement(anchorEl);
    const contextKey = `hover-product|${num(row.id) || norm(row.name || '')}`;
    const key = `${contextKey}|r${S.hoverRecipeMapLoaded ? 1 : 0}|p${S.hoverPriceRangeLoaded ? 1 : 0}`;
    const html = `
      <div class="dash-hover-preview-head">
        <div class="dash-hover-preview-title">${escapeHtml(clean(row.name || t('default_product')))}</div>
      </div>
      <div class="dash-hover-preview-list">
        ${hoverPreviewProductItemHtml(row, { includeDue: true })}
      </div>
    `;
    showHoverPreviewHtml(contextKey, key, html, point);
    if (!S.hoverRecipeMapLoaded || !S.hoverPriceRangeLoaded) {
      const fallback = clean(fallbackName || row.name || '');
      queueHoverPreviewRerender(contextKey, () => {
        showProductHoverPreview(productIdInput, null, null, anchorEl, fallback);
      });
    }
  }

  function showFacetHoverPreview(facetTypeInput, facetValueInput, evt = null, chart = null, anchorEl = null, optionsInput = null) {
    ensureHoverEnrichmentDataLoaded();
    const facetType = normalizeFacetType(facetTypeInput);
    const facetValue = clean(facetValueInput || '');
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const chartId = clean(options.chartId || '');
    if (!facetType || !facetValue) {
      hideChartHoverPreview();
      return;
    }
    if (norm(facetValue) === norm(t('others_label')) || norm(facetValue) === norm(t('no_data'))) {
      hideChartHoverPreview();
      return;
    }

    const allFacetRows = hoverPreviewFacetRows(facetType, facetValue);
    const metricCfg = hoverFacetMetricConfig(facetType, chartId);
    const scoredRows = topRowsForFacetByMetric(allFacetRows, metricCfg, 5);
    const topRows = scoredRows.map((entry) => entry.row);
    const total = allFacetRows.length;
    const logoHtml = facetLogoPreviewHtml(facetType, facetValue, allFacetRows);
    const listHtml = scoredRows.length
      ? scoredRows.map((item) => hoverPreviewFacetMetricItemHtml(item, metricCfg)).join('')
      : `<div class="dash-hover-preview-empty">${escapeHtml(t('hover_preview_empty'))}</div>`;
    const showFunEquivalents = metricCfg.showFunEquivalents === true;
    const totalValue = allFacetRows.reduce((sum, row) => sum + num(row && row.value), 0);
    const totalCalories = allFacetRows.reduce((sum, row) => sum + num(row && row.calories), 0);
    const priceFunHtml = showFunEquivalents ? hoverEquivalentSectionHtml('price', totalValue) : '';
    const caloriesFunHtml = showFunEquivalents ? hoverEquivalentSectionHtml('calories', totalCalories) : '';
    const titlePrefix = facetType === 'brand' ? t('meta_brand') : t('meta_group');
    const point = hoverPreviewEventPoint(evt, chart) || hoverPreviewPointFromElement(anchorEl);
    const idsKey = topRows.map((row) => num(row && row.id)).join(',');
    const metricKey = clean(metricCfg && metricCfg.key ? metricCfg.key : chartId || 'generic');
    const contextKey = `hover-facet|${facetType}|${norm(facetValue)}|${metricKey}`;
    const metricSig = scoredRows.map((item) => fmt(num(item.metric), 4)).join(',');
    const key = `${contextKey}|${total}|${idsKey}|m${metricSig}|s${S.hoverPurchaseStatsLoaded ? 1 : 0}|p${S.hoverPriceRangeLoaded ? 1 : 0}`;
    const chartTheme = clean(metricCfg && metricCfg.chartTheme ? metricCfg.chartTheme : '');
    const summaryText = metricCfg && typeof metricCfg.summaryText === 'function'
      ? clean(metricCfg.summaryText(allFacetRows))
      : '';
    const topLabel = clean(metricCfg && metricCfg.topLabel ? metricCfg.topLabel : t('hover_preview_top_products_label'));
    const html = `
      <div class="dash-hover-preview-head">
        <div class="dash-hover-preview-title">${escapeHtml(`${titlePrefix}: ${facetValue}`)}</div>
        <div class="dash-hover-preview-count">${escapeHtml(fmtProducts(total, 0))}</div>
      </div>
      <div class="dash-hover-preview-item mb-2">
        ${logoHtml}
        <div class="dash-hover-preview-main">
          <div class="dash-hover-preview-name">${escapeHtml(facetValue)}</div>
          <div class="dash-hover-preview-meta">
            ${chartTheme ? `<span class="dash-hover-preview-chip">${escapeHtml(chartTheme)}</span>` : ''}
            ${summaryText ? `<span class="dash-hover-preview-chip">${escapeHtml(summaryText)}</span>` : ''}
          </div>
          <div class="dash-hover-preview-section-title">${escapeHtml(topLabel)}</div>
        </div>
      </div>
      <div class="dash-hover-preview-list">${listHtml}</div>
      ${priceFunHtml}
      ${caloriesFunHtml}
    `;
    showHoverPreviewHtml(contextKey, key, html, point);
    if (!S.hoverPriceRangeLoaded || !S.hoverPurchaseStatsLoaded) {
      queueHoverPreviewRerender(contextKey, () => {
        showFacetHoverPreview(facetType, facetValue, null, null, anchorEl, options);
      });
    }
  }

  function normalizedRiskBucketId(labelInput) {
    const label = norm(labelInput || '');
    if (!label || label === norm(t('no_data'))) return '';
    if (label === norm(t('status_below_min'))) return 'below';
    if (label === norm(t('status_due_soon'))) return 'soon';
    if (label === norm(t('status_overdue'))) return 'overdue';
    if (label === norm(t('status_expired'))) return 'expired';
    return '';
  }

  function normalizedDueBucketId(labelInput) {
    const label = norm(labelInput || '');
    if (!label || label === norm(t('no_data'))) return '';
    if (label === norm(t('due_over'))) return 'late';
    if (label === norm(t('due_0_3'))) return 'd3';
    if (label === norm(t('due_4_7'))) return 'd7';
    if (label === norm(t('due_8_30'))) return 'd30';
    if (label === norm(t('due_30_plus'))) return 'later';
    if (label === norm(t('due_none'))) return 'none';
    return '';
  }

  function rowMatchesRiskBucket(row, bucketId) {
    if (!row || !bucketId) return false;
    if (bucketId === 'below') return row.below === true;
    if (bucketId === 'soon') return row.soon === true;
    if (bucketId === 'overdue') return row.overdue === true;
    if (bucketId === 'expired') return row.expired === true;
    return false;
  }

  function rowMatchesDueBucket(row, bucketId) {
    if (!row || !bucketId) return false;
    if (bucketId === 'none') return !row.due;
    const diff = dueDiffDays(row.due || null);
    if (!Number.isFinite(diff)) return false;
    if (bucketId === 'late') return diff < 0;
    if (bucketId === 'd3') return diff >= 0 && diff <= 3;
    if (bucketId === 'd7') return diff >= 4 && diff <= 7;
    if (bucketId === 'd30') return diff >= 8 && diff <= 30;
    if (bucketId === 'later') return diff > 30;
    return false;
  }

  function sortRowsForHoverPreview(rowsInput) {
    const rows = Array.isArray(rowsInput) ? [...rowsInput] : [];
    rows.sort((a, b) => {
      const aDiff = dueDiffDays(a && a.due ? a.due : null);
      const bDiff = dueDiffDays(b && b.due ? b.due : null);
      const aHasDiff = Number.isFinite(aDiff);
      const bHasDiff = Number.isFinite(bDiff);
      if (aHasDiff && bHasDiff && aDiff !== bDiff) return aDiff - bDiff;
      if (aHasDiff && !bHasDiff) return -1;
      if (!aHasDiff && bHasDiff) return 1;
      const aValue = num(a && a.value ? a.value : 0);
      const bValue = num(b && b.value ? b.value : 0);
      if (aValue !== bValue) return bValue - aValue;
      return clean(a && a.name ? a.name : '').localeCompare(clean(b && b.name ? b.name : ''), undefined, { sensitivity: 'base' });
    });
    return rows;
  }

  function hoverPreviewRowsByBucket(chartId, bucketLabel, limitInput = 5) {
    const chart = clean(chartId || '');
    const label = clean(bucketLabel || '');
    const rows = hoverPreviewRowsSource();
    if (!chart || !label || !rows.length) return { rows: [], total: 0 };

    const bucketId = chart === 'risk'
      ? normalizedRiskBucketId(label)
      : normalizedDueBucketId(label);
    if (!bucketId) return { rows: [], total: 0 };

    const filtered = rows.filter((row) => (
      chart === 'risk'
        ? rowMatchesRiskBucket(row, bucketId)
        : rowMatchesDueBucket(row, bucketId)
    ));
    const sorted = sortRowsForHoverPreview(filtered);
    const limit = Math.floor(num(limitInput));
    const visible = limit > 0 ? sorted.slice(0, limit) : sorted;
    return { rows: visible, total: sorted.length, allRows: sorted };
  }

  function hoverPreviewEventPoint(evt, chart) {
    const nativeEvt = evt && evt.native ? evt.native : evt;
    const xDirect = nativeEvt && Number.isFinite(nativeEvt.clientX) ? nativeEvt.clientX : NaN;
    const yDirect = nativeEvt && Number.isFinite(nativeEvt.clientY) ? nativeEvt.clientY : NaN;
    if (Number.isFinite(xDirect) && Number.isFinite(yDirect)) return { x: xDirect, y: yDirect };

    const canvas = chart && chart.canvas ? chart.canvas : null;
    if (!canvas) return null;
    const rect = canvas.getBoundingClientRect();
    const rawX = nativeEvt && Number.isFinite(nativeEvt.x) ? nativeEvt.x : NaN;
    const rawY = nativeEvt && Number.isFinite(nativeEvt.y) ? nativeEvt.y : NaN;
    if (!Number.isFinite(rawX) || !Number.isFinite(rawY)) return null;

    const looksAbsolute = rawX >= rect.left - 6 && rawX <= rect.right + 6 && rawY >= rect.top - 6 && rawY <= rect.bottom + 6;
    if (looksAbsolute) return { x: rawX, y: rawY };
    return { x: rect.left + rawX, y: rect.top + rawY };
  }

  function placeHoverPreview(element, point) {
    if (!element || !point) return;
    const pad = 12;
    const gap = 16;
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

    element.style.left = '0px';
    element.style.top = '0px';
    const rect = element.getBoundingClientRect();
    let left = point.x + gap;
    let top = point.y + gap;
    if (left + rect.width > vw - pad) left = Math.max(pad, point.x - rect.width - gap);
    if (top + rect.height > vh - pad) top = Math.max(pad, point.y - rect.height - gap);
    element.style.left = `${Math.round(left)}px`;
    element.style.top = `${Math.round(top)}px`;
  }

  function hoverPreviewItemHtml(row) {
    return hoverPreviewProductItemHtml(row, { includeDue: true });
  }

  function showRiskDueHoverPreview(chartId, bucketLabel, evt, chart, anchorEl = null) {
    ensureHoverEnrichmentDataLoaded();
    const chartKey = clean(chartId || '');
    const label = clean(bucketLabel || '');
    if (!chartKey || !label) {
      hideChartHoverPreview();
      return;
    }
    if (norm(label) === norm(t('no_data')) || norm(label) === norm(t('others_label'))) {
      hideChartHoverPreview();
      return;
    }

    const point = hoverPreviewEventPoint(evt, chart) || hoverPreviewPointFromElement(anchorEl);
    if (!point) {
      hideChartHoverPreview();
      return;
    }

    const sample = hoverPreviewRowsByBucket(chartKey, label);
    const rows = Array.isArray(sample.rows) ? sample.rows : [];
    const total = Math.max(0, Math.floor(num(sample.total)));

    const contextKey = `hover-bucket|${chartKey}|${norm(label)}`;
    const key = `${contextKey}|${total}|${rows.map((r) => num(r.id)).join(',')}|r${S.hoverRecipeMapLoaded ? 1 : 0}|p${S.hoverPriceRangeLoaded ? 1 : 0}`;
    if (!rows.length) {
      showHoverPreviewHtml(contextKey, key, `
        <div class="dash-hover-preview-head">
          <div class="dash-hover-preview-title">${escapeHtml(label)}</div>
          <div class="dash-hover-preview-count">${escapeHtml(fmtProducts(0))}</div>
        </div>
        <div class="dash-hover-preview-empty">${escapeHtml(t('hover_preview_empty'))}</div>
      `, point);
      return;
    }

    const rowsHtml = rows.map((row) => hoverPreviewItemHtml(row)).join('');
    const moreHtml = total > rows.length
      ? `<div class="dash-hover-preview-more">${escapeHtml(t('hover_preview_more', { count: fmt(total - rows.length, 0) }))}</div>`
      : '';
    const html = `
      <div class="dash-hover-preview-head">
        <div class="dash-hover-preview-title">${escapeHtml(label)}</div>
        <div class="dash-hover-preview-count">${escapeHtml(fmtProducts(total))}</div>
      </div>
      <div class="dash-hover-preview-list">${rowsHtml}</div>
      ${moreHtml}
    `;
    showHoverPreviewHtml(contextKey, key, html, point);
    if (!S.hoverRecipeMapLoaded || !S.hoverPriceRangeLoaded) {
      queueHoverPreviewRerender(contextKey, () => {
        showRiskDueHoverPreview(chartKey, label, null, null, anchorEl);
      });
    }
  }

  function showChartEntityHoverPreview(chartIdInput, indexInput, contextDataInput, evt = null, chart = null, anchorEl = null) {
    const chartId = clean(chartIdInput || '');
    const index = Number.isInteger(indexInput) ? indexInput : parseInt(String(indexInput || '-1'), 10);
    const contextData = Array.isArray(contextDataInput) ? contextDataInput : [];
    if (!chartId || !Number.isInteger(index) || index < 0 || index >= contextData.length) {
      hideChartHoverPreview();
      return;
    }

    if (chartId === 'risk' || chartId === 'due') {
      const row = contextData[index];
      const label = clean(Array.isArray(row) ? row[0] : row && row.label ? row.label : '');
      showRiskDueHoverPreview(chartId, label, evt, chart, anchorEl);
      return;
    }

    if (chartId === 'g_val' || chartId === 'g_qty' || chartId === 'g_cal') {
      const row = contextData[index];
      const group = clean(Array.isArray(row) ? row[0] : row && (row.group || row.label || row.name) ? (row.group || row.label || row.name) : '');
      showFacetHoverPreview('group', group, evt, chart, anchorEl, { chartId });
      return;
    }

    if (chartId === 'brand_price') {
      const row = contextData[index];
      const brand = clean(Array.isArray(row) ? row[0] : row && (row.brand || row.name || row.label) ? (row.brand || row.name || row.label) : '');
      showFacetHoverPreview('brand', brand, evt, chart, anchorEl, { chartId });
      return;
    }

    if (chartId === 'brand_rel') {
      const point = contextData[index] || {};
      const brand = clean(point.brand || point.name || point.label || '');
      showFacetHoverPreview('brand', brand, evt, chart, anchorEl, { chartId });
      return;
    }

    if (chartId === 'top_val' || chartId === 'price_val') {
      const point = contextData[index] || {};
      const productId = num(point.id || point.productId);
      const productName = clean(point.name || point.label || '');
      showProductHoverPreview(productId, evt, chart, anchorEl, productName);
      return;
    }

    hideChartHoverPreview();
  }

  function showHoverPreviewForInteractiveElement(element, evt = null, chart = null) {
    const target = element && typeof element.closest === 'function'
      ? element.closest('.dash-product-link, .dash-stock-facet-link')
      : null;
    if (!target) return false;
    if (target.classList && target.classList.contains('dash-no-hover-preview')) {
      hideChartHoverPreview();
      return false;
    }

    if (target.classList.contains('dash-product-link')) {
      const productId = num(target.getAttribute('data-product-id') || '0');
      const fallbackName = clean(target.textContent || '');
      showProductHoverPreview(productId, evt, chart, target, fallbackName);
      return true;
    }

    if (target.classList.contains('dash-stock-facet-link')) {
      const facet = stockFacetFromElement(target);
      if (!facet) return false;
      showFacetHoverPreview(facet.type, facet.value, evt, chart, target);
      return true;
    }

    return false;
  }

  function bindEntityHoverPreviewHandlers(rootElement) {
    const root = rootElement;
    if (!root || root.dataset.entityHoverPreviewBound === '1') return;

    root.addEventListener('mouseover', (event) => {
      showHoverPreviewForInteractiveElement(event && event.target ? event.target : null, event, null);
    });
    root.addEventListener('mousemove', (event) => {
      showHoverPreviewForInteractiveElement(event && event.target ? event.target : null, event, null);
    });
    root.addEventListener('mouseout', (event) => {
      const target = event && event.target && typeof event.target.closest === 'function'
        ? event.target.closest('.dash-product-link, .dash-stock-facet-link')
        : null;
      if (!target) return;
      const next = event.relatedTarget;
      if (next && target.contains(next)) return;
      if (next && typeof next.closest === 'function' && next.closest('.dash-product-link, .dash-stock-facet-link')) return;
      hideChartHoverPreview();
    });
    root.addEventListener('focusin', (event) => {
      const target = event && event.target;
      if (!target) return;
      showHoverPreviewForInteractiveElement(target, event, null);
    });
    root.addEventListener('focusout', (event) => {
      const next = event.relatedTarget;
      if (next && root.contains(next) && typeof next.closest === 'function' && next.closest('.dash-product-link, .dash-stock-facet-link')) return;
      hideChartHoverPreview();
    });
    root.addEventListener('mouseleave', hideChartHoverPreview);
    root.dataset.entityHoverPreviewBound = '1';
  }

  function alertPartsFromRow(row) {
    const parts = [];
    if (row && row.below) parts.push(t('status_below_min'));
    if (row && row.soon) parts.push(t('status_due_soon'));
    if (row && row.overdue) parts.push(t('status_overdue'));
    if (row && row.expired) parts.push(t('status_expired'));
    return parts;
  }

  function findProductRowById(productId) {
    const id = num(productId);
    if (id <= 0) return null;
    const all = Array.isArray(S.lastAllRows) ? S.lastAllRows : [];
    const filtered = Array.isArray(S.lastFilteredRows) ? S.lastFilteredRows : [];
    return filtered.find((r) => num(r.id) === id) || all.find((r) => num(r.id) === id) || null;
  }

  function quantityBaseSummaryForRow(rowInput, amountOverride = null) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const amount = Number.isFinite(num(amountOverride)) ? num(amountOverride) : num(row.amount);
    if (!(amount > 0)) {
      return {
        amount,
        massBase: 0,
        volumeBase: 0,
        massRows: 0,
        volumeRows: 0,
      };
    }
    const factors = quantityFactorCandidatesForRow(row);
    const massFactor = num(factors && factors.mass);
    const volumeFactor = num(factors && factors.volume);
    const massBase = massFactor > 0 ? amount * massFactor : 0;
    const volumeBase = volumeFactor > 0 ? amount * volumeFactor : 0;
    return {
      amount,
      massBase,
      volumeBase,
      massRows: massBase > 0 ? 1 : 0,
      volumeRows: volumeBase > 0 ? 1 : 0,
    };
  }

  function aggregateRowsByPredicate(predicateFn) {
    const rows = (Array.isArray(S.lastFilteredRows) && S.lastFilteredRows.length > 0)
      ? S.lastFilteredRows
      : (Array.isArray(S.lastAllRows) ? S.lastAllRows : []);
    const selected = rows.filter((row) => {
      try {
        return predicateFn(row);
      } catch (_err) {
        return false;
      }
    });

    const out = {
      n: selected.length,
      value: 0,
      amount: 0,
      qtyMassBase: 0,
      qtyVolumeBase: 0,
      qtyMassRows: 0,
      qtyVolumeRows: 0,
      calories: 0,
      priceSum: 0,
      priceN: 0,
      alerts: 0,
      soonOrLate: 0,
    };

    selected.forEach((r) => {
      out.value += num(r.value);
      const rowAmount = num(r.amount);
      out.amount += rowAmount;
      const qtySummary = quantityBaseSummaryForRow(r, rowAmount);
      out.qtyMassBase += num(qtySummary.massBase);
      out.qtyVolumeBase += num(qtySummary.volumeBase);
      out.qtyMassRows += num(qtySummary.massRows);
      out.qtyVolumeRows += num(qtySummary.volumeRows);
      out.calories += num(r.calories);
      if (num(r.price) > 0) {
        out.priceSum += num(r.price);
        out.priceN += 1;
      }
      if (r.below || r.soon || r.overdue || r.expired) out.alerts += 1;
      const diff = dueDiffDays(r.due);
      if (diff !== null && diff <= 3) out.soonOrLate += 1;
    });

    out.avgPrice = out.priceN > 0 ? out.priceSum / out.priceN : 0;
    return out;
  }

  function firstRowByPredicate(predicateFn) {
    const rows = (Array.isArray(S.lastFilteredRows) && S.lastFilteredRows.length > 0)
      ? S.lastFilteredRows
      : (Array.isArray(S.lastAllRows) ? S.lastAllRows : []);
    for (const row of rows) {
      try {
        if (predicateFn(row)) return row;
      } catch (_err) {
        // Ignore row-level predicate failures.
      }
    }
    return null;
  }

  function buildFocusThemes(focus) {
    const lines = [];
    if (!focus) return lines;
    const focusUnit = cleanUnitLabel(focus.stockUnitName || '');
    const en = resolveUiLanguage() === 'en';

    if (focus.type === 'product') {
      lines.push(en
        ? `Budget: value ${fmtMoney(num(focus.value))} | price ${fmtMoney(num(focus.price))}.`
        : `Budget: valeur ${fmtMoney(num(focus.value))} | prix ${fmtMoney(num(focus.price))}.`);
      lines.push(en
        ? `Stock: quantity ${fmtQtyProduct(num(focus.amount), focusUnit)} | group ${clean(focus.group || t('default_no_group'))}.`
        : `Stock: quantité ${fmtQtyProduct(num(focus.amount), focusUnit)} | groupe ${clean(focus.group || t('default_no_group'))}.`);
      lines.push(en
        ? `Risk: due ${focus.dueText || t('due_none')} | alerts ${focus.alertText || t('default_none')}.`
        : `Risque: échéance ${focus.dueText || t('due_none')} | alertes ${focus.alertText || t('default_none')}.`);
      if (num(focus.calories) > 0) {
        lines.push(en
          ? `Nutrition: ${fmtKcal(num(focus.calories))} on visible stock.`
          : `Nutrition: ${fmtKcal(num(focus.calories))} sur le stock visible.`);
      }
    } else if (focus.type === 'brand') {
      lines.push(en
        ? `Brand position: ${fmtProducts(num(focus.n))}, value ${fmtMoney(num(focus.value))}.`
        : `Position marque: ${fmtProducts(num(focus.n))}, valeur ${fmtMoney(num(focus.value))}.`);
      lines.push(en
        ? `Brand average price: ${fmtMoney(num(focus.avgPrice))}.`
        : `Prix moyen marque: ${fmtMoney(num(focus.avgPrice))}.`);
      lines.push(en
        ? `Brand risk: ${fmtProducts(num(focus.alerts))} with alerts.`
        : `Risque marque: ${fmtProducts(num(focus.alerts))} en alerte.`);
      lines.push(en
        ? `Brand rotation: ${fmtProducts(num(focus.soonOrLate))} overdue or <= 3 days.`
        : `Rotation marque: ${fmtProducts(num(focus.soonOrLate))} dépassés ou <= 3 jours.`);
    } else if (focus.type === 'group') {
      lines.push(en ? `Group: ${clean(focus.label)}.` : `Groupe: ${clean(focus.label)}.`);
      lines.push(en
        ? `Value ${fmtMoney(num(focus.value))} | quantity ${fmtQtyByChart(focus.chartId, num(focus.amount))}.`
        : `Valeur ${fmtMoney(num(focus.value))} | quantité ${fmtQtyByChart(focus.chartId, num(focus.amount))}.`);
      if (num(focus.calories) > 0) lines.push(en ? `Group calories: ${fmtKcal(num(focus.calories))}.` : `Calories groupe: ${fmtKcal(num(focus.calories))}.`);
      lines.push(en ? `Group alerts: ${fmtAlerts(num(focus.alerts))}.` : `Alertes groupe: ${fmtAlerts(num(focus.alerts))}.`);
    } else {
      lines.push(en ? `Category: ${clean(focus.label)}.` : `Catégorie: ${clean(focus.label)}.`);
      if (focus.value !== undefined) lines.push(en ? `Impact: ${fmtProducts(num(focus.value))}.` : `Impact: ${fmtProducts(num(focus.value))}.`);
      if (focus.chartTitle) lines.push(en ? `Chart context: ${focus.chartTitle}.` : `Contexte graphique: ${focus.chartTitle}.`);
    }

    return lines;
  }

  function buildFocusPrompt(focus, promptStyle = 'full') {
    const themes = buildFocusThemes(focus);
    const facts = [];
    const focusUnit = cleanUnitLabel(focus && focus.stockUnitName ? focus.stockUnitName : '');
    const lang = resolveUiLanguage();
    if (focus.label) facts.push(lang === 'en' ? `Element: ${focus.label}` : `Élément: ${focus.label}`);
    if (focus.chartTitle) facts.push(lang === 'en' ? `Chart: ${focus.chartTitle}` : `Graphique: ${focus.chartTitle}`);
    if (focus.type) facts.push(lang === 'en' ? `Type: ${focus.type}` : `Type: ${focus.type}`);
    if (focus.value !== undefined) facts.push(lang === 'en' ? `Measured value: ${fmtMoney(num(focus.value))}` : `Valeur mesurée: ${fmtMoney(num(focus.value))}`);
    if (focus.amount !== undefined) {
      const qty = focus.type === 'product'
        ? fmtQtyProduct(num(focus.amount), focusUnit)
        : fmtQtyByChart(focus.chartId, num(focus.amount));
      facts.push(lang === 'en' ? `Quantity: ${qty}` : `Quantité: ${qty}`);
    }
    if (focus.avgPrice !== undefined && num(focus.avgPrice) > 0) facts.push(lang === 'en' ? `Average price: ${fmtMoney(num(focus.avgPrice))}` : `Prix moyen: ${fmtMoney(num(focus.avgPrice))}`);
    if (focus.price !== undefined && num(focus.price) > 0) facts.push(lang === 'en' ? `Unit price: ${fmtMoney(num(focus.price))}` : `Prix unitaire: ${fmtMoney(num(focus.price))}`);
    if (focus.calories !== undefined && num(focus.calories) > 0) facts.push(lang === 'en' ? `Calories: ${fmtKcal(num(focus.calories))}` : `Calories: ${fmtKcal(num(focus.calories))}`);
    if (focus.dueText) facts.push(lang === 'en' ? `Due date: ${focus.dueText}` : `Échéance: ${focus.dueText}`);
    if (focus.alertText) facts.push(lang === 'en' ? `Alerts: ${focus.alertText}` : `Alertes: ${focus.alertText}`);

    if (lang === 'en' && promptStyle === 'tiny') {
      return [
        'You are a Grocy stock analyst.',
        ...facts.map((f) => `- ${f}`),
        'Return exactly:',
        '1) Ultra-short summary',
        '2) 24h action',
        '3) Watchpoint',
        'Max 70 words.',
      ].join('\n');
    }

    if (lang === 'en' && promptStyle === 'compact') {
      return [
        'You are a pragmatic Grocy stock analyst.',
        'Context:',
        ...facts.map((f) => `- ${f}`),
        'Expected answer:',
        '1) Quick read',
        '2) Main risk',
        '3) Immediate action',
        '4) 7-30 day action',
        'Max 105 words.',
      ].join('\n');
    }

    if (lang === 'en') {
      return [
        'You are a pragmatic Grocy stock analyst.',
        'Provide useful, actionable observations in English.',
        'Clicked context:',
        ...facts.map((f) => `- ${f}`),
        'Predefined themes:',
        ...themes.map((th) => `- ${th}`),
        'Expected response (short):',
        '1) Quick read (max 2 sentences)',
        '2) Main risk',
        '3) Immediate action (24h)',
        '4) Structural action (7-30 days)',
        '5) Metric to monitor',
        'Maximum 140 words.',
      ].join('\n');
    }

    if (promptStyle === 'tiny') {
      return [
        'Analyste stock Grocy en français.',
        ...facts.map((f) => `- ${f}`),
        'Donne exactement :',
        '1) Résumé ultra-court',
        '2) Action 24h',
        '3) Vigilance',
        'Max 70 mots.',
      ].join('\n');
    }

    if (promptStyle === 'compact') {
      return [
        'Analyste stock Grocy pragmatique, en français.',
        'Contexte:',
        ...facts.map((f) => `- ${f}`),
        'Réponse attendue:',
        '1) Lecture rapide',
        '2) Risque principal',
        '3) Action immédiate',
        '4) Action 7-30 jours',
        'Max 105 mots.',
      ].join('\n');
    }

    return [
      'Tu es un analyste stock Grocy, pragmatique.',
      'Donne des observations utiles et actionnables, en français.',
      'Contexte cliqué:',
      ...facts.map((f) => `- ${f}`),
      'Thèmes prédéfinis:',
      ...themes.map((t) => `- ${t}`),
      'Réponse attendue (courte):',
      '1) Lecture rapide (2 phrases max)',
      '2) Risque principal',
      '3) Action immédiate (24h)',
      '4) Action de fond (7-30 jours)',
      '5) Indicateur à suivre',
      'Maximum 140 mots au total.',
    ].join('\n');
  }

  function focusCacheKey(focus, settings) {
    const normalizedSettings = normalizeAiSettings(settings || aiSettings());
    const active = activeAiProvider(normalizedSettings);
    const focusMode = normalizeAiFocusMode(normalizedSettings.focusMode);
    const model = aiProviderModelLabel(active.id, normalizedSettings);
    const temperature = clamp(num(normalizedSettings.temperature), 0, 1.2);
    return [
      active.id,
      focusMode,
      model,
      fmt(temperature, 2),
      clean(focus && focus.chartId ? focus.chartId : ''),
      clean(focus && focus.type ? focus.type : ''),
      clean(focus && focus.label ? focus.label : ''),
      fmt(num(focus && focus.value !== undefined ? focus.value : 0), 4),
      fmt(num(focus && focus.amount !== undefined ? focus.amount : 0), 4),
    ].join('|');
  }

  function toFocusMetaHtml(focus) {
    const pairs = [];
    const focusUnit = cleanUnitLabel(focus.stockUnitName || '');
    pairs.push({ k: t('meta_element'), v: focus.label || t('default_na') });
    pairs.push({ k: t('meta_type'), v: focus.type || t('default_na') });
    if (focus.chartTitle) pairs.push({ k: t('meta_chart'), v: focus.chartTitle });
    if (focus.group) pairs.push({ k: t('meta_group'), v: focus.group });
    if (focus.brand) pairs.push({ k: t('meta_brand'), v: focus.brand });
    if (focus.value !== undefined) pairs.push({ k: t('meta_value'), v: fmtMoney(num(focus.value)) });
    if (focus.amount !== undefined && num(focus.amount) !== 0) {
      const qty = focus.type === 'product'
        ? fmtQtyProduct(num(focus.amount), focusUnit)
        : fmtQtyByChart(focus.chartId, num(focus.amount));
      pairs.push({ k: t('meta_quantity'), v: qty });
    }
    if (focus.price !== undefined && num(focus.price) > 0) pairs.push({ k: t('meta_price'), v: fmtMoney(num(focus.price)) });
    if (focus.avgPrice !== undefined && num(focus.avgPrice) > 0) pairs.push({ k: t('meta_avg_price'), v: fmtMoney(num(focus.avgPrice)) });
    if (focus.calories !== undefined && num(focus.calories) > 0) pairs.push({ k: t('meta_calories'), v: fmtKcal(num(focus.calories)) });
    if (focus.dueText) pairs.push({ k: t('meta_due'), v: focus.dueText });
    if (focus.alertText) pairs.push({ k: t('meta_alerts'), v: focus.alertText });

    return pairs.map((p) => `<span class="dash-focus-kv"><span class="dash-focus-k">${escapeHtml(p.k)}:</span><strong>${escapeHtml(String(p.v))}</strong></span>`).join('');
  }

  function focusStockLinksHtml(focus) {
    if (!focus) return '';
    const links = [];
    const brand = clean(focus.brand || '');
    const group = clean(focus.group || '');

    if (brand && !isNoBrandLabel(brand)) {
      links.push(stockFacetLinkHtml('brand', brand, t('overlay_open_brand_products'), 'dash-stock-facet-link-overlay dash-no-hover-preview'));
    }
    if (group && !isNoGroupLabel(group)) {
      links.push(stockFacetLinkHtml('group', group, t('overlay_open_group_products'), 'dash-stock-facet-link-overlay dash-no-hover-preview'));
    }
    if (!links.length) return '';

    return `
      <div class="dash-focus-links-title">${escapeHtml(t('overlay_stock_links_title'))}</div>
      <div class="dash-focus-links-wrap">${links.join('')}</div>
    `;
  }

  function buildFocusFromSelection(chartId, index, contextData, M) {
    const chartTitle = chartTitleById(chartId);
    if (!Array.isArray(contextData) || index < 0 || index >= contextData.length) return null;
    const selected = contextData[index];

    if (chartId === 'top_val') {
      const item = selected || {};
      const productId = num(item.id);
      const row = findProductRowById(productId) || {};
      const qtySummary = quantityBaseSummaryForRow(row, num(row.amount));
      const dueText = formatDueDateWithRelative(row.due || item.due || null);
      const alertParts = alertPartsFromRow(row);
      return {
        chartId,
        chartTitle,
        type: 'product',
        label: clean(item.name || row.name || `${t('default_product')} ${productId}`),
        productId,
        n: 1,
        pictureUrl: clean(row.pictureUrl || item.pictureUrl || ''),
        stockUnitName: cleanUnitLabel(item.stockUnitName || row.stockUnitName || ''),
        value: num(item.value || row.value),
        amount: num(row.amount),
        qtyMassBase: num(qtySummary.massBase),
        qtyVolumeBase: num(qtySummary.volumeBase),
        qtyMassRows: num(qtySummary.massRows),
        qtyVolumeRows: num(qtySummary.volumeRows),
        price: num(row.price),
        avgPrice: num(row.avgPrice),
        calories: num(row.calories),
        group: clean(row.group || ''),
        brand: clean(row.brand || ''),
        dueText: dueText === t('due_none') ? '' : dueText,
        alertText: alertParts.length ? alertParts.join(', ') : t('default_none'),
      };
    }

    if (chartId === 'price_val') {
      const item = selected || {};
      const productId = num(item.id);
      const row = findProductRowById(productId) || {};
      const qtySummary = quantityBaseSummaryForRow(row, num(row.amount));
      const dueText = formatDueDateWithRelative(row.due || null);
      const alertParts = alertPartsFromRow(row);
      return {
        chartId,
        chartTitle,
        type: 'product',
        label: clean(item.name || row.name || `${t('default_product')} ${productId}`),
        productId,
        n: 1,
        pictureUrl: clean(row.pictureUrl || item.pictureUrl || ''),
        stockUnitName: cleanUnitLabel(item.stockUnitName || row.stockUnitName || ''),
        value: num(item.y || row.value),
        amount: num(row.amount),
        qtyMassBase: num(qtySummary.massBase),
        qtyVolumeBase: num(qtySummary.volumeBase),
        qtyMassRows: num(qtySummary.massRows),
        qtyVolumeRows: num(qtySummary.volumeRows),
        price: num(item.x || row.price),
        avgPrice: num(row.avgPrice),
        calories: num(row.calories),
        group: clean(item.group || row.group || ''),
        brand: clean(row.brand || ''),
        dueText: dueText === t('due_none') ? '' : dueText,
        alertText: alertParts.length ? alertParts.join(', ') : t('default_none'),
      };
    }

    if (chartId === 'brand_price') {
      const brandName = clean(selected[0] || '');
      const agg = aggregateRowsByPredicate((row) => clean(row.brand) === brandName);
      const sampleRow = firstRowByPredicate((row) => clean(row.brand) === brandName) || {};
      return {
        chartId,
        chartTitle,
        type: 'brand',
        label: brandName || t('default_brand'),
        brand: brandName,
        pictureUrl: clean(sampleRow.pictureUrl || ''),
        value: agg.value,
        amount: agg.amount,
        qtyMassBase: agg.qtyMassBase,
        qtyVolumeBase: agg.qtyVolumeBase,
        qtyMassRows: agg.qtyMassRows,
        qtyVolumeRows: agg.qtyVolumeRows,
        avgPrice: num(selected[1]) || agg.avgPrice,
        n: agg.n,
        alerts: agg.alerts,
        soonOrLate: agg.soonOrLate,
      };
    }

    if (chartId === 'brand_rel') {
      const item = selected || {};
      const brandName = clean(item.brand || item.name || '');
      const agg = aggregateRowsByPredicate((row) => clean(row.brand) === brandName);
      const sampleRow = firstRowByPredicate((row) => clean(row.brand) === brandName) || {};
      return {
        chartId,
        chartTitle,
        type: 'brand',
        label: brandName || t('default_brand'),
        brand: brandName,
        pictureUrl: clean(sampleRow.pictureUrl || ''),
        value: num(item.y) || agg.value,
        amount: agg.amount,
        qtyMassBase: agg.qtyMassBase,
        qtyVolumeBase: agg.qtyVolumeBase,
        qtyMassRows: agg.qtyMassRows,
        qtyVolumeRows: agg.qtyVolumeRows,
        avgPrice: num(item.x) || agg.avgPrice,
        n: num(item.n) || agg.n,
        alerts: agg.alerts,
        soonOrLate: agg.soonOrLate,
      };
    }

    if (chartId === 'g_val' || chartId === 'g_qty' || chartId === 'g_cal') {
      const groupName = clean(selected[0] || t('default_no_group'));
      const agg = aggregateRowsByPredicate((row) => clean(row.group || t('default_no_group')) === groupName);
      const sampleRow = firstRowByPredicate((row) => clean(row.group || t('default_no_group')) === groupName) || {};
      return {
        chartId,
        chartTitle,
        type: 'group',
        label: groupName,
        group: groupName,
        n: agg.n,
        brand: clean(sampleRow.brand || ''),
        pictureUrl: clean(sampleRow.pictureUrl || ''),
        value: chartId === 'g_val' ? num(selected[1]) : agg.value,
        amount: chartId === 'g_qty' ? num(selected[1]) : agg.amount,
        qtyMassBase: agg.qtyMassBase,
        qtyVolumeBase: agg.qtyVolumeBase,
        qtyMassRows: agg.qtyMassRows,
        qtyVolumeRows: agg.qtyVolumeRows,
        calories: chartId === 'g_cal' ? num(selected[1]) : agg.calories,
        alerts: agg.alerts,
      };
    }

    if (chartId === 'risk' || chartId === 'due') {
      return {
        chartId,
        chartTitle,
        type: 'bucket',
        label: clean(selected[0] || t('default_category')),
        value: num(selected[1]),
        n: num(selected[1]),
      };
    }

    return {
      chartId,
      chartTitle,
      type: 'item',
      label: clean(Array.isArray(selected) ? selected[0] : String(selected || t('default_item'))),
      value: Array.isArray(selected) ? num(selected[1]) : num(selected),
    };
  }

  function focusLocalLogoUrl(focus) {
    if (!focus || typeof focus !== 'object') return '';
    const picture = clean(focus.pictureUrl || '');
    if (picture) return logoUrlForLargeDisplay(picture);
    const group = clean(focus.group || '');
    if (group && !isNoGroupLabel(group)) {
      const groupLogo = groupLogoEffectiveUrl(group);
      if (groupLogo) return logoUrlForLargeDisplay(groupLogo);
    }
    const brand = clean(focus.brand || '');
    if (brand && !isNoBrandLabel(brand)) {
      const logo = brandLogoEffectiveUrl(brand);
      if (logo) return logoUrlForLargeDisplay(logo);
    }
    return '';
  }

  function focusLocalLogoHtml(focus) {
    const url = focusLocalLogoUrl(focus);
    if (url) {
      return `<img src="${escapeHtml(url)}" alt="${escapeHtml(clean(focus.label || t('default_item')))}">`;
    }
    const label = clean(focus && focus.label ? focus.label : '');
    const fallback = label ? label.slice(0, 1).toUpperCase() : 'G';
    return `<span class="dash-focus-local-fallback">${escapeHtml(fallback)}</span>`;
  }

  function focusLocalMetaText(focus) {
    if (!focus) return t('overlay_focus_hint');
    const title = clean(focus.chartTitle || '');
    const label = clean(focus.label || '');
    if (title && label) return `${label} - ${title}`;
    return label || title || t('overlay_focus_hint');
  }

  function focusSupportsLocalProductList(focusInput) {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : null;
    if (!focus) return false;
    const type = clean(focus.type || '');
    return type === 'bucket' || type === 'group' || type === 'brand';
  }

  function overlayBucketFocusKey(focusInput) {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : null;
    if (!focus || !focusSupportsLocalProductList(focus)) return '';
    const chartId = clean(focus.chartId || '');
    const type = clean(focus.type || '');
    const label = norm(clean(focus.label || ''));
    if (!chartId || !label) return '';
    return `${chartId}|${type}|${label}`;
  }

  function ensureOverlayBucketUiState(focusInput) {
    const key = overlayBucketFocusKey(focusInput);
    if (!key) return null;
    const raw = S.overlayBucketUiByKey[key] && typeof S.overlayBucketUiByKey[key] === 'object'
      ? S.overlayBucketUiByKey[key]
      : {};
    const normalized = {
      expanded: raw.expanded === true,
      showAll: raw.showAll === true,
      selectedProductId: num(raw.selectedProductId) > 0 ? num(raw.selectedProductId) : 0,
    };
    S.overlayBucketUiByKey[key] = normalized;
    return normalized;
  }

  function updateOverlayBucketUiState(focusInput, patchInput = {}) {
    const key = overlayBucketFocusKey(focusInput);
    if (!key) return null;
    const current = ensureOverlayBucketUiState(focusInput) || { expanded: false, showAll: false, selectedProductId: 0 };
    const patch = patchInput && typeof patchInput === 'object' ? patchInput : {};
    const next = {
      expanded: Object.prototype.hasOwnProperty.call(patch, 'expanded') ? patch.expanded === true : current.expanded,
      showAll: Object.prototype.hasOwnProperty.call(patch, 'showAll') ? patch.showAll === true : current.showAll,
      selectedProductId: Object.prototype.hasOwnProperty.call(patch, 'selectedProductId')
        ? (num(patch.selectedProductId) > 0 ? num(patch.selectedProductId) : 0)
        : current.selectedProductId,
    };
    if (!next.expanded) next.showAll = false;
    S.overlayBucketUiByKey[key] = next;
    return next;
  }

  function overlayBucketRowsForFocus(focusInput) {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : null;
    if (!focus || !focusSupportsLocalProductList(focus)) return { rows: [], total: 0 };

    const chartId = clean(focus.chartId || '');
    const type = clean(focus.type || '');
    const label = clean(focus.label || '');
    const pref = getChartPref(chartId);
    let rows = [];
    let total = 0;

    if (type === 'bucket') {
      const bucket = hoverPreviewRowsByBucket(chartId, label, 0);
      rows = Array.isArray(bucket && bucket.allRows) ? bucket.allRows : [];
      total = Math.max(rows.length, Math.floor(num(bucket && bucket.total)));
      return { rows, total };
    }

    const facetType = type === 'brand' ? 'brand' : 'group';
    const allFacetRows = hoverPreviewFacetRows(facetType, label);
    total = Array.isArray(allFacetRows) ? allFacetRows.length : 0;
    if (!total) return { rows: [], total: 0 };

    const metricCfg = hoverFacetMetricConfig(facetType, chartId);
    const computeMetric = metricCfg && typeof metricCfg.computeRowMetric === 'function'
      ? metricCfg.computeRowMetric
      : ((row) => hoverPurchaseScoreForRow(row));
    const formatMetric = metricCfg && typeof metricCfg.formatMetric === 'function'
      ? metricCfg.formatMetric
      : ((metric) => fmt(metric, 2));
    const metricLabel = clean(metricCfg && metricCfg.metricLabel ? metricCfg.metricLabel : '');
    const ordered = allFacetRows
      .map((row) => ({ row, metric: num(computeMetric(row)) }))
      .sort((a, b) => {
        if (pref.sort === 'asc' && a.metric !== b.metric) return a.metric - b.metric;
        if (pref.sort !== 'asc' && b.metric !== a.metric) return b.metric - a.metric;
        const aValue = num(a && a.row && a.row.value);
        const bValue = num(b && b.row && b.row.value);
        if (bValue !== aValue) return bValue - aValue;
        return clean(a && a.row && a.row.name ? a.row.name : '')
          .localeCompare(clean(b && b.row && b.row.name ? b.row.name : ''), undefined, { sensitivity: 'base' });
      })
      .map((entry) => ({
        ...entry.row,
        __focusMetric: num(entry.metric),
        __focusMetricText: clean(formatMetric(entry.metric, entry.row) || ''),
        __focusMetricLabel: metricLabel,
      }));

    rows = ordered;
    return { rows, total };
  }

  function focusFromBucketProductRow(baseFocusInput, rowInput) {
    const baseFocus = baseFocusInput && typeof baseFocusInput === 'object' ? baseFocusInput : {};
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const productId = num(row.id);
    const qtySummary = quantityBaseSummaryForRow(row, num(row.amount));
    const dueText = formatDueDateWithRelative(row.due || null);
    const alertParts = alertPartsFromRow(row);
    return {
      chartId: clean(baseFocus.chartId || ''),
      chartTitle: clean(baseFocus.chartTitle || chartTitleById(baseFocus.chartId || '')),
      type: 'product',
      label: clean(row.name || `${t('default_product')} ${productId || ''}`),
      productId: productId > 0 ? productId : 0,
      n: 1,
      pictureUrl: clean(row.pictureUrl || ''),
      stockUnitName: cleanUnitLabel(row.stockUnitName || ''),
      value: num(row.value),
      amount: num(row.amount),
      qtyMassBase: num(qtySummary.massBase),
      qtyVolumeBase: num(qtySummary.volumeBase),
      qtyMassRows: num(qtySummary.massRows),
      qtyVolumeRows: num(qtySummary.volumeRows),
      price: num(row.price),
      avgPrice: num(row.avgPrice),
      calories: num(row.calories),
      group: clean(row.group || ''),
      brand: clean(row.brand || ''),
      dueText: dueText === t('due_none') ? '' : dueText,
      alertText: alertParts.length ? alertParts.join(', ') : t('default_none'),
    };
  }

  function resolveOverlayLocalDisplayFocus(focusInput) {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : null;
    if (!focus || !focusSupportsLocalProductList(focus)) return focus;
    const ui = ensureOverlayBucketUiState(focus);
    if (!ui || num(ui.selectedProductId) <= 0) return focus;
    const bucketRows = overlayBucketRowsForFocus(focus);
    const selectedRow = (Array.isArray(bucketRows.rows) ? bucketRows.rows : [])
      .find((row) => num(row && row.id) === num(ui.selectedProductId));
    if (!selectedRow) {
      updateOverlayBucketUiState(focus, { selectedProductId: 0 });
      return focus;
    }
    return focusFromBucketProductRow(focus, selectedRow);
  }

  function focusBucketThumbHtml(rowInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const pictureUrl = clean(row.pictureUrl || '');
    const label = clean(row.name || t('default_product'));
    if (pictureUrl) {
      return `<span class="dash-focus-bucket-thumb"><img src="${escapeHtml(pictureUrl)}" alt="${escapeHtml(label)}"></span>`;
    }
    const initial = label ? label.slice(0, 1).toUpperCase() : '?';
    return `<span class="dash-focus-bucket-thumb dash-focus-bucket-thumb-fallback">${escapeHtml(initial)}</span>`;
  }

  function focusBucketItemMetaText(rowInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const parts = [];
    const metricText = clean(row.__focusMetricText || '');
    const metricLabel = clean(row.__focusMetricLabel || '');
    if (metricText) {
      parts.push(metricLabel ? `${metricLabel}: ${metricText}` : metricText);
    }
    const dueText = formatDueDate(row.due || null);
    if (dueText && dueText !== t('due_none')) parts.push(dueText);
    const price = hoverPreviewRowPrice(row);
    if (price > 0) parts.push(fmtMoneyUi(price));
    return parts.join(' • ');
  }

  function focusBucketDisplayName(rowInput) {
    const row = rowInput && typeof rowInput === 'object' ? rowInput : {};
    const brand = clean(row.brand || '');
    const qty = num(row.amount) > 0 ? fmtQtyProduct(num(row.amount), cleanUnitLabel(row.stockUnitName || '')) : '';
    let name = clean(row.name || t('default_product'));
    if (brand) {
      const lowerName = name.toLowerCase();
      const lowerBrand = brand.toLowerCase();
      const suffix = ` - ${lowerBrand}`;
      if (lowerName.endsWith(suffix)) {
        name = clean(name.slice(0, name.length - suffix.length));
      }
    }
    const parts = [name, brand, qty].map((part) => clean(part)).filter(Boolean);
    return parts.join(' - ');
  }

  function focusBucketListHtml(focusInput) {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : null;
    if (!focus || !focusSupportsLocalProductList(focus)) return '';

    const bucket = overlayBucketRowsForFocus(focus);
    const allRows = Array.isArray(bucket.rows) ? bucket.rows : [];
    if (!allRows.length) return '';

    const ui = ensureOverlayBucketUiState(focus) || { expanded: false, showAll: false, selectedProductId: 0 };
    const expanded = ui.expanded === true;
    const showAll = expanded && ui.showAll === true;
    const total = Math.max(allRows.length, Math.floor(num(bucket.total)));
    const visibleLimit = showAll ? allRows.length : (expanded ? Math.min(5, allRows.length) : 0);
    const visibleRows = allRows.slice(0, visibleLimit);
    const canExpand = allRows.length > 1;
    const canShowAll = expanded && !showAll && allRows.length > 5;
    const hiddenCount = Math.max(0, allRows.length - 5);
    const selectedProductId = num(ui.selectedProductId);

    const rowsHtml = visibleRows.map((row, idx) => {
      const productId = num(row && row.id);
      const name = focusBucketDisplayName(row);
      const selectable = productId > 0;
      const isSelected = selectedProductId > 0 && productId > 0 && selectedProductId === productId;
      const cascadeClass = expanded ? ' is-cascade' : '';
      const selectedClass = isSelected ? ' is-selected' : '';
      const primaryClass = idx === 0 ? ' is-primary' : '';
      const expandClass = '';
      const delayMs = Math.min(420, idx * 65);
      const showMoreButton = '';
      const seeMoreButton = '';
      return `
        <div class="dash-focus-bucket-item${primaryClass}${selectedClass}${cascadeClass}${expandClass}" style="--dash-cascade-delay:${delayMs}ms;">
          <button
            type="button"
            class="dash-focus-bucket-product-btn"
            data-focus-bucket-product-id="${escapeHtml(fmt(productId, 0))}"
            ${selectable ? '' : 'disabled'}
            title="${escapeHtml(name)}"
            aria-label="${escapeHtml(name)}"
          >
            ${focusBucketThumbHtml(row)}
            <span class="dash-focus-bucket-main">
              <span class="dash-focus-bucket-name">${escapeHtml(name)}</span>
            </span>
          </button>
          ${seeMoreButton}
          ${showMoreButton}
        </div>
      `;
    }).join('');

    const showAllRowHtml = canShowAll
        ? `
          <button
            type="button"
            class="btn btn-outline-info btn-sm py-0 px-2 mt-1"
            data-focus-bucket-show-all="1"
            title="${escapeHtml(t('overlay_focus_bucket_show_more'))}"
            aria-label="${escapeHtml(t('overlay_focus_bucket_show_more'))}"
          >
            ${escapeHtml(t('overlay_focus_bucket_show_more'))}${hiddenCount > 0 ? ` +${escapeHtml(fmt(hiddenCount, 0))}` : ''}
          </button>
        `
        : '';

    const classes = [
      'dash-focus-bucket-list',
      expanded ? 'is-expanded' : '',
      showAll ? 'is-scrollable' : '',
    ].filter(Boolean).join(' ');

    if (!expanded && canExpand) {
      return `
        <div class="${classes}" data-focus-bucket-list="1">
          <button
            type="button"
            class="btn btn-outline-secondary btn-sm py-0 px-2"
            data-focus-bucket-expand="1"
            title="${escapeHtml(t('overlay_focus_bucket_see_more'))}"
            aria-label="${escapeHtml(t('overlay_focus_bucket_see_more'))}"
          >
            ${escapeHtml(t('overlay_focus_bucket_see_more'))}
          </button>
        </div>
      `;
    }
    return `<div class="${classes}" data-focus-bucket-list="1">${rowsHtml}${showAllRowHtml}</div>`;
  }

  function resolveFocusQuantityMode(focus, requestedModeInput = 'auto') {
    const focusSafe = focus && typeof focus === 'object' ? focus : {};
    const requestedMode = normalizeQtyMode(requestedModeInput);
    if (requestedMode !== 'auto') return requestedMode;
    const massRows = num(focusSafe.qtyMassRows);
    const volumeRows = num(focusSafe.qtyVolumeRows);
    if (massRows > volumeRows && massRows > 0) return 'mass';
    if (volumeRows > massRows && volumeRows > 0) return 'volume';
    const massBase = Math.abs(num(focusSafe.qtyMassBase));
    const volumeBase = Math.abs(num(focusSafe.qtyVolumeBase));
    if (massBase > 0 && volumeBase <= 0) return 'mass';
    if (volumeBase > 0 && massBase <= 0) return 'volume';
    if (volumeBase > massBase && volumeBase > 0) return 'volume';
    return 'mass';
  }

  function focusQuantityDisplayMeta(focus) {
    const focusSafe = focus && typeof focus === 'object' ? focus : {};
    const requestedMode = normalizeQtyMode(getChartPref('g_qty').qtyMode);
    const resolvedMode = resolveFocusQuantityMode(focusSafe, requestedMode);
    const massBase = num(focusSafe.qtyMassBase);
    const volumeBase = num(focusSafe.qtyVolumeBase);
    const hasMass = massBase > 0;
    const hasVolume = volumeBase > 0;
    let text = '';
    let converted = false;
    if (resolvedMode === 'mass' && hasMass) {
      const spec = qtyDisplaySpec('mass', Math.abs(massBase));
      const divisor = num(spec.divisor || 1) || 1;
      text = fmtQtyWithDisplay(massBase / divisor, spec);
      converted = true;
    } else if (resolvedMode === 'volume' && hasVolume) {
      const spec = qtyDisplaySpec('volume', Math.abs(volumeBase));
      const divisor = num(spec.divisor || 1) || 1;
      text = fmtQtyWithDisplay(volumeBase / divisor, spec);
      converted = true;
    }

    if (!text) {
      const unit = cleanUnitLabel(focusSafe.stockUnitName || '') || t('unit_units');
      text = fmtQtyProduct(num(focusSafe.amount), unit);
    }

    return {
      requestedMode,
      resolvedMode,
      text,
      converted,
      hasMass,
      hasVolume,
      modeLabel: qtyModeDisplayLabel(requestedMode, resolvedMode),
    };
  }

  function focusQuantityControlsHtml(activeModeInput = 'auto') {
    const activeMode = normalizeQtyMode(activeModeInput);
    const buttons = QTY_MODE_IDS.map((mode) => {
      const meta = qtyModeControlMeta(mode);
      const activeClass = activeMode === mode ? ' chart-ctl-active is-active' : '';
      return `
        <button
          type="button"
          class="btn btn-outline-secondary btn-sm py-0 px-2 dash-qty-mode-btn${activeClass}"
          data-focus-qty-mode="${escapeHtml(mode)}"
          title="${escapeHtml(meta.title || meta.label || '')}"
          aria-label="${escapeHtml(meta.label || mode)}"
        >${qtyModeButtonInnerHtml(meta)}</button>
      `;
    }).join('');
    return `
      <div class="dash-focus-qty-controls" role="group" aria-label="${escapeHtml(t('meta_quantity'))}">
        ${buttons}
      </div>
    `;
  }

  function stableHashInt(input = '') {
    const text = String(input || '');
    let hash = 0;
    for (let i = 0; i < text.length; i += 1) {
      hash = ((hash << 5) - hash) + text.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash);
  }

  function overlayEquivalentStateKey(focusInput, kindInput = '', scopeInput = '') {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : {};
    const kind = clean(kindInput || '');
    const scope = clean(scopeInput || '');
    return [
      kind,
      scope,
      clean(focus.chartId || ''),
      clean(focus.type || ''),
      fmt(num(focus.productId || 0), 0),
      norm(clean(focus.label || '')),
      fmt(num(focus.value !== undefined ? focus.value : 0), 4),
      fmt(num(focus.amount !== undefined ? focus.amount : 0), 4),
      fmt(num(focus.calories !== undefined ? focus.calories : 0), 2),
    ].join('|');
  }

  function ensureOverlayEquivalentState(stateKeyInput = '') {
    const stateKey = clean(stateKeyInput || '');
    if (!stateKey) return null;
    const raw = S.overlayEquivalentUiByKey[stateKey] && typeof S.overlayEquivalentUiByKey[stateKey] === 'object'
      ? S.overlayEquivalentUiByKey[stateKey]
      : {};
    const normalized = {
      nonce: Math.max(0, Math.floor(num(raw.nonce))),
    };
    S.overlayEquivalentUiByKey[stateKey] = normalized;
    return normalized;
  }

  function bumpOverlayEquivalentStateNonce(stateKeyInput = '') {
    const stateKey = clean(stateKeyInput || '');
    if (!stateKey) return;
    const current = ensureOverlayEquivalentState(stateKey) || { nonce: 0 };
    S.overlayEquivalentUiByKey[stateKey] = {
      nonce: (Math.max(0, Math.floor(num(current.nonce))) + 1) % 1000000,
    };
  }

  function focusQuantityEquivalentContext(focusInput, qtyMetaInput = null) {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : {};
    const qtyMeta = qtyMetaInput && typeof qtyMetaInput === 'object'
      ? qtyMetaInput
      : focusQuantityDisplayMeta(focus);
    const resolvedMode = normalizeQtyMode(qtyMeta && qtyMeta.resolvedMode ? qtyMeta.resolvedMode : 'auto');

    if (resolvedMode === 'mass' && num(focus.qtyMassBase) > 0) {
      return {
        scope: 'mass',
        total: Math.abs(num(focus.qtyMassBase)),
        catalog: FUN_QTY_EQUIVALENTS_MASS,
        minimum: 0.5,
      };
    }
    if (resolvedMode === 'volume' && num(focus.qtyVolumeBase) > 0) {
      return {
        scope: 'volume',
        total: Math.abs(num(focus.qtyVolumeBase)),
        catalog: FUN_QTY_EQUIVALENTS_VOLUME,
        minimum: 1,
      };
    }
    return {
      scope: 'count',
      total: Math.abs(num(focus.amount)),
      catalog: FUN_QTY_EQUIVALENTS_COUNT,
      minimum: 1,
    };
  }

  function focusAnchorEquivalentMeta(focusInput, kindInput = '', qtyMetaInput = null) {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : null;
    const kind = clean(kindInput || '');
    if (!focus || !kind) return null;

    let total = 0;
    let minimum = 0;
    let catalog = [];
    let scopeKey = kind;
    if (kind === 'quantity') {
      const qtyContext = focusQuantityEquivalentContext(focus, qtyMetaInput);
      if (!qtyContext) return null;
      total = num(qtyContext.total);
      minimum = num(qtyContext.minimum);
      catalog = Array.isArray(qtyContext.catalog) ? qtyContext.catalog : [];
      scopeKey = `quantity|${clean(qtyContext.scope || 'count')}`;
    } else if (kind === 'calories') {
      total = Math.abs(num(focus.calories));
      minimum = 20;
      catalog = FUN_CAL_EQUIVALENTS;
      scopeKey = 'calories';
    } else {
      return null;
    }

    if (!(total >= minimum) || !Array.isArray(catalog) || catalog.length === 0) return null;
    const maxItems = Math.max(14, Math.min(44, Math.floor(catalog.length * 0.28)));
    const candidates = computeHoverEquivalents(total, catalog, maxItems);
    if (!Array.isArray(candidates) || candidates.length === 0) return null;

    const stateKey = overlayEquivalentStateKey(focus, kind, scopeKey);
    const state = ensureOverlayEquivalentState(stateKey) || { nonce: 0 };
    const nonce = Math.max(0, Math.floor(num(state.nonce)));
    const pickIndex = stableHashInt(`${stateKey}|${fmt(total, 5)}|${nonce}`) % candidates.length;
    const pick = candidates[pickIndex] || candidates[0];
    if (!pick) return null;
    const text = `${hoverEquivalentCountText(pick.count)} ${hoverEquivalentLabel(pick.entry, pick.count)}`;
    return {
      kind,
      stateKey,
      text,
    };
  }

  function focusAnchorRandomButtonHtml(stateKeyInput = '') {
    const stateKey = clean(stateKeyInput || '');
    if (!stateKey) return '';
    return `
      <button
        type="button"
        class="btn btn-outline-secondary btn-sm py-0 px-2 dash-focus-random-btn"
        data-focus-equivalent-random-key="${escapeHtml(stateKey)}"
        title="${escapeHtml(t('focus_anchor_random_title'))}"
        aria-label="${escapeHtml(t('focus_anchor_random_title'))}"
      >
        <i class="fa-solid fa-shuffle" aria-hidden="true"></i>
        <span>${escapeHtml(t('focus_anchor_random'))}</span>
      </button>
    `;
  }

  function bindOverlayFocusQtyModeControls(root, focus) {
    if (!root) return;
    root.querySelectorAll('button[data-focus-qty-mode]').forEach((button) => {
      if (!button || button.dataset.focusQtyModeBound === '1') return;
      button.dataset.focusQtyModeBound = '1';
      button.addEventListener('click', (event) => {
        event.preventDefault();
        const mode = normalizeQtyMode(button.getAttribute('data-focus-qty-mode') || 'auto');
        patchChartPref('g_qty', { qtyMode: mode });
        if (S.fullChartId === 'g_qty') {
          refreshSingleChart('g_qty');
          return;
        }
        syncChartControls('g_qty');
        if (S.overlayFocus) {
          renderOverlayFocusLocalSection(S.overlayFocus);
        }
      });
    });
  }

  function bindOverlayFocusEquivalentControls(root, focus) {
    if (!root) return;
    root.querySelectorAll('button[data-focus-equivalent-random-key]').forEach((button) => {
      if (!button || button.dataset.focusEquivalentRandomBound === '1') return;
      button.dataset.focusEquivalentRandomBound = '1';
      button.addEventListener('click', (event) => {
        event.preventDefault();
        const stateKey = clean(button.getAttribute('data-focus-equivalent-random-key') || '');
        if (!stateKey) return;
        bumpOverlayEquivalentStateNonce(stateKey);
        const refreshFocus = S.overlayFocus || focus;
        if (refreshFocus) renderOverlayFocusLocalSection(refreshFocus);
      });
    });
  }

  function focusCriteriaText(focusInput) {
    const focus = focusInput && typeof focusInput === 'object' ? focusInput : null;
    if (!focus) return '';
    const chartId = clean(focus.chartId || '');
    const order = getChartPref(chartId).sort === 'asc'
      ? langText('Plus faibles d’abord', 'Lowest first')
      : langText('Plus forts d’abord', 'Highest first');
    if (chartId === 'g_val') return `${langText('Valeur stock', 'Stock value')} (${order})`;
    if (chartId === 'g_qty') return `${langText('Quantité', 'Quantity')} (${order})`;
    if (chartId === 'g_cal') return `${langText('Calories', 'Calories')} (${order})`;
    if (chartId === 'brand_price') return `${langText('Prix unitaire', 'Unit price')} (${order})`;
    if (chartId === 'brand_rel') return `${langText('Valeur stock', 'Stock value')} (${order})`;
    if (chartId === 'risk') return langText('Priorité alerte', 'Alert priority');
    if (chartId === 'due') return langText('Proximité échéance', 'Due-date proximity');
    return '';
  }

  function focusLocalStatsHtml(focus) {
    if (!focus) return `<span class="text-muted">${escapeHtml(t('overlay_focus_hint'))}</span>`;
    const rows = [];
    rows.push({ type: 'plain', key: t('meta_element'), value: clean(focus.label || t('default_na')) });
    if (focusSupportsLocalProductList(focus)) {
      const criteria = focusCriteriaText(focus);
      if (criteria) rows.push({ type: 'plain', key: langText('Critère', 'Criterion'), value: criteria });
      if (num(focus.productId) <= 0) {
        rows.push({
          type: 'plain',
          key: langText('Sélection', 'Selection'),
          value: langText('Groupe global (aucun produit sélectionné)', 'Group summary (no product selected)'),
        });
      }
    }
    if (num(focus.n) > 0) rows.push({ type: 'plain', key: t('kpi_products'), value: fmtProducts(num(focus.n)) });
    if (focus.price !== undefined && num(focus.price) > 0) rows.push({ type: 'plain', key: t('meta_price'), value: fmtMoney(num(focus.price)) });
    if (focus.amount !== undefined && num(focus.amount) !== 0) {
      const qtyMeta = focusQuantityDisplayMeta(focus);
      rows.push({ type: 'quantity', key: t('meta_quantity'), value: qtyMeta.text, qtyMeta });
      const qtyAnchor = focusAnchorEquivalentMeta(focus, 'quantity', qtyMeta);
      if (qtyAnchor && qtyAnchor.text) {
        rows.push({
          type: 'anchor',
          key: t('focus_anchor_qty'),
          value: qtyAnchor.text,
          stateKey: qtyAnchor.stateKey,
        });
      }
    }
    if (focus.brand) rows.push({ type: 'plain', key: t('meta_brand'), value: clean(focus.brand) });
    if (focus.group) rows.push({ type: 'plain', key: t('meta_group'), value: clean(focus.group) });
    if (focus.dueText) rows.push({ type: 'plain', key: t('meta_due'), value: clean(focus.dueText) });
    if (focus.alertText) rows.push({ type: 'plain', key: t('meta_alerts'), value: clean(focus.alertText) });
    if (focus.calories !== undefined && num(focus.calories) > 0) {
      rows.push({ type: 'plain', key: t('meta_calories'), value: fmtKcal(num(focus.calories)) });
      const calAnchor = focusAnchorEquivalentMeta(focus, 'calories', null);
      if (calAnchor && calAnchor.text) {
        rows.push({
          type: 'anchor',
          key: t('focus_anchor_cal'),
          value: calAnchor.text,
          stateKey: calAnchor.stateKey,
        });
      }
    }
    if (!rows.length) return `<span class="text-muted">${escapeHtml(t('overlay_focus_hint'))}</span>`;

    return `<div class="dash-focus-local-stats">${rows
      .map((row) => {
        if (row.type === 'quantity') {
          const qtyMeta = row.qtyMeta && typeof row.qtyMeta === 'object' ? row.qtyMeta : null;
          const controlsHtml = focusQuantityControlsHtml(qtyMeta ? qtyMeta.requestedMode : 'auto');
          const qtyTitle = qtyMeta ? qtyMeta.modeLabel : '';
          return `
            <div class="dash-focus-local-stat dash-focus-local-stat-qty">
              <span class="dash-focus-local-stat-key">${escapeHtml(row.key || '')}</span>
              <div class="dash-focus-local-stat-tail">
                ${controlsHtml}
                <strong title="${escapeHtml(qtyTitle || '')}">${escapeHtml(row.value || '')}</strong>
              </div>
            </div>
          `;
        }
        if (row.type === 'anchor') {
          return `
            <div class="dash-focus-local-stat dash-focus-local-stat-anchor">
              <span class="dash-focus-local-stat-key">${escapeHtml(row.key || '')}</span>
              <div class="dash-focus-local-stat-tail">
                ${focusAnchorRandomButtonHtml(row.stateKey || '')}
                <strong>${escapeHtml(row.value || '')}</strong>
              </div>
            </div>
          `;
        }
        return `
          <div class="dash-focus-local-stat">
            <span class="dash-focus-local-stat-key">${escapeHtml(row.key || '')}</span>
            <div class="dash-focus-local-stat-tail">
              <strong>${escapeHtml(row.value || '')}</strong>
            </div>
          </div>
        `;
      })
      .join('')}</div>`;
  }

  function renderOverlayFocusLocalSection(focus) {
    const localMetaEl = document.getElementById('dash_chart_overlay_focus_local_meta');
    const localLinksEl = document.getElementById('dash_chart_overlay_focus_local_links');
    const localStatsEl = document.getElementById('dash_chart_overlay_focus_local_stats');
    const localLogoEl = document.getElementById('dash_chart_overlay_focus_local_logo');
    const localProductsEl = document.getElementById('dash_chart_overlay_focus_local_products');
    const productBtn = document.getElementById('dash_focus_open_product');
    if (!localMetaEl || !localLinksEl || !localStatsEl || !localLogoEl || !localProductsEl) return false;

    const displayFocus = resolveOverlayLocalDisplayFocus(focus) || focus;
    const canListProducts = focusSupportsLocalProductList(focus);
    const listUiState = canListProducts
      ? (ensureOverlayBucketUiState(focus) || { expanded: false, showAll: false, selectedProductId: 0 })
      : null;
    const isExpanded = !!(listUiState && listUiState.expanded);
    const productsHtml = canListProducts ? focusBucketListHtml(focus) : '';
    localMetaEl.textContent = focusLocalMetaText(displayFocus);
    localStatsEl.innerHTML = focusLocalStatsHtml(displayFocus);
    bindOverlayFocusQtyModeControls(localStatsEl, displayFocus);
    bindOverlayFocusEquivalentControls(localStatsEl, displayFocus);
    localLinksEl.innerHTML = focusStockLinksHtml(displayFocus);

    localLogoEl.classList.toggle('is-clickable', canListProducts);
    localLogoEl.title = canListProducts
      ? (isExpanded ? t('overlay_details_collapse') : t('overlay_focus_bucket_see_more'))
      : '';
    localLogoEl.innerHTML = focusLocalLogoHtml(focus || displayFocus);

    localProductsEl.classList.toggle('is-open', canListProducts && isExpanded && !!productsHtml);
    localProductsEl.innerHTML = (canListProducts && isExpanded) ? productsHtml : '';

    if (productBtn) {
      if (num(displayFocus && displayFocus.productId) > 0) productBtn.classList.remove('d-none');
      else productBtn.classList.add('d-none');
    }
    return true;
  }

  function setOverlayAiPanelState(options = {}) {
    const panel = document.getElementById('dash_chart_overlay_focus_ai');
    const stateEl = document.getElementById('dash_chart_overlay_focus_ai_state');
    const bodyEl = document.getElementById('dash_chart_overlay_focus_ai_body');
    const settingsBtn = document.getElementById('dash_focus_ai_settings');
    if (!panel || !stateEl || !bodyEl || !settingsBtn) return;

    const collapsed = options.collapsed === true;
    const status = clean(options.status || '');
    const level = clean(options.level || 'muted');
    const showSettings = options.showSettings === true;
    const bodyHtml = Object.prototype.hasOwnProperty.call(options, 'bodyHtml')
      ? String(options.bodyHtml || '')
      : '';

    panel.classList.toggle('is-collapsed', collapsed);
    stateEl.className = `small text-${level} mr-2`;
    stateEl.textContent = status;
    settingsBtn.classList.toggle('d-none', !showSettings);
    if (bodyHtml) bodyEl.innerHTML = bodyHtml;
    else bodyEl.textContent = '';
  }

  function focusAiToHtml(text) {
    const cleaned = String(text || '').replace(/\r\n/g, '\n').trim();
    if (!cleaned) return `<span class="text-muted">${escapeHtml(t('focus_resp_empty'))}</span>`;
    return escapeHtml(cleaned).replace(/\n{2,}/g, '\n').replace(/\n/g, '<br>');
  }

  function focusAiResultToHtml(result) {
    const payload = (result && typeof result === 'object') ? result : { text: result };
    return focusAiToHtml(payload.text || '');
  }

  async function renderOverlayFocusCard(focus, forceRefresh = false, trigger = 'auto') {
    if (!focus) return;
    S.overlayFocus = focus;
    const aiEl = document.getElementById('dash_chart_overlay_focus_ai_body');
    if (!aiEl) return;
    if (!renderOverlayFocusLocalSection(focus)) return;

    const settings = normalizeAiSettings(aiSettings());
    const active = activeAiProvider(settings);
    const triggerMode = clean(trigger || 'auto');
    const manual = triggerMode !== 'restore';
    const restoreOnly = triggerMode === 'restore';
    const runtimeState = clean(S.aiProviderRuntimeState[active.id] || '');
    const providerValidationMsg = clean(document.getElementById(providerValidationMsgId(active.id))?.textContent || '');
    const collapseAiWithSettings = (statusKey, bodyHtml, level = 'warning') => {
      setOverlayAiPanelState({
        collapsed: true,
        status: t(statusKey),
        level,
        showSettings: true,
        bodyHtml,
      });
    };

    const policy = aiFocusPolicy(settings, manual);
    const modeLabel = policy.label;
    const modeId = normalizeAiFocusMode(settings.focusMode);

    if (!settings.enabled) {
      collapseAiWithSettings('overlay_focus_ai_disabled', `<span class="text-muted">${escapeHtml(t('focus_ai_disabled'))}</span>`, 'muted');
      return;
    }
    if (!isAiProviderConfigured(settings, active.id)) {
      collapseAiWithSettings('overlay_focus_ai_missing', `<span class="text-warning">${escapeHtml(t('focus_ai_config_missing', { provider: active.def.label }))}</span>`);
      return;
    }
    if (runtimeState === 'rejected') {
      collapseAiWithSettings(
        'overlay_focus_ai_error',
        `<span class="text-warning">${escapeHtml(providerValidationMsg || t('focus_unknown_error'))}</span>`
      );
      return;
    }
    if (runtimeState !== 'valid') {
      collapseAiWithSettings('overlay_focus_ai_unvalidated', `<span class="text-info">${escapeHtml(t('overlay_focus_ai_unvalidated'))}</span>`, 'info');
      return;
    }

    setOverlayAiPanelState({
      collapsed: false,
      status: '',
      level: 'muted',
      showSettings: false,
      bodyHtml: '',
    });

    const cacheKey = focusCacheKey(focus, settings);
    if (!forceRefresh && S.aiCache.has(cacheKey)) {
      aiEl.innerHTML = focusAiResultToHtml(S.aiCache.get(cacheKey));
      return;
    }
    if (restoreOnly) {
      aiEl.innerHTML = `<span class="text-muted">${escapeHtml(t('focus_ai_restore_missing'))}</span>`;
      return;
    }

    if (S.aiRequestInFlight) {
      aiEl.innerHTML = `<span class="text-info">${escapeHtml(t('focus_ai_busy', { mode: modeLabel }))}</span>`;
      return;
    }
    if (S.aiOverlayTotalCalls >= policy.maxTotalCallsPerOverlay) {
      aiEl.innerHTML = `<span class="text-warning">${escapeHtml(t('focus_ai_total_limit', { count: fmt(policy.maxTotalCallsPerOverlay, 0) }))}</span>`;
      return;
    }
    const now = Date.now();
    if (!manual && S.aiOverlayLastCallAt > 0 && (now - S.aiOverlayLastCallAt) < policy.minIntervalMs) {
      const waitMs = policy.minIntervalMs - (now - S.aiOverlayLastCallAt);
      aiEl.innerHTML = `<span class="text-info">${escapeHtml(t('focus_ai_throttle', { mode: modeLabel, wait: fmt(waitMs / 1000, 1) }))}</span>`;
      return;
    }

    aiEl.innerHTML = `<span class="text-info">${escapeHtml(t('focus_ai_running', { provider: active.def.label, mode: modeLabel }))}</span>`;
    S.aiRequestInFlight = true;
    S.aiOverlayLastCallAt = now;
    S.aiOverlayTotalCalls += 1;
    if (!manual) S.aiOverlayAutoCalls += 1;
    const requestId = ++S.aiRequestSeq;
    try {
      const prompt = buildFocusPrompt(focus, policy.promptStyle);
      const result = await callAiText(settings, prompt, {
        maxOutputTokens: policy.maxOutputTokens,
        allowFallback: policy.allowFallback,
        temperature: policy.temperature,
        timeoutMs: policy.timeoutMs,
      });
      S.aiCache.set(cacheKey, result);
      saveAiCache(S.dataSignature);
      if (requestId !== S.aiRequestSeq) return;
      if (!S.overlayFocus || focusCacheKey(S.overlayFocus, settings) !== cacheKey) return;
      aiEl.innerHTML = focusAiResultToHtml(result);
    } catch (error) {
      if (requestId !== S.aiRequestSeq) return;
      const message = clean(error && error.message ? error.message : String(error));
      collapseAiWithSettings(
        'overlay_focus_ai_error',
        `<span class="text-danger">${escapeHtml(t('focus_ai_unavailable', { message: message || t('focus_unknown_error') }))}</span>`,
        'warning'
      );
    } finally {
      S.aiRequestInFlight = false;
      if (modeId === 'cheapest' && !manual) {
        // In cheapest mode, avoid stacking auto retries after a failed call.
        S.aiOverlayAutoCalls = policy.maxAutoCallsPerOverlay;
      }
    }
  }

  function handleOverlayChartClick(index, trigger = 'auto') {
    const ctx = S.fullChartContext;
    if (!ctx || index < 0) return;
    const focus = buildFocusFromSelection(ctx.chartId, index, ctx.contextData || [], ctx.metrics || S.lastMetrics);
    if (!focus) return;
    if (focusSupportsLocalProductList(focus)) {
      updateOverlayBucketUiState(focus, { expanded: false, showAll: false, selectedProductId: 0 });
    }
    renderOverlayFocusCard(focus, false, trigger);
  }

  function setText(id, v) { const el = document.getElementById(id); if (el) el.textContent = v; }

  function apiStockGlobalValue() {
    let total = 0;
    S.apiStockByProductId.forEach((row) => {
      total += row.value > 0 ? row.value : 0;
    });
    return total;
  }

  function filtersAtGlobalDefault() {
    const search = clean(document.getElementById('search')?.value || '');
    const gf = document.getElementById('product-group-filter')?.value || 'all';
    const sf = document.getElementById('status-filter')?.value || 'all';
    return !search && gf === 'all' && sf === 'all' && S.active === 'all';
  }

  function apiStockGlobalValueNonZeroOnly() {
    let total = 0;
    S.apiStockByProductId.forEach((row) => {
      if (row.value > 0) total += row.value;
    });
    return total;
  }

  function insights(M, filtered, total) {
    const ul = document.getElementById('dash_insights');
    const ctx = document.getElementById('dash_context');
    if (!ul || !ctx) return;

    const en = resolveUiLanguage() === 'en';
    const tabLabel = S.tabs?.[S.active] ? clean(S.tabs[S.active].textContent) : t('default_all');
    const cov = total ? (filtered / total) * 100 : 0;
    ctx.textContent = t('insight_scope', {
      filtered: fmtProducts(filtered),
      total: fmtProducts(total),
      tab: tabLabel,
      coverage: fmtPercent(cov),
    });

    if (!filtered) {
      ul.innerHTML = `<li>${escapeHtml(t('insight_no_rows'))}</li>`;
      return;
    }

    const list = [];
    const topGroup = mapPairs(M.byGroupValue).sort((a, b) => b[1] - a[1])[0];
    if (topGroup && M.value > 0) {
      list.push(en
        ? `Dominant value group: "${topGroup[0]}" (${fmtPercent((topGroup[1] / M.value) * 100)}).`
        : `Groupe dominant en valeur: "${topGroup[0]}" (${fmtPercent((topGroup[1] / M.value) * 100)}).`);
    }

    if (M.top.length) {
      list.push(en
        ? `Most immobilizing product: "${M.top[0].name}" (${fmtMoney(M.top[0].value)}).`
        : `Produit le plus immobilisant: "${M.top[0].name}" (${fmtMoney(M.top[0].value)}).`);
      const top5 = M.top.slice(0, 5).reduce((s, x) => s + x.value, 0);
      list.push(en
        ? `Concentration: top 5 products represent ${fmtPercent(M.value ? (top5 / M.value) * 100 : 0)} of value.`
        : `Concentration: les 5 premiers produits représentent ${fmtPercent(M.value ? (top5 / M.value) * 100 : 0)} de la valeur.`);
    }

    list.push(en
      ? `Alerts: ${fmtProducts(M.alert)} (${fmtPercent(filtered ? (M.alert / filtered) * 100 : 0)}) | below stock ${fmtProducts(M.below)}, due soon ${fmtProducts(M.soon)}, overdue ${fmtProducts(M.overdue)}, expired ${fmtProducts(M.expired)}.`
      : `Alertes: ${fmtProducts(M.alert)} (${fmtPercent(filtered ? (M.alert / filtered) * 100 : 0)}) | sous stock ${fmtProducts(M.below)}, proche date ${fmtProducts(M.soon)}, retard ${fmtProducts(M.overdue)}, expiré ${fmtProducts(M.expired)}.`);

    const pricey = M.brand.filter((b) => b.pN > 0).sort((a, b) => b.avg - a.avg)[0];
    if (pricey) {
      list.push(en
        ? `Most expensive brand (average price): "${pricey.name}" at ${fmtMoney(pricey.avg)}.`
        : `Marque la plus chère (prix moyen): "${pricey.name}" à ${fmtMoney(pricey.avg)}.`);
    }

    ul.innerHTML = list.map((x) => `<li>${x}</li>`).join('');
  }

  function rankPairsDesc(map) {
    return mapPairs(map).sort((a, b) => num(b[1]) - num(a[1]));
  }

  function renderGlobalConclusions(M, filteredCount, totalCount, displayedValue) {
    const target = document.getElementById('dash_global_conclusions_body');
    if (!target) return;
    const en = resolveUiLanguage() === 'en';

    if (!M || filteredCount <= 0) {
      target.innerHTML = linesToHtml([t('global_no_data')]);
      return;
    }

    const lines = [];
    const valueByGroup = rankPairsDesc(M.byGroupValue);
    const qtyByGroup = rankPairsDesc(M.byGroupQty);
    const calByGroup = rankPairsDesc(M.byGroupCal);
    const topValueGroup = valueByGroup[0] || null;
    const topQtyGroup = qtyByGroup[0] || null;
    const topCalGroup = calByGroup[0] || null;

    const topProduct = Array.isArray(M.top) && M.top.length ? M.top[0] : null;
    const top5Value = Array.isArray(M.top) ? M.top.slice(0, 5).reduce((sum, p) => sum + num(p.value), 0) : 0;
    const top5Ratio = M.value > 0 ? (top5Value / M.value) * 100 : 0;

    const dueTotal = num(M.due.late) + num(M.due.d3) + num(M.due.d7) + num(M.due.d30) + num(M.due.later) + num(M.due.none);
    const riskyDue = num(M.due.late) + num(M.due.d3);
    const riskyDueRatio = dueTotal > 0 ? (riskyDue / dueTotal) * 100 : 0;
    const alertRatio = filteredCount > 0 ? (num(M.alert) / filteredCount) * 100 : 0;

    const brandByValue = Array.isArray(M.brand)
      ? [...M.brand].sort((a, b) => num(b.value) - num(a.value))
      : [];
    const leadBrand = brandByValue[0] || null;
    const leadBrandShare = leadBrand && M.value > 0 ? (num(leadBrand.value) / M.value) * 100 : 0;
    const priceyBrand = Array.isArray(M.brand) && M.brand.length
      ? [...M.brand].sort((a, b) => num(b.avg) - num(a.avg))[0]
      : null;

    lines.push(t('global_value_visible', {
      value: fmtMoney(displayedValue),
      filtered: fmtProducts(filteredCount),
      total: fmtProducts(totalCount),
    }));

    if (topValueGroup && M.value > 0) {
      lines.push(t('global_main_weight', {
        group: topValueGroup[0],
        share: fmtPercent((num(topValueGroup[1]) / M.value) * 100),
      }));
    }

    if (topValueGroup && topQtyGroup && clean(topValueGroup[0]) !== clean(topQtyGroup[0])) {
      lines.push(t('global_shift_value_volume', {
        valueGroup: topValueGroup[0],
        qtyGroup: topQtyGroup[0],
      }));
    } else if (topQtyGroup) {
      lines.push(t('global_aligned_value_volume', { group: topQtyGroup[0] }));
    }

    if (topProduct && M.value > 0) {
      lines.push(t('global_product_concentration', {
        share: fmtPercent(top5Ratio),
        leader: topProduct.name,
      }));
    }

    lines.push(t('global_operational_risk', {
      alertShare: fmtPercent(alertRatio),
      dueShare: fmtPercent(riskyDueRatio),
    }));

    if (leadBrand) {
      const premiumText = priceyBrand
        ? (en
          ? `"${priceyBrand.name}" is the most expensive by average price.`
          : `"${priceyBrand.name}" est la plus chère en prix moyen.`)
        : t('global_brand_no_premium');
      lines.push(t('global_brand_summary', {
        brand: leadBrand.name,
        share: fmtPercent(leadBrandShare),
        premium: premiumText,
      }));
    } else {
      lines.push(t('global_brand_insufficient'));
    }

    if (topCalGroup && M.cal > 0) {
      lines.push(t('global_nutrition_summary', {
        group: topCalGroup[0],
        share: fmtPercent((num(topCalGroup[1]) / M.cal) * 100),
      }));
    } else {
      lines.push(t('global_nutrition_insufficient'));
    }

    target.innerHTML = linesToHtml(lines);
  }

  function dueDiffDays(date) {
    const normalized = normalizeDueDateValue(date);
    if (!normalized) return null;
    const now = new Date();
    now.setHours(0, 0, 0, 0);
    const d = new Date(normalized);
    d.setHours(0, 0, 0, 0);
    return Math.floor((d.getTime() - now.getTime()) / 86400000);
  }

  function fmtDueDelta(diff) {
    const value = num(diff);
    if (!Number.isFinite(value)) return t('due_no_date_text');
    if (value < 0) return t('due_over_by', { days: fmtDays(Math.abs(value)) });
    if (value === 0) return t('due_today');
    return t('due_in', { days: fmtDays(value) });
  }

  function fallbackRankingRows() {
    return [{ id: 0, label: t('no_data'), valueText: '' }];
  }

  function ensureRankingRows(rows) {
    return Array.isArray(rows) && rows.length > 0 ? rows : fallbackRankingRows();
  }

  function normalizeRankingCategory(value) {
    const normalized = clean(value || '').toLowerCase();
    if (normalized === 'products' || normalized === 'brands' || normalized === 'groups' || normalized === 'ops') return normalized;
    return 'all';
  }

  function rankingCategoryDefs() {
    return [
      { id: 'all', label: t('rankings_category_all') },
      { id: 'products', label: t('rankings_category_products') },
      { id: 'brands', label: t('rankings_category_brands') },
      { id: 'groups', label: t('rankings_category_groups') },
      { id: 'ops', label: t('rankings_category_ops') },
    ];
  }

  function setRankingsCategory(value) {
    S.rankingsCategory = normalizeRankingCategory(value);
    scheduleUiStateSave();
  }

  function rankingPodiumMode(cardId) {
    const key = clean(cardId || '');
    if (!key) return 'top';
    const current = clean(S.rankingsPodiumModes[key] || '').toLowerCase();
    return current === 'bottom' ? 'bottom' : 'top';
  }

  function setRankingPodiumMode(cardId, mode) {
    const key = clean(cardId || '');
    if (!key) return;
    S.rankingsPodiumModes[key] = clean(mode || '').toLowerCase() === 'bottom' ? 'bottom' : 'top';
    scheduleUiStateSave();
  }

  function setRankingsDetailsExpanded(expanded) {
    const normalized = expanded === true;
    S.rankingsDetailsExpanded = normalized;
    const wrap = document.getElementById('dash_rankings_full_wrap');
    if (wrap) wrap.classList.toggle('d-none', !normalized);
    const btn = document.getElementById('dash_rankings_full_toggle');
    if (btn) {
      btn.classList.toggle('is-expanded', normalized);
      const icon = normalized ? 'fa-chevron-up' : 'fa-chevron-down';
      const text = normalized ? t('rankings_full_collapse') : t('rankings_full_expand');
      btn.innerHTML = `<i class="fa-solid ${icon}"></i> ${escapeHtml(text)}`;
    }
    scheduleUiStateSave();
  }

  function refreshRankingsSection() {
    if (!S.lastMetrics) return;
    const filtered = Array.isArray(S.lastFilteredRows) ? S.lastFilteredRows : [];
    const totalCount = Array.isArray(S.lastAllRows) ? S.lastAllRows.length : filtered.length;
    renderRankings(S.lastMetrics, filtered, totalCount);
  }

  function focusRankingCard(cardId, scrollIntoView = false) {
    const grid = document.getElementById('dash_rankings_grid');
    if (!grid) return;
    Array.from(grid.querySelectorAll('.dash-ranking-card.is-focused')).forEach((card) => {
      card.classList.remove('is-focused');
    });
    const key = clean(cardId || '');
    if (!key) return;
    const safe = key.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    const target = grid.querySelector(`.dash-ranking-card[data-rank-card-id="${safe}"]`);
    if (!target) return;
    target.classList.add('is-focused');
    if (scrollIntoView) {
      target.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }

  function rankingRowProduct(product, valueText, valueNum = 0) {
    const id = num(product && product.id ? product.id : 0);
    const label = clean(product && product.name ? product.name : `${t('default_product')} ${id}`);
    return {
      id: id > 0 ? id : 0,
      label: label || t('default_product'),
      valueText: clean(valueText || ''),
      valueNum: num(valueNum),
      facetType: '',
      facetValue: '',
    };
  }

  function rankingRowFacet(type, label, valueText, valueNum = 0) {
    const facetType = normalizeFacetType(type);
    const facetValue = clean(label || '');
    return {
      id: 0,
      label: facetValue || t('default_item'),
      valueText: clean(valueText || ''),
      valueNum: num(valueNum),
      facetType,
      facetValue: facetType ? facetValue : '',
    };
  }

  function rankingRowLabelHtml(row, facetExtraClass = '') {
    const label = clean(row && row.label ? row.label : t('default_item'));
    if (num(row && row.id) > 0) {
      return `<button type="button" class="btn btn-link p-0 align-baseline dash-product-link" data-product-id="${num(row.id)}">${escapeHtml(label)}</button>`;
    }
    const facetType = normalizeFacetType(row && row.facetType ? row.facetType : '');
    const facetValue = clean(row && row.facetValue ? row.facetValue : '');
    if (facetType && facetValue) {
      return stockFacetLinkHtml(facetType, facetValue, label, facetExtraClass);
    }
    return `<span>${escapeHtml(label)}</span>`;
  }

  function rankingOrderBadgeHtml(orderIndex, visualIndex, badgeClass) {
    const order = Math.max(num(orderIndex), 1);
    const visual = Math.max(num(visualIndex), 1);
    const safeBadgeClass = clean(badgeClass || 'dash-ranking-rank');
    const crownClass = visual === 1
      ? ' is-gold'
      : (visual === 2 ? ' is-silver' : (visual === 3 ? ' is-bronze' : ''));
    const crown = crownClass
      ? `<i class="fa-solid fa-crown dash-rank-crown${crownClass}" aria-hidden="true"></i>`
      : '';
    const rankClass = visual <= 3 ? ` rank-${visual}` : '';
    return `
      <span class="${escapeHtml(`${safeBadgeClass}${rankClass}`)}">
        ${crown}
        <span class="dash-rank-num">${escapeHtml(fmt(order, 0))}</span>
      </span>
    `;
  }

  function rankingSupportsQtyMode(cardInput) {
    const card = cardInput && typeof cardInput === 'object' ? cardInput : null;
    return !!(card && card.qtyModeScoped === true);
  }

  function rankingQtyModeControlHtml(cardInput, compact = false) {
    if (!rankingSupportsQtyMode(cardInput)) return '';
    const activeMode = normalizeQtyMode(getChartPref('g_qty').qtyMode);
    const classes = compact
      ? 'dash-ranking-qty-controls dash-ranking-qty-controls-compact'
      : 'dash-ranking-qty-controls';
    const buttons = QTY_MODE_IDS.map((mode) => {
      const meta = qtyModeControlMeta(mode);
      const activeClass = activeMode === mode ? ' is-active' : '';
      const innerHtml = qtyModeButtonInnerHtml(meta);
      return `
        <button
          type="button"
          class="btn btn-outline-secondary dash-qty-mode-btn${activeClass}"
          data-rank-qty-mode="${escapeHtml(mode)}"
          title="${escapeHtml(meta.title)}"
          aria-label="${escapeHtml(meta.label)}"
        >${innerHtml}</button>
      `;
    }).join('');
    return `
      <div class="${classes}" role="group" aria-label="${escapeHtml(t('chart_group_qty_title'))}">
        ${buttons}
      </div>
    `;
  }

  function rankingRowsSimilarity(rowsA, rowsB) {
    const labelsA = new Set(
      ensureRankingRows(rowsA)
        .slice(0, 8)
        .map((row) => norm(row && row.label ? row.label : ''))
        .filter(Boolean)
    );
    const labelsB = new Set(
      ensureRankingRows(rowsB)
        .slice(0, 8)
        .map((row) => norm(row && row.label ? row.label : ''))
        .filter(Boolean)
    );
    if (labelsA.size === 0 || labelsB.size === 0) return 0;
    let same = 0;
    labelsA.forEach((label) => {
      if (labelsB.has(label)) same += 1;
    });
    return same / Math.max(labelsA.size, labelsB.size);
  }

  function dedupeRankingCards(cardsInput) {
    const cards = Array.isArray(cardsInput) ? cardsInput : [];
    const kept = [];
    cards.forEach((candidate) => {
      const rows = Array.isArray(candidate && candidate.rowsTop) ? candidate.rowsTop : [];
      if (!rows.length) return;

      let duplicate = false;
      for (const existing of kept) {
        if (clean(existing.entity || '') !== clean(candidate.entity || '')) continue;
        const sim = rankingRowsSimilarity(existing.rowsTop, candidate.rowsTop);
        const sameFamily = clean(existing.dedupeFamily || '') && clean(existing.dedupeFamily || '') === clean(candidate.dedupeFamily || '');
        if ((sameFamily && sim >= 0.45) || sim >= 0.93) {
          duplicate = true;
          break;
        }
      }

      if (!duplicate) kept.push(candidate);
    });
    return kept;
  }

  function buildRankingCards(M, filteredRows) {
    const products = Array.isArray(filteredRows) ? filteredRows : [];
    const brands = Array.isArray(M?.brand) ? M.brand : [];
    const qtyState = buildGroupQtyState(products, 'g_qty');
    const qtyProducts = Array.isArray(qtyState?.byProductDisplay) ? qtyState.byProductDisplay : [];
    const qtyScope = clean(qtyState && qtyState.unitBadgeText ? qtyState.unitBadgeText : '');
    const qtyUnclassifiedCount = qtyState && Array.isArray(qtyState.unclassified) ? qtyState.unclassified.length : 0;
    const qtyScopeText = t('rank_qty_scope_text', { scope: qtyScope || t('default_na') });
    const qtyScopeDetail = qtyUnclassifiedCount > 0
      ? `${qtyScopeText} | ${t('rank_qty_unclassified_text', { count: fmtProducts(qtyUnclassifiedCount) })}`
      : qtyScopeText;

    const topByValueDesc = [...products]
      .filter((p) => num(p.value) > 0)
      .sort((a, b) => num(b.value) - num(a.value));
    const topByValueAsc = [...topByValueDesc].sort((a, b) => num(a.value) - num(b.value));

    const topByQtyDesc = [...qtyProducts]
      .filter((p) => num(p.amountBase) > 0)
      .sort((a, b) => num(b.amountBase) - num(a.amountBase));
    const topByQtyAsc = [...topByQtyDesc].sort((a, b) => num(a.amountBase) - num(b.amountBase));

    const topByPriceDesc = [...products]
      .filter((p) => num(p.price) > 0)
      .sort((a, b) => num(b.price) - num(a.price));
    const topByPriceAsc = [...topByPriceDesc].sort((a, b) => num(a.price) - num(b.price));

    const topByCaloriesDesc = [...products]
      .filter((p) => num(p.calories) > 0)
      .sort((a, b) => num(b.calories) - num(a.calories));
    const topByCaloriesAsc = [...topByCaloriesDesc].sort((a, b) => num(a.calories) - num(b.calories));
    const caloriesTotal = topByCaloriesDesc.reduce((sum, p) => sum + num(p.calories), 0);
    const caloriesFun = calorieFunSummaryText(caloriesTotal, 2);

    const topByValuePerUnitDesc = [...products]
      .filter((p) => num(p.amount) > 0 && num(p.value) > 0)
      .map((p) => ({ ...p, ratio: num(p.value) / num(p.amount) }))
      .sort((a, b) => num(b.ratio) - num(a.ratio));
    const topByValuePerUnitAsc = [...topByValuePerUnitDesc].sort((a, b) => num(a.ratio) - num(b.ratio));

    const nearestDueDesc = [...products]
      .map((p) => ({ ...p, diff: dueDiffDays(p.due) }))
      .filter((p) => p.diff !== null && num(p.diff) >= 0)
      .sort((a, b) => num(a.diff) - num(b.diff));
    const nearestDueAsc = [...nearestDueDesc].sort((a, b) => num(b.diff) - num(a.diff));

    const overdueDueDesc = [...products]
      .map((p) => ({ ...p, diff: dueDiffDays(p.due) }))
      .filter((p) => p.diff !== null && num(p.diff) < 0)
      .sort((a, b) => num(a.diff) - num(b.diff));
    const overdueDueAsc = [...overdueDueDesc].sort((a, b) => num(b.diff) - num(a.diff));

    const groupsByValueDesc = rankPairsDesc(M?.byGroupValue || new Map())
      .filter((e) => clean(e[0]) && num(e[1]) > 0);
    const groupsByValueAsc = [...groupsByValueDesc].sort((a, b) => num(a[1]) - num(b[1]));

    const groupsByQtyDesc = rankPairsDesc(qtyState?.byGroupDisplay || new Map())
      .filter((e) => clean(e[0]) && num(e[1]) > 0);
    const groupsByQtyAsc = [...groupsByQtyDesc].sort((a, b) => num(a[1]) - num(b[1]));

    const brandsByValueDesc = [...brands]
      .filter((b) => clean(b.name) && num(b.value) > 0)
      .sort((a, b) => num(b.value) - num(a.value));
    const brandsByValueAsc = [...brandsByValueDesc].sort((a, b) => num(a.value) - num(b.value));

    const brandsByAvgPriceDesc = [...brands]
      .filter((b) => clean(b.name) && num(b.avg) > 0)
      .sort((a, b) => num(b.avg) - num(a.avg));
    const brandsByAvgPriceAsc = [...brandsByAvgPriceDesc].sort((a, b) => num(a.avg) - num(b.avg));

    const brandsByCoverageDesc = [...brands]
      .filter((b) => clean(b.name) && num(b.n) > 0)
      .sort((a, b) => num(b.n) - num(a.n));
    const brandsByCoverageAsc = [...brandsByCoverageDesc].sort((a, b) => num(a.n) - num(b.n));

    return [
      {
        id: 'prod_value',
        category: 'products',
        entity: 'product',
        dedupeFamily: 'prod_value',
        title: t('rank_top_value_title'),
        subtitle: t('rank_top_value_sub'),
        rowsTop: topByValueDesc.map((p) => rankingRowProduct(p, t('rank_value_text', { value: fmtMoney(p.value) }), p.value)),
        rowsBottom: topByValueAsc.map((p) => rankingRowProduct(p, t('rank_value_text', { value: fmtMoney(p.value) }), p.value)),
      },
      {
        id: 'prod_qty',
        category: 'products',
        entity: 'product',
        dedupeFamily: 'prod_qty',
        title: t('rank_top_qty_title'),
        subtitle: `${t('rank_top_qty_sub')} | ${qtyScopeDetail}`,
        qtyModeScoped: true,
        qtyScopeText: qtyScope,
        qtyUnclassifiedCount,
        rowsTop: topByQtyDesc.map((p) => rankingRowProduct(
          p,
          t('rank_quantity_text', { value: fmtQtyWithDisplay(num(p.amountDisplay), qtyState.displaySpec) }),
          p.amountBase
        )),
        rowsBottom: topByQtyAsc.map((p) => rankingRowProduct(
          p,
          t('rank_quantity_text', { value: fmtQtyWithDisplay(num(p.amountDisplay), qtyState.displaySpec) }),
          p.amountBase
        )),
      },
      {
        id: 'prod_price',
        category: 'products',
        entity: 'product',
        dedupeFamily: 'unit_cost',
        title: t('rank_top_price_title'),
        subtitle: t('rank_top_price_sub'),
        rowsTop: topByPriceDesc.map((p) => rankingRowProduct(p, t('rank_price_text', { value: fmtMoney(p.price) }), p.price)),
        rowsBottom: topByPriceAsc.map((p) => rankingRowProduct(p, t('rank_price_text', { value: fmtMoney(p.price) }), p.price)),
      },
      {
        id: 'prod_value_unit',
        category: 'products',
        entity: 'product',
        dedupeFamily: 'unit_cost',
        title: t('rank_top_value_per_unit_title'),
        subtitle: t('rank_top_value_per_unit_sub'),
        rowsTop: topByValuePerUnitDesc.map((p) => {
          const unit = cleanUnitLabel(p.stockUnitName) || t('unit_units');
          return rankingRowProduct(p, t('rank_value_per_unit_text', { unit, value: fmtMoney(p.ratio) }), p.ratio);
        }),
        rowsBottom: topByValuePerUnitAsc.map((p) => {
          const unit = cleanUnitLabel(p.stockUnitName) || t('unit_units');
          return rankingRowProduct(p, t('rank_value_per_unit_text', { unit, value: fmtMoney(p.ratio) }), p.ratio);
        }),
      },
      {
        id: 'prod_cal',
        category: 'products',
        entity: 'product',
        dedupeFamily: 'prod_cal',
        title: t('rank_top_cal_title'),
        subtitle: t('rank_top_cal_sub'),
        funNote: caloriesFun,
        rowsTop: topByCaloriesDesc.map((p) => rankingRowProduct(p, fmtKcal(p.calories), p.calories)),
        rowsBottom: topByCaloriesAsc.map((p) => rankingRowProduct(p, fmtKcal(p.calories), p.calories)),
      },
      {
        id: 'due_nearest',
        category: 'ops',
        entity: 'product',
        dedupeFamily: 'due_upcoming',
        title: t('rank_due_nearest_title'),
        subtitle: t('rank_due_nearest_sub'),
        rowsTop: nearestDueDesc.map((p) => rankingRowProduct(p, fmtDueDelta(p.diff), p.diff)),
        rowsBottom: nearestDueAsc.map((p) => rankingRowProduct(p, fmtDueDelta(p.diff), p.diff)),
      },
      {
        id: 'due_over',
        category: 'ops',
        entity: 'product',
        dedupeFamily: 'due_over',
        title: t('rank_due_over_title'),
        subtitle: t('rank_due_over_sub'),
        rowsTop: overdueDueDesc.map((p) => rankingRowProduct(p, fmtDueDelta(p.diff), p.diff)),
        rowsBottom: overdueDueAsc.map((p) => rankingRowProduct(p, fmtDueDelta(p.diff), p.diff)),
      },
      {
        id: 'group_value',
        category: 'groups',
        entity: 'group',
        dedupeFamily: 'group_value',
        title: t('rank_group_value_title'),
        subtitle: t('rank_group_value_sub'),
        rowsTop: groupsByValueDesc.map((e) => rankingRowFacet('group', e[0], t('rank_value_text', { value: fmtMoney(e[1]) }), e[1])),
        rowsBottom: groupsByValueAsc.map((e) => rankingRowFacet('group', e[0], t('rank_value_text', { value: fmtMoney(e[1]) }), e[1])),
      },
      {
        id: 'group_qty',
        category: 'groups',
        entity: 'group',
        dedupeFamily: 'group_qty',
        title: t('rank_group_qty_title'),
        subtitle: `${t('rank_group_qty_sub')} | ${qtyScopeDetail}`,
        qtyModeScoped: true,
        qtyScopeText: qtyScope,
        qtyUnclassifiedCount,
        rowsTop: groupsByQtyDesc.map((e) => rankingRowFacet(
          'group',
          e[0],
          t('rank_quantity_text', { value: fmtQtyWithDisplay(num(e[1]), qtyState.displaySpec) }),
          e[1]
        )),
        rowsBottom: groupsByQtyAsc.map((e) => rankingRowFacet(
          'group',
          e[0],
          t('rank_quantity_text', { value: fmtQtyWithDisplay(num(e[1]), qtyState.displaySpec) }),
          e[1]
        )),
      },
      {
        id: 'brand_value',
        category: 'brands',
        entity: 'brand',
        dedupeFamily: 'brand_value',
        title: t('rank_brand_value_title'),
        subtitle: t('rank_brand_value_sub'),
        rowsTop: brandsByValueDesc.map((b) => rankingRowFacet('brand', b.name, t('rank_brand_value_text', { value: fmtMoney(b.value), count: fmtProducts(b.n) }), b.value)),
        rowsBottom: brandsByValueAsc.map((b) => rankingRowFacet('brand', b.name, t('rank_brand_value_text', { value: fmtMoney(b.value), count: fmtProducts(b.n) }), b.value)),
      },
      {
        id: 'brand_avg_price',
        category: 'brands',
        entity: 'brand',
        dedupeFamily: 'brand_avg_price',
        title: t('rank_brand_avg_price_title'),
        subtitle: t('rank_brand_avg_price_sub'),
        rowsTop: brandsByAvgPriceDesc.map((b) => rankingRowFacet('brand', b.name, t('rank_avg_price_text', { value: fmtMoney(b.avg) }), b.avg)),
        rowsBottom: brandsByAvgPriceAsc.map((b) => rankingRowFacet('brand', b.name, t('rank_avg_price_text', { value: fmtMoney(b.avg) }), b.avg)),
      },
      {
        id: 'brand_coverage',
        category: 'brands',
        entity: 'brand',
        dedupeFamily: 'brand_coverage',
        title: t('rank_brand_coverage_title'),
        subtitle: t('rank_brand_coverage_sub'),
        rowsTop: brandsByCoverageDesc.map((b) => rankingRowFacet('brand', b.name, fmtProducts(b.n), b.n)),
        rowsBottom: brandsByCoverageAsc.map((b) => rankingRowFacet('brand', b.name, fmtProducts(b.n), b.n)),
      },
    ];
  }

  function rankingFullCardHtml(card) {
    const key = clean(card && card.id ? card.id : '');
    const mode = rankingPodiumMode(key);
    const rows = ensureRankingRows(mode === 'bottom' ? card.rowsBottom : card.rowsTop);
    const qtyModeControls = rankingQtyModeControlHtml(card, false);
    const funNote = clean(card && card.funNote ? card.funNote : '');
    const funNoteHtml = funNote
      ? `<div class="dash-ranking-fun-note"><strong>${escapeHtml(t('rank_cal_fun_prefix'))}:</strong> ${escapeHtml(funNote)}</div>`
      : '';
    const totalRows = rows.length;
    const rowsHtml = rows.length
      ? rows.map((row, index) => {
        const visualIndex = index + 1;
        const orderIndex = mode === 'bottom'
          ? Math.max(totalRows - index, 1)
          : visualIndex;
        const rankBadge = rankingOrderBadgeHtml(orderIndex, visualIndex, 'dash-ranking-rank');
        const labelHtml = rankingRowLabelHtml(row);
        const valueHtml = row.valueText ? `<span class="dash-ranking-value">${escapeHtml(row.valueText)}</span>` : '';
        return `
          <li class="dash-ranking-row">
            ${rankBadge}
            <div class="dash-ranking-main">
              ${labelHtml}
              ${valueHtml}
            </div>
          </li>
        `;
      }).join('')
      : `<li class="dash-ranking-empty">${escapeHtml(t('rankings_none'))}</li>`;
    const modeBadge = mode === 'bottom' ? t('rankings_mode_badge_bottom') : t('rankings_mode_badge_top');
    const nextMode = mode === 'bottom' ? 'top' : 'bottom';
    const focusedClass = clean(S.rankingsFocusedCardId || '') === key ? ' is-focused' : '';

    return `
      <div class="col-12 col-xxl-6 mb-3">
        <div class="dash-ranking-card p-3${focusedClass}" data-rank-card-id="${escapeHtml(key)}">
          <div class="dash-ranking-header">
            <div>
              <div class="dash-ranking-title">${escapeHtml(card.title)}</div>
              <div class="dash-ranking-subtitle">${escapeHtml(card.subtitle || '')}</div>
              ${qtyModeControls}
              ${funNoteHtml}
            </div>
            <button
              type="button"
              class="dash-ranking-mode-chip"
              data-rank-card-id="${escapeHtml(key)}"
              data-rank-podium-mode="${escapeHtml(nextMode)}"
              title="${escapeHtml(t('rankings_mode_toggle_title'))}"
            >
              <i class="fa-solid fa-arrows-rotate" aria-hidden="true"></i>
              <span>${escapeHtml(modeBadge)}</span>
            </button>
          </div>
          <ol class="dash-ranking-list">${rowsHtml}</ol>
        </div>
      </div>`;
  }

  function rankingPodiumCardHtml(card) {
    const key = clean(card && card.id ? card.id : '');
    const mode = rankingPodiumMode(key);
    const modeTop = mode !== 'bottom';
    const qtyModeControls = rankingQtyModeControlHtml(card, true);
    const funNote = clean(card && card.funNote ? card.funNote : '');
    const funNoteHtml = funNote
      ? `<div class="dash-ranking-fun-note"><strong>${escapeHtml(t('rank_cal_fun_prefix'))}:</strong> ${escapeHtml(funNote)}</div>`
      : '';
    const allRows = ensureRankingRows(modeTop ? card.rowsTop : card.rowsBottom);
    const selectedRows = allRows.slice(0, 3);
    const totalRows = ensureRankingRows(card.rowsTop || card.rowsBottom).length;
    const rowsHtml = selectedRows.map((row, index) => {
      const orderIndex = modeTop ? (index + 1) : Math.max(totalRows - index, 1);
      const rankClass = `rank-${Math.min(index + 1, 3)}${modeTop ? '' : ' rank-bottom'}`;
      const rankBadge = rankingOrderBadgeHtml(orderIndex, index + 1, 'dash-podium-medal');
      const labelHtml = rankingRowLabelHtml(row, 'dash-stock-facet-link-podium');
      const valueHtml = row.valueText ? `<span class="dash-podium-value">${escapeHtml(row.valueText)}</span>` : '';
      return `
        <li class="dash-podium-item ${rankClass}">
          ${rankBadge}
          <div class="dash-podium-main">
            ${labelHtml}
            ${valueHtml}
          </div>
        </li>
      `;
    }).join('');

    return `
      <div class="col-12 col-xl-6 col-xxl-4 mb-3">
        <div class="dash-podium-card p-3" data-rank-card-id="${escapeHtml(key)}">
          <div class="dash-podium-head">
            <div>
              <div class="dash-podium-title">${escapeHtml(card.title)}</div>
              <div class="dash-podium-subtitle">${escapeHtml(card.subtitle || '')}</div>
              ${qtyModeControls}
              ${funNoteHtml}
            </div>
            <button type="button" class="btn btn-sm btn-outline-secondary dash-podium-see-more" data-rank-see-more="${escapeHtml(key)}">${escapeHtml(t('rankings_see_more'))}</button>
          </div>
          <div class="dash-podium-mode" role="group" aria-label="${escapeHtml(card.title)}">
            <button type="button" class="btn btn-outline-secondary${modeTop ? ' is-active' : ''}" data-rank-card-id="${escapeHtml(key)}" data-rank-podium-mode="top">${escapeHtml(t('rankings_mode_top'))}</button>
            <button type="button" class="btn btn-outline-secondary${!modeTop ? ' is-active' : ''}" data-rank-card-id="${escapeHtml(key)}" data-rank-podium-mode="bottom">${escapeHtml(t('rankings_mode_bottom'))}</button>
          </div>
          <ol class="dash-podium-list">${rowsHtml}</ol>
        </div>
      </div>
    `;
  }

  function rankingsCategoryButtonsHtml(cards) {
    const defs = rankingCategoryDefs();
    const counts = new Map();
    cards.forEach((card) => {
      const category = normalizeRankingCategory(card && card.category ? card.category : 'all');
      if (category === 'all') return;
      counts.set(category, (counts.get(category) || 0) + 1);
    });

    const selected = normalizeRankingCategory(S.rankingsCategory);
    if (selected !== 'all' && (counts.get(selected) || 0) <= 0) {
      S.rankingsCategory = 'all';
    }
    const activeCategory = normalizeRankingCategory(S.rankingsCategory);

    return defs
      .filter((def) => def.id === 'all' || (counts.get(def.id) || 0) > 0)
      .map((def) => {
        const count = def.id === 'all' ? cards.length : (counts.get(def.id) || 0);
        const active = activeCategory === def.id ? ' is-active' : '';
        return `
          <button type="button" class="dash-rankings-cat-btn${active}" data-rankings-category="${escapeHtml(def.id)}">
            <span>${escapeHtml(def.label)}</span>
            <span class="dash-rankings-cat-count">${escapeHtml(fmt(count, 0))}</span>
          </button>
        `;
      })
      .join('');
  }

  function renderRankings(M, filtered, totalCount) {
    const grid = document.getElementById('dash_rankings_grid');
    const ctx = document.getElementById('dash_rankings_context');
    const categoryRoot = document.getElementById('dash_rankings_categories');
    const podiumRoot = document.getElementById('dash_rankings_podium_grid');
    if (!grid || !ctx || !categoryRoot || !podiumRoot) return;

    const products = Array.isArray(filtered) ? filtered : [];
    const cardsRaw = buildRankingCards(M, products);
    const cards = dedupeRankingCards(cardsRaw);

    S.rankingsCardsIndex = new Map(cards.map((card) => [clean(card.id || ''), card]));
    categoryRoot.innerHTML = rankingsCategoryButtonsHtml(cards);

    const activeCategory = normalizeRankingCategory(S.rankingsCategory);
    const visibleCards = activeCategory === 'all'
      ? cards
      : cards.filter((card) => normalizeRankingCategory(card.category) === activeCategory);

    ctx.textContent = t('ranking_context_line', {
      products: fmtProducts(products.length),
      total: fmtProducts(totalCount),
      cards: fmt(visibleCards.length, 0),
    });

    if (!visibleCards.length) {
      podiumRoot.innerHTML = `<div class="col-12"><div class="dash-podium-empty px-1 py-2">${escapeHtml(t('rankings_none'))}</div></div>`;
      grid.innerHTML = `<div class="col-12"><div class="dash-ranking-empty px-1 py-2">${escapeHtml(t('rankings_none'))}</div></div>`;
      setRankingsDetailsExpanded(false);
      return;
    }

    podiumRoot.innerHTML = visibleCards.map((card) => rankingPodiumCardHtml(card)).join('');
    grid.innerHTML = visibleCards.map((card) => rankingFullCardHtml(card)).join('');

    setRankingsDetailsExpanded(S.rankingsDetailsExpanded === true);
    if (S.rankingsDetailsExpanded && S.rankingsFocusedCardId) {
      focusRankingCard(S.rankingsFocusedCardId, false);
    }
  }

  function renderBrandRelationCompactLabels(pointsInput) {
    const brandRelLabels = document.getElementById('brand_rel_labels');
    if (!brandRelLabels) return;

    const points = Array.isArray(pointsInput) ? pointsInput : [];
    if (!points.length) {
      brandRelLabels.textContent = t('brand_rel_none');
      return;
    }

    const lines = points
      .slice(0, Math.min(points.length, 6))
      .map((b, i) => {
        const brandName = clean(b.brand || t('default_brand'));
        const metrics = `${t('metric_price_prefix')} ${fmtMoney(b.x)} | ${t('metric_value_prefix')} ${fmtMoney(b.y)} | ${fmtProducts(b.n)}`;
        return `
          <div class="dash-brand-rel-item">
            <span class="dash-brand-rel-rank">${escapeHtml(fmt(i + 1, 0))}.</span>
            ${stockFacetLinkHtml('brand', brandName, brandName)}
            <span class="dash-brand-rel-metrics">${escapeHtml(metrics)}</span>
          </div>
        `;
      });
    const suffix = points.length > 6 ? `<div class="dash-brand-rel-more text-muted">${escapeHtml(t('brand_rel_more_suffix', { count: fmt(points.length - 6, 0) }))}</div>` : '';
    brandRelLabels.innerHTML = lines.join('') + suffix;
  }

  function renderCompactChartById(chartId, metricsInput) {
    const chart = clean(chartId || '');
    const M = metricsInput;
    if (!chart || !M) return false;

    const openGroupFacet = (_idx, label) => {
      const groupName = clean(label || '');
      if (!groupName) return;
      if (norm(groupName) === norm(t('others_label')) || norm(groupName) === norm(t('no_data'))) return;
      openStockFacetView('group', groupName);
    };
    const openBrandFacet = (_idx, label) => {
      const brandName = clean(label || '');
      if (!brandName) return;
      if (norm(brandName) === norm(t('others_label')) || norm(brandName) === norm(t('no_data'))) return;
      openStockFacetView('brand', brandName);
    };

    if (chart === 'g_val') {
      const entries = rankedMapEntries(M.byGroupValue, 10, true, false, 'g_val');
      const type = getChartPref('g_val').chartType;
      if (type === 'donut') {
        chartDonut('g_val', entries, ' €', {
          compact: true,
          disableTooltip: true,
          onPointClick: openGroupFacet,
          onPointHover: (idx, _label, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('g_val', idx, entries, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        });
      } else {
        chartBar('g_val', entries, t('chart_label_value'), true, 2, {
          compact: true,
          labelMaxLength: 28,
          disableTooltip: true,
          onPointClick: openGroupFacet,
          onPointHover: (idx, _label, _value, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('g_val', idx, entries, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        });
      }
      return true;
    }
    if (chart === 'g_qty') {
      const qtyState = buildGroupQtyState(Array.isArray(S.lastFilteredRows) ? S.lastFilteredRows : [], 'g_qty');
      S.lastGroupQtyState = qtyState;
      renderGroupQtyUnclassified(qtyState);
      const entries = groupQtyEntries(qtyState, false, 'g_qty');
      const type = getChartPref('g_qty').chartType;
      if (type === 'donut') {
        chartDonut('g_qty', entries, ` ${qtyState.displaySpec.unit}`, {
          compact: true,
          disableTooltip: true,
          onPointClick: openGroupFacet,
          onPointHover: (idx, _label, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('g_qty', idx, entries, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        });
      } else {
        chartBar('g_qty', entries, t('chart_label_quantity'), false, 2, {
          compact: true,
          labelMaxLength: 18,
          disableTooltip: true,
          onPointClick: openGroupFacet,
          onPointHover: (idx, _label, _value, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('g_qty', idx, entries, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
          valueFormatter: (value, decimals) => fmtQtyWithCurrentMode(value, decimals),
        });
      }
      return true;
    }
    if (chart === 'risk') {
      const riskEntries = rankedPairs([
        [t('status_below_min'), M.below],
        [t('status_due_soon'), M.soon],
        [t('status_overdue'), M.overdue],
        [t('status_expired'), M.expired],
      ], 4, false, false, 'risk');
      const type = getChartPref('risk').chartType;
      if (type === 'bar') {
        chartBar('risk', riskEntries, t('chart_label_products'), false, 0, {
          compact: true,
          labelMaxLength: 16,
          disableTooltip: true,
          onPointHover: (_idx, pointLabel, _value, _entry, evt, chartRef) => {
            showRiskDueHoverPreview('risk', pointLabel, evt, chartRef);
          },
          onPointLeave: hideChartHoverPreview,
        });
      } else {
        chartDonut('risk', riskEntries, ` ${t('unit_products')}`, {
          disableTooltip: true,
          onPointHover: (_idx, pointLabel, _entry, evt, chartRef) => {
            showRiskDueHoverPreview('risk', pointLabel, evt, chartRef);
          },
          onPointLeave: hideChartHoverPreview,
        });
      }
      return true;
    }
    if (chart === 'due') {
      const dueEntries = rankedPairs([
        [t('due_over'), M.due.late],
        [t('due_0_3'), M.due.d3],
        [t('due_4_7'), M.due.d7],
        [t('due_8_30'), M.due.d30],
        [t('due_30_plus'), M.due.later],
        [t('due_none'), M.due.none],
      ], 6, false, false, 'due');
      const type = getChartPref('due').chartType;
      if (type === 'donut') {
        chartDonut('due', dueEntries, ` ${t('unit_products')}`, {
          disableTooltip: true,
          onPointHover: (_idx, pointLabel, _entry, evt, chartRef) => {
            showRiskDueHoverPreview('due', pointLabel, evt, chartRef);
          },
          onPointLeave: hideChartHoverPreview,
        });
      } else {
        chartBar('due', dueEntries, t('chart_label_products'), false, 0, {
          compact: true,
          labelMaxLength: 14,
          disableTooltip: true,
          onPointHover: (_idx, pointLabel, _value, _entry, evt, chartRef) => {
            showRiskDueHoverPreview('due', pointLabel, evt, chartRef);
          },
          onPointLeave: hideChartHoverPreview,
        });
      }
      return true;
    }
    if (chart === 'brand_price') {
      const bPrice = rankedBrandPrice(M, false, 'brand_price');
      const entries = bPrice.length ? bPrice : [[t('no_data'), 0]];
      const type = getChartPref('brand_price').chartType;
      if (type === 'donut') {
        chartDonut('brand_price', entries, ' €', {
          compact: true,
          disableTooltip: true,
          onPointClick: openBrandFacet,
          onPointHover: (idx, _label, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('brand_price', idx, entries, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        });
      } else {
        chartBar('brand_price', entries, t('chart_label_avg_price'), true, 2, {
          compact: true,
          labelMaxLength: 22,
          disableTooltip: true,
          onPointClick: openBrandFacet,
          onPointHover: (idx, _label, _value, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('brand_price', idx, entries, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        });
      }
      return true;
    }
    if (chart === 'brand_rel') {
      const bubble = rankedBrandBubble(M, false, 'brand_rel');
      renderBrandRelationCompactLabels(bubble);
      const type = getChartPref('brand_rel').chartType;
      const onBrandClick = (_idx, point) => {
        const brandName = clean(point && (point.brand || point.name) ? (point.brand || point.name) : '');
        if (!brandName || norm(brandName) === norm(t('no_data'))) return;
        openStockFacetView('brand', brandName);
      };
      if (type === 'scatter') {
        draw('brand_rel', brandRelScatterConfig(bubble, {
          compact: true,
          disableTooltip: true,
          onPointClick: onBrandClick,
          onPointHover: (idx, point, evt, chartRef) => {
            showChartEntityHoverPreview('brand_rel', idx, bubble, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        }));
      } else {
        draw('brand_rel', bubbleConfig(bubble, t('chart_dataset_brands'), {
          compact: true,
          disableTooltip: true,
          onPointClick: onBrandClick,
          onPointHover: (idx, point, evt, chartRef) => {
            showChartEntityHoverPreview('brand_rel', idx, bubble, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        }));
      }
      return true;
    }
    if (chart === 'top_val') {
      const topDetailed = rankedTopProductsDetailed(M, false, 'top_val');
      const entries = topDetailed.map((p) => [p.name, p.value]);
      const type = getChartPref('top_val').chartType;
      if (type === 'donut') {
        chartDonut('top_val', entries, ' €', {
          compact: true,
          disableTooltip: true,
          onPointClick: (idx) => openProduct(topDetailed[idx] ? topDetailed[idx].id : 0),
          onPointHover: (idx, _label, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('top_val', idx, topDetailed, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        });
      } else {
        chartBar(
          'top_val',
          entries,
          t('chart_label_value'),
          true,
          2,
          {
            compact: true,
            labelMaxLength: 24,
            disableTooltip: true,
            clickIds: topDetailed.map((p) => p.id),
            onPointHover: (idx, _label, _value, _entry, evt, chartRef) => {
              showChartEntityHoverPreview('top_val', idx, topDetailed, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
            },
            onPointLeave: hideChartHoverPreview,
          }
        );
      }
      return true;
    }
    if (chart === 'price_val') {
      const pts = rankedScatterPoints(M, false, 'price_val');
      const type = getChartPref('price_val').chartType;
      if (type === 'bubble') {
        draw('price_val', productBubbleConfig(pts, {
          compact: true,
          disableTooltip: true,
          openOnClick: true,
          onPointHover: (idx, point, evt, chartRef) => {
            showChartEntityHoverPreview('price_val', idx, pts, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        }));
      } else {
        draw('price_val', scatterConfig(pts, {
          compact: true,
          disableTooltip: true,
          openOnClick: true,
          onPointHover: (idx, point, evt, chartRef) => {
            showChartEntityHoverPreview('price_val', idx, pts, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        }));
      }
      return true;
    }
    if (chart === 'g_cal') {
      const entries = rankedMapEntries(M.byGroupCal, 12, true, false, 'g_cal');
      const calFunNode = document.getElementById('g_cal_fun_note');
      const totalCal = entries.reduce((sum, e) => sum + num(e[1]), 0);
      const calFunText = calorieFunSummaryText(totalCal, 1);
      if (calFunNode) {
        if (calFunText) {
          calFunNode.innerHTML = `
            <div class="dash-calorie-fun-box">
              <div class="dash-calorie-fun-title">${escapeHtml(t('rank_cal_fun_prefix'))}</div>
              <div class="dash-calorie-fun-text">${escapeHtml(calFunText)}</div>
            </div>
          `;
          calFunNode.classList.remove('d-none');
        } else {
          calFunNode.innerHTML = '';
          calFunNode.classList.add('d-none');
        }
      }
      const type = getChartPref('g_cal').chartType;
      if (type === 'donut') {
        chartDonut('g_cal', entries, ' kcal', {
          compact: true,
          disableTooltip: true,
          onPointClick: openGroupFacet,
          onPointHover: (idx, _label, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('g_cal', idx, entries, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        });
      } else {
        chartBar('g_cal', entries, t('kpi_calories'), false, 0, {
          compact: true,
          labelMaxLength: 16,
          disableTooltip: true,
          onPointClick: openGroupFacet,
          onPointHover: (idx, _label, _value, _entry, evt, chartRef) => {
            showChartEntityHoverPreview('g_cal', idx, entries, evt, chartRef, chartRef && chartRef.canvas ? chartRef.canvas : null);
          },
          onPointLeave: hideChartHoverPreview,
        });
      }
      return true;
    }
    return false;
  }

  function renderDashboard() {
    if (!document.getElementById('stock-analytics-dashboard')) return;
    const body = document.getElementById('dash_body');
    if (!body || body.classList.contains('d-none')) return;
    if (!S.dashboardReady) return;
    hideChartHoverPreview();

    const allRaw = data(false);
    const filteredRaw = data(true);
    rebuildRowMetaIndex(allRaw);
    const all = allRaw.filter((row) => row.value > 0);
    const filtered = filteredRaw.filter((row) => row.value > 0);
    S.lastAllRows = all;
    S.lastFilteredRows = filtered;
    rebuildGroupLogoDefaultCache(all);
    if (S.brandLogoLookupEnabled) rebuildBrandLogoDefaultCache(all);
    if (!S.brandLogoLookupEnabled && S.brandLogoDefaultCacheBuilt) {
      S.brandLogoDefaultCache = new Map();
      S.brandLogoDefaultCacheBuilt = false;
      S.brandLogoDefaultCacheSignature = '';
    }
    renderBrandLogoBanner(all);
    const M = aggregate(filtered);
    S.lastMetrics = M;
    S.lastGroupQtyState = buildGroupQtyState(filtered, 'g_qty');

    const signature = computeDataSignature(filtered);
    const signatureMatches = S.dataSignature && signature && S.dataSignature === signature;
    S.dataSignature = signature;
    syncAiCacheOnRender(signature, signatureMatches);
    if (!signatureMatches) {
      S.overlayActiveIndexByChart = {};
    }
    scheduleUiStateSave();
    const globalApiValue = apiStockGlobalValue();
    const globalApiValueNonZeroOnly = apiStockGlobalValueNonZeroOnly();
    const displayedValue = (S.apiStockSource === 'api/stock' && filtersAtGlobalDefault() && globalApiValue > 0)
      ? globalApiValueNonZeroOnly
      : M.value;
    const aiCfg = normalizeAiSettings(aiSettings());
    const aiActive = activeAiProvider(aiCfg);
    const lifetimeState = ensureKpiLifetimeTotalsState();
    window.__grocyDash = {
      apiLoaded: S.apiLoaded,
      apiStockRows: S.apiStockByProductId.size,
      apiBrandRows: S.apiBrandByProductId.size,
      apiStockSource: S.apiStockSource,
      apiStockRawRows: S.apiStockRawRows,
      apiQuantityConversionSource: S.apiQuantityConversionSource,
      apiQuantityConversionRows: S.apiQuantityConversionRows,
      apiBrandMethod: S.apiBrandMethod,
      apiBrandRequests: S.apiBrandRequests,
      apiBrandFailures: S.apiBrandFailures,
      apiBrandFieldNames: S.apiBrandFieldNames,
      dashboardReady: S.dashboardReady,
      dashboardOpen: S.dashboardOpen,
      dashboardView: S.dashboardView,
      aiEnabled: aiCfg.enabled === true,
      aiConfigured: isAiProviderConfigured(aiCfg, aiActive.id),
      aiProvider: aiActive.id,
      aiProviderLabel: aiActive.def.label,
      aiModel: aiProviderModelLabel(aiActive.id, aiCfg),
      aiFocusMode: normalizeAiFocusMode(aiCfg.focusMode),
      aiUiLanguageMode: normalizeUiLanguageMode(aiCfg.uiLanguageMode),
      aiUiLanguageResolved: resolveUiLanguage(aiCfg),
      aiFallbackEnabled: aiCfg.useFallback === true,
      aiFallbackProviders: aiCfg.fallbackProviders,
      aiValidationMode: normalizeAiValidationMode(aiCfg.validationMode),
      brandLogoLookupEnabled: S.brandLogoLookupEnabled === true,
      brandLogoSource: normalizeBrandLogoSource(S.brandLogoSource || 'database'),
      brandLogoDefaultCount: S.brandLogoDefaultCache.size,
      brandLogoOverrideCount: S.brandLogoOverrides.size,
      brandLogoClearedCount: S.brandLogoCleared.size,
      aiOverlayAutoCalls: S.aiOverlayAutoCalls,
      aiOverlayTotalCalls: S.aiOverlayTotalCalls,
      stockFacetType: S.stockFacetType,
      stockFacetValue: S.stockFacetValue,
      chartPrefs: S.chartPrefs,
      qtyModeSelected: getChartPref('g_qty').qtyMode,
      qtyModeResolved: S.lastGroupQtyState && S.lastGroupQtyState.resolvedMode ? S.lastGroupQtyState.resolvedMode : '',
      qtyUnclassifiedCount: S.lastGroupQtyState && Array.isArray(S.lastGroupQtyState.unclassified) ? S.lastGroupQtyState.unclassified.length : 0,
      kpiLifetimeLoaded: lifetimeState.loaded === true,
      kpiLifetimeLoading: lifetimeState.loading === true,
      kpiLifetimeValue: num(lifetimeState.value),
      kpiLifetimeCalories: num(lifetimeState.calories),
      kpiLifetimeError: clean(lifetimeState.error || ''),
      totalRows: all.length,
      filteredRows: filtered.length,
      filteredValueSum: M.value,
      globalStockValue: globalApiValue,
      globalStockValueNonZeroOnly: globalApiValueNonZeroOnly,
      valueShown: displayedValue,
      sample: filtered[0] || null,
    };

    setText('k_products', `${fmtProducts(filtered.length)} / ${fmtProducts(all.length)}`);
    setText('k_value', fmtMoney(displayedValue));
    setText('k_price', fmtMoney(M.priceAvg));
    setText('k_cal', fmtKcal(M.cal));
    setText('k_alert', fmtAlerts(M.alert));
    setText('k_brand', fmtBrands(M.brand.length));
    renderKpiFunPanels(displayedValue, M.cal, filtered);

    insights(M, filtered.length, all.length);
    renderGlobalConclusions(M, filtered.length, all.length, displayedValue);
    renderRankings(M, filtered, all.length);

    if (!window.Chart) {
      const ul = document.getElementById('dash_insights');
      const brandRelLabels = document.getElementById('brand_rel_labels');
      if (ul) {
        ul.innerHTML += `<li>${escapeHtml(t('charts_unavailable'))}</li>`;
      }
      if (brandRelLabels) {
        brandRelLabels.textContent = '';
      }
      clearCharts();
      return;
    }

    if (!filtered.length) {
      const brandRelLabels = document.getElementById('brand_rel_labels');
      if (brandRelLabels) {
        brandRelLabels.textContent = '';
      }
      clearCharts();
      return;
    }

    CHART_IDS.forEach((chartId) => {
      renderCompactChartById(chartId, M);
    });
    CHART_IDS.forEach((chartId) => {
      syncChartControls(chartId);
    });

    if (!S.uiStateRestored) {
      S.uiStateRestored = true;
      if (signatureMatches && S.savedFullChartId) {
        S.fullChartId = '';
        openChartOverlay(S.savedFullChartId);
      }
    }

    if (S.fullChartId) {
      renderExpandedChart(S.fullChartId);
    }
  }

  function renderExpandedChart(chartId) {
    if (!chartId || !S.lastMetrics || !window.Chart) return;
    hideChartHoverPreview();
    renderOverlayChartControls(chartId);
    const details = document.getElementById('dash_chart_overlay_details');
    const funWrap = document.getElementById('dash_chart_overlay_fun');
    const M = S.lastMetrics;
    let cfg = null;
    let detailHtml = '';
    let contextData = [];
    const forceAll = overlayForceAllForChart(chartId);
    const savedIndexBeforeRefresh = Number.isInteger(S.overlayActiveIndexByChart[chartId])
      ? S.overlayActiveIndexByChart[chartId]
      : -1;
    const focusBeforeRefresh = S.overlayFocus
      && clean((S.overlayFocus && S.overlayFocus.chartId) || '') === clean(chartId)
      ? S.overlayFocus
      : null;

    if (chartId === 'g_val') {
      const entries = rankedMapEntries(M.byGroupValue, 10, true, forceAll, 'g_val');
      const type = getChartPref('g_val').chartType;
      cfg = type === 'donut'
        ? donutConfig(entries, ' €', { compact: false })
        : barConfig(entries, t('chart_label_value'), true, 2, { compact: false, labelMaxLength: 48 });
      detailHtml = formatLinesForOverlay(entries, (e) => `${e[0]}: ${fmtMoney(e[1])}`, { chartId: 'g_val', showFacetThumbs: true });
      contextData = entries;
    } else if (chartId === 'g_qty') {
      const qtyState = buildGroupQtyState(Array.isArray(S.lastFilteredRows) ? S.lastFilteredRows : [], 'g_qty');
      S.lastGroupQtyState = qtyState;
      const entries = groupQtyEntries(qtyState, forceAll, 'g_qty');
      const type = getChartPref('g_qty').chartType;
      cfg = type === 'donut'
        ? donutConfig(entries, ` ${qtyState.displaySpec.unit}`, { compact: false })
        : barConfig(entries, t('chart_label_quantity'), false, 2, {
          compact: false,
          labelMaxLength: 40,
          valueFormatter: (value, decimals) => fmtQtyWithCurrentMode(value, decimals),
        });
      detailHtml = `${formatLinesForOverlay(entries, (e) => `${e[0]}: ${fmtQtyWithCurrentMode(e[1])}`, { chartId: 'g_qty', showFacetThumbs: true })}<div class="mt-2">${groupQtyUnclassifiedHtml(qtyState, 14)}</div>`;
      contextData = entries;
    } else if (chartId === 'risk') {
      const entries = rankedPairs([
        [t('status_below_min'), M.below],
        [t('status_due_soon'), M.soon],
        [t('status_overdue'), M.overdue],
        [t('status_expired'), M.expired],
      ], 4, false, true, 'risk');
      const type = getChartPref('risk').chartType;
      cfg = type === 'bar'
        ? barConfig(entries, t('chart_label_products'), false, 0, { compact: false, labelMaxLength: 32 })
        : donutConfig(entries, ` ${t('unit_products')}`, { compact: false });
      detailHtml = formatLinesForOverlay(entries, (e) => `${e[0]}: ${fmtProducts(e[1])}`);
      contextData = entries;
    } else if (chartId === 'due') {
      const entries = rankedPairs([
        [t('due_over'), M.due.late],
        [t('due_0_3'), M.due.d3],
        [t('due_4_7'), M.due.d7],
        [t('due_8_30'), M.due.d30],
        [t('due_30_plus'), M.due.later],
        [t('due_none'), M.due.none],
      ], 6, false, true, 'due');
      const type = getChartPref('due').chartType;
      cfg = type === 'donut'
        ? donutConfig(entries, ` ${t('unit_products')}`, { compact: false })
        : barConfig(entries, t('chart_label_products'), false, 0, { compact: false, labelMaxLength: 30 });
      detailHtml = formatLinesForOverlay(entries, (e) => `${e[0]}: ${fmtProducts(e[1])}`);
      contextData = entries;
    } else if (chartId === 'brand_price') {
      const entries = rankedBrandPrice(M, forceAll, 'brand_price');
      const type = getChartPref('brand_price').chartType;
      cfg = type === 'donut'
        ? donutConfig(entries, ' €', { compact: false })
        : barConfig(entries, t('chart_label_avg_price'), true, 2, { compact: false, labelMaxLength: 42 });
      detailHtml = formatLinesForOverlay(entries, (e) => `${e[0]}: ${fmtMoney(e[1])}`, { chartId: 'brand_price', showFacetThumbs: true });
      contextData = entries;
    } else if (chartId === 'brand_rel') {
      const points = rankedBrandBubble(M, forceAll, 'brand_rel');
      const type = getChartPref('brand_rel').chartType;
      cfg = type === 'scatter'
        ? brandRelScatterConfig(points, { compact: false })
        : bubbleConfig(points, t('chart_dataset_brands'), { compact: false });
      detailHtml = formatLinesForOverlay(points, (p) => `${p.brand}: ${t('metric_price_prefix')} ${fmtMoney(p.x)} | ${t('metric_value_prefix')} ${fmtMoney(p.y)} | ${fmtProducts(p.n)}`, { chartId: 'brand_rel', showFacetThumbs: true });
      contextData = points;
    } else if (chartId === 'top_val') {
      const topDetailed = rankedTopProductsDetailed(M, forceAll, 'top_val');
      const entries = topDetailed.map((p) => [p.name, p.value]);
      const type = getChartPref('top_val').chartType;
      cfg = type === 'donut'
        ? donutConfig(entries, ' €', { compact: false })
        : barConfig(entries, t('chart_label_value'), true, 2, { compact: false, labelMaxLength: 44 });
      detailHtml = formatLinesForOverlay(entries, (e) => `${e[0]}: ${fmtMoney(e[1])}`);
      contextData = topDetailed;
    } else if (chartId === 'price_val') {
      const points = rankedScatterPoints(M, forceAll, 'price_val');
      const type = getChartPref('price_val').chartType;
      cfg = type === 'bubble'
        ? productBubbleConfig(points, { compact: false, openOnClick: false })
        : scatterConfig(points, { compact: false, openOnClick: false });
      detailHtml = formatLinesForOverlay(points, (p) => `${p.name}: ${t('metric_price_prefix')} ${fmtMoney(p.x)} | ${t('metric_value_prefix')} ${fmtMoney(p.y)}${p.group ? ` | ${t('metric_group_prefix')} ${p.group}` : ''}`);
      contextData = points;
    } else if (chartId === 'g_cal') {
      const entries = rankedMapEntries(M.byGroupCal, 12, true, forceAll, 'g_cal');
      const type = getChartPref('g_cal').chartType;
      cfg = type === 'donut'
        ? donutConfig(entries, ' kcal', { compact: false })
        : barConfig(entries, t('kpi_calories'), false, 0, { compact: false, labelMaxLength: 34 });
      detailHtml = formatLinesForOverlay(entries, (e) => `${e[0]}: ${fmtKcal(e[1])}`, { chartId: 'g_cal', showFacetThumbs: true });
      contextData = entries;
    }

    if (cfg) {
      cfg.options = cfg.options || {};
      cfg.options.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];
      if (isChartJsV2()) {
        cfg.options.animation = { duration: 0 };
        cfg.options.responsiveAnimationDuration = 0;
      } else {
        cfg.options.animation = { duration: 0 };
        cfg.options.transitions = cfg.options.transitions || {};
        cfg.options.transitions.active = { animation: { duration: 0 } };
        cfg.options.transitions.resize = { animation: { duration: 0 } };
      }
      cfg.options.hover = cfg.options.hover || {};
      cfg.options.hover.mode = null;
      cfg.options.hover.intersect = true;
      if (cfg.options.plugins && cfg.options.plugins.tooltip) {
        cfg.options.plugins.tooltip.enabled = false;
      }
      if (cfg.options.tooltips) {
        cfg.options.tooltips.enabled = false;
      }
      const previousOnClick = cfg.options.onClick;
      cfg.options.onClick = function onOverlayClick(evt, elements, chartRef) {
        const chart = chartRef || this;
        const list = Array.isArray(elements) ? elements : [];
        const resolved = list.length ? list : chartElementsFromEvent(chart, evt, true);
        cancelOverlayHoverClear();
        if (list.length > 0) {
          const datasetIndex = chartElementIndex(list[0]);
          const logicalIndex = overlayDatasetToLogicalIndex(chart, datasetIndex);
          if (logicalIndex >= 0) {
            setOverlayChartActiveIndex(logicalIndex, true);
            handleOverlayChartClick(logicalIndex);
          }
        } else if (resolved.length > 0) {
          const datasetIndex = chartElementIndex(resolved[0]);
          const logicalIndex = overlayDatasetToLogicalIndex(chart, datasetIndex);
          if (logicalIndex >= 0) {
            setOverlayChartActiveIndex(logicalIndex, true);
            handleOverlayChartClick(logicalIndex);
          }
        }
        if (typeof previousOnClick === 'function') {
          try { previousOnClick.call(this, evt, elements, chartRef); } catch (_err) {}
        }
      };
      cfg.options.onHover = function onOverlayHover(evt, elements, chartRef) {
        const chart = chartRef || this;
        const evtType = clean((evt && evt.type) || (evt && evt.native && evt.native.type) || '');
        if (evtType === 'mouseout' || evtType === 'mouseleave') {
          cancelOverlayHoverClear();
          clearOverlayChartActiveIndex();
          hideChartHoverPreview();
          if (chart && chart.canvas) chart.canvas.style.cursor = 'default';
          return;
        }
        const list = Array.isArray(elements) ? elements : [];
        const resolved = list.length ? list : chartElementsFromEvent(chart, evt, false);
        if (resolved.length > 0) {
          cancelOverlayHoverClear();
          const datasetIndex = chartElementIndex(resolved[0]);
          const logicalIndex = overlayDatasetToLogicalIndex(chart, datasetIndex);
          if (logicalIndex >= 0) {
            setOverlayChartActiveIndex(logicalIndex, true);
            showChartEntityHoverPreview(chartId, logicalIndex, contextData, evt, chart, chart && chart.canvas ? chart.canvas : null);
            if (chart && chart.canvas) chart.canvas.style.cursor = 'pointer';
            return;
          }
        }
        scheduleOverlayHoverClear(75);
        if (chart && chart.canvas) {
          chart.canvas.style.cursor = 'default';
        }
      };
      S.fullChartContext = { chartId, contextData, metrics: M };
      if (!focusBeforeRefresh) {
        S.overlayFocus = null;
        const focusMeta = document.getElementById('dash_chart_overlay_focus_local_meta');
        if (focusMeta) focusMeta.textContent = t('overlay_focus_hint');
        const focusLinks = document.getElementById('dash_chart_overlay_focus_local_links');
        if (focusLinks) focusLinks.innerHTML = '';
        const focusStats = document.getElementById('dash_chart_overlay_focus_local_stats');
        if (focusStats) focusStats.innerHTML = '';
        const focusLogo = document.getElementById('dash_chart_overlay_focus_local_logo');
        if (focusLogo) {
          focusLogo.innerHTML = '';
          focusLogo.classList.remove('is-clickable');
          focusLogo.removeAttribute('title');
        }
        const focusProducts = document.getElementById('dash_chart_overlay_focus_local_products');
        if (focusProducts) {
          focusProducts.innerHTML = '';
          focusProducts.classList.remove('is-open');
        }
        const focusAi = document.getElementById('dash_chart_overlay_focus_ai_body');
        if (focusAi) focusAi.textContent = t('overlay_ai_waiting');
        const focusAiState = document.getElementById('dash_chart_overlay_focus_ai_state');
        if (focusAiState) focusAiState.textContent = '';
        const focusAiPanel = document.getElementById('dash_chart_overlay_focus_ai');
        if (focusAiPanel) focusAiPanel.classList.remove('is-collapsed');
        const focusAiBtn = document.getElementById('dash_focus_ai_settings');
        if (focusAiBtn) focusAiBtn.classList.add('d-none');
        const focusBtn = document.getElementById('dash_focus_open_product');
        if (focusBtn) focusBtn.classList.add('d-none');
      }
      drawOverlayChart(cfg);
      renderOverlayLegend(chartId, cfg);
      renderOverlayNarrative(chartId, M, contextData);
    }
    if (details) details.innerHTML = detailHtml;
    renderOverlayFunComparisons(chartId, contextData);
    if (funWrap) {
      const body = document.getElementById('dash_chart_overlay_fun_body');
      if (!body || !clean(body.textContent || body.innerHTML || '')) {
        funWrap.classList.add('d-none');
      }
    }
    const savedIndex = savedIndexBeforeRefresh;
    if (savedIndex >= 0 && Array.isArray(contextData) && savedIndex < contextData.length) {
      setOverlayChartActiveIndex(savedIndex, true);
      handleOverlayChartClick(savedIndex, 'restore');
    } else if (focusBeforeRefresh) {
      renderOverlayFocusCard(focusBeforeRefresh, false, 'restore');
    }
  }

  function bindDraw() {
    if (S.drawBound) return;
    const d = dt();
    if (d) {
      d.on('draw.stockAnalytics', scheduleRender);
      S.drawBound = true;
      scheduleRender();
      return;
    }
    if (S.drawTry > 120) return;
    S.drawTry += 1;
    setTimeout(bindDraw, 200);
  }

  function isProductFormPage() {
    const path = clean(window.location.pathname);
    return /\/product\/(new|\d+)\/?$/.test(path);
  }

  function isStatusTerminalHostPage() {
    if (isProductFormPage()) return true;
    return !!document.getElementById('stock-overview-table');
  }

  function isLookupNotFoundMessage(messageInput = '') {
    const message = clean(messageInput || '').toLowerCase();
    if (!message) return false;
    return message.includes('introuvable')
      || message.includes('no reliable barcode found')
      || message.includes('not found')
      || message.includes('aucun')
      || message.includes('no result')
      || message.includes('no product');
  }

  function buildProductNameFallbackVariants(nameInput = '', limitInput = 16) {
    const source = clean(nameInput || '').replace(/\s+/g, ' ').trim();
    const limit = Math.max(4, Math.min(40, num(limitInput) || 16));
    if (!source) return [];
    const out = [];
    const seen = new Set();
    const add = (value) => {
      const cleaned = clean(value || '').replace(/\s+/g, ' ').trim();
      if (!cleaned || cleaned.length < 2) return;
      const key = norm(cleaned);
      if (!key || seen.has(key)) return;
      seen.add(key);
      out.push(cleaned);
    };

    add(source);
    add(source.replace(/\([^)]*\)/g, ' '));

    const splitDash = source.split(/\s*-\s*/).map((part) => clean(part)).filter((part) => !!part);
    for (let i = splitDash.length - 1; i >= 1; i -= 1) {
      add(splitDash.slice(0, i).join(' - '));
    }
    if (splitDash.length > 0) add(splitDash[0]);

    const qtyRegex = /\b\d+(?:[.,]\d+)?\s*(kg|g|mg|l|ml|cl|dl|x|pcs?|pi[eè]ce?s?|u|unit[eé]s?)\b/ig;
    const pass1 = out.slice();
    for (const entry of pass1) add(entry.replace(qtyRegex, ' '));

    const pass2 = out.slice();
    for (const entry of pass2) {
      const tokens = entry.split(/\s+/).map((token) => clean(token)).filter((token) => !!token);
      for (let len = tokens.length - 1; len >= 2; len -= 1) {
        add(tokens.slice(0, len).join(' '));
        if (out.length >= limit) break;
      }
      if (out.length >= limit) break;
    }
    return out.slice(0, limit);
  }

  function defaultProductStatusTerminalSettings() {
    return {
      pinned: false,
      expanded: false,
    };
  }

  function normalizeProductStatusTerminalSettings(rawSettings) {
    const fallback = defaultProductStatusTerminalSettings();
    const raw = rawSettings && typeof rawSettings === 'object' ? rawSettings : {};
    return {
      pinned: boolish(raw.pinned),
      expanded: boolish(raw.expanded),
    };
  }

  function loadProductStatusTerminalSettings() {
    const fallback = defaultProductStatusTerminalSettings();
    try {
      const raw = localStorage.getItem(PRODUCT_STATUS_TERMINAL_SETTINGS_KEY);
      const parsed = raw ? JSON.parse(raw) : fallback;
      const normalized = normalizeProductStatusTerminalSettings(parsed);
      S.productStatusTerminalPinned = normalized.pinned;
      S.productStatusTerminalExpanded = normalized.expanded;
      S.productStatusTerminalSettingsLoaded = true;
      return normalized;
    } catch (_err) {
      S.productStatusTerminalPinned = fallback.pinned;
      S.productStatusTerminalExpanded = fallback.expanded;
      S.productStatusTerminalSettingsLoaded = true;
      return fallback;
    }
  }

  function saveProductStatusTerminalSettings() {
    const payload = normalizeProductStatusTerminalSettings({
      pinned: S.productStatusTerminalPinned,
      expanded: S.productStatusTerminalExpanded,
    });
    S.productStatusTerminalPinned = payload.pinned;
    S.productStatusTerminalExpanded = payload.expanded;
    S.productStatusTerminalSettingsLoaded = true;
    try {
      localStorage.setItem(PRODUCT_STATUS_TERMINAL_SETTINGS_KEY, JSON.stringify(payload));
    } catch (_err) {
      // Ignore localStorage quota/private mode issues.
    }
    return payload;
  }

  function serializeProductStatusTerminalEntries(limitInput = 140) {
    const entries = Array.isArray(S.productStatusEntries) ? S.productStatusEntries : [];
    const limit = Math.max(10, Math.min(220, num(limitInput) || 140));
    return entries.slice(-limit).map((entry) => {
      const tone = productStatusTerminalTone(entry && entry.tone ? entry.tone : 'info');
      const text = clean(entry && entry.text ? entry.text : '');
      const source = clean(entry && entry.source ? entry.source : '');
      const details = normalizeProductStatusTerminalDetails(entry && entry.details ? entry.details : []);
      const ts = num(entry && entry.ts) > 0 ? num(entry.ts) : Date.now();
      const timeLabel = clean(entry && entry.timeLabel ? entry.timeLabel : productStatusTerminalTime(ts));
      const repeat = Math.max(1, num(entry && entry.repeat));
      return {
        id: clean(entry && entry.id ? entry.id : ''),
        tone,
        text,
        source,
        details,
        detailsSig: details.join(' | '),
        ts,
        timeLabel,
        repeat,
      };
    }).filter((entry) => entry.text);
  }

  function clearProductStatusTerminalSession() {
    try {
      sessionStorage.removeItem(PRODUCT_STATUS_TERMINAL_SESSION_KEY);
    } catch (_err) {
      // Ignore storage access issues.
    }
  }

  function saveProductStatusTerminalSession(optionsInput = null) {
    try {
      const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
      const entries = serializeProductStatusTerminalEntries(140);
      const payload = {
        entries,
        expanded: Object.prototype.hasOwnProperty.call(options, 'expanded')
          ? boolish(options.expanded)
          : S.productStatusTerminalExpanded === true,
        pinned: Object.prototype.hasOwnProperty.call(options, 'pinned')
          ? boolish(options.pinned)
          : S.productStatusTerminalPinned === true,
        reason: clean(options.reason || ''),
        ts: Date.now(),
      };
      if (payload.entries.length === 0 && payload.pinned !== true && payload.expanded !== true) {
        clearProductStatusTerminalSession();
        return null;
      }
      sessionStorage.setItem(PRODUCT_STATUS_TERMINAL_SESSION_KEY, JSON.stringify(payload));
      return payload;
    } catch (_err) {
      return null;
    }
  }

  function loadProductStatusTerminalSession() {
    try {
      const raw = sessionStorage.getItem(PRODUCT_STATUS_TERMINAL_SESSION_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== 'object') return null;
      const ts = num(parsed.ts) > 0 ? num(parsed.ts) : 0;
      if (ts > 0 && (Date.now() - ts) > (1000 * 60 * 60 * 24)) {
        clearProductStatusTerminalSession();
        return null;
      }
      const rawEntries = Array.isArray(parsed.entries) ? parsed.entries : [];
      const entries = rawEntries.map((entry) => {
        const tone = productStatusTerminalTone(entry && entry.tone ? entry.tone : 'info');
        const text = clean(entry && entry.text ? entry.text : '');
        if (!text) return null;
        const source = clean(entry && entry.source ? entry.source : '');
        const details = normalizeProductStatusTerminalDetails(entry && entry.details ? entry.details : []);
        const tsValue = num(entry && entry.ts) > 0 ? num(entry.ts) : Date.now();
        return {
          id: clean(entry && entry.id ? entry.id : ''),
          tone,
          text,
          source,
          details,
          detailsSig: details.join(' | '),
          ts: tsValue,
          timeLabel: clean(entry && entry.timeLabel ? entry.timeLabel : productStatusTerminalTime(tsValue)),
          repeat: Math.max(1, num(entry && entry.repeat)),
        };
      }).filter((entry) => !!entry);
      return {
        entries: entries.slice(-140),
        expanded: boolish(parsed.expanded),
        pinned: boolish(parsed.pinned),
        reason: clean(parsed.reason || ''),
      };
    } catch (_err) {
      return null;
    }
  }

  function restoreProductStatusTerminalFromSession() {
    const payload = loadProductStatusTerminalSession();
    if (!payload) return false;
    const current = Array.isArray(S.productStatusEntries) ? S.productStatusEntries.slice() : [];
    const restored = Array.isArray(payload.entries) ? payload.entries : [];
    if (restored.length > 0) {
      const seen = new Set();
      const merged = [...current, ...restored].map((entry) => {
        const tone = productStatusTerminalTone(entry && entry.tone ? entry.tone : 'info');
        const text = clean(entry && entry.text ? entry.text : '');
        const source = clean(entry && entry.source ? entry.source : '');
        const details = normalizeProductStatusTerminalDetails(entry && entry.details ? entry.details : []);
        const detailsSig = details.join(' | ');
        const key = `${tone}|${text}|${source}|${detailsSig}`;
        if (!text || seen.has(key)) return null;
        seen.add(key);
        const ts = num(entry && entry.ts) > 0 ? num(entry.ts) : Date.now();
        return {
          id: clean(entry && entry.id ? entry.id : ''),
          tone,
          text,
          source,
          details,
          detailsSig,
          ts,
          timeLabel: clean(entry && entry.timeLabel ? entry.timeLabel : productStatusTerminalTime(ts)),
          repeat: Math.max(1, num(entry && entry.repeat)),
        };
      }).filter((entry) => !!entry);
      S.productStatusEntries = merged.slice(-220);
      S.productStatusEntrySeq = Math.max(num(S.productStatusEntrySeq), S.productStatusEntries.length + 1);
    }
    if (payload.expanded === true) {
      S.productStatusTerminalExpanded = true;
    }
    if (payload.pinned === true) {
      S.productStatusTerminalPinned = true;
    }
    saveProductStatusTerminalSettings();
    clearProductStatusTerminalSession();
    return true;
  }

  function productStatusTerminalPointerX(event) {
    if (!event) return 0;
    if (typeof event.clientX === 'number') return event.clientX;
    if (event.touches && event.touches[0] && typeof event.touches[0].clientX === 'number') return event.touches[0].clientX;
    if (event.changedTouches && event.changedTouches[0] && typeof event.changedTouches[0].clientX === 'number') return event.changedTouches[0].clientX;
    return 0;
  }

  function productStatusTerminalDetailValue(value, depth = 0) {
    if (value === null || value === undefined) return '';
    if (depth > 2) return clean(String(value));
    if (Array.isArray(value)) {
      return value
        .map((item) => productStatusTerminalDetailValue(item, depth + 1))
        .filter((item) => !!item)
        .join(', ');
    }
    if (typeof value === 'object') {
      return Object.entries(value)
        .slice(0, 12)
        .map(([k, v]) => {
          const key = clean(k || '');
          const text = productStatusTerminalDetailValue(v, depth + 1);
          if (!key || !text) return '';
          return `${key}=${text}`;
        })
        .filter((item) => !!item)
        .join(', ');
    }
    if (typeof value === 'number') {
      return Number.isFinite(value) ? String(value) : '';
    }
    return clean(String(value));
  }

  function normalizeProductStatusTerminalDetails(detailsInput = null) {
    const lines = [];
    const pushLine = (lineInput = '') => {
      const line = clean(lineInput || '');
      if (!line) return;
      lines.push(line);
    };

    if (Array.isArray(detailsInput)) {
      detailsInput.forEach((item) => {
        if (item && typeof item === 'object' && !Array.isArray(item)
          && Object.prototype.hasOwnProperty.call(item, 'label')
          && Object.prototype.hasOwnProperty.call(item, 'value')) {
          const label = clean(item.label || '');
          const value = productStatusTerminalDetailValue(item.value);
          if (label && value) pushLine(`${label}: ${value}`);
          else if (label) pushLine(label);
          else pushLine(value);
          return;
        }
        pushLine(productStatusTerminalDetailValue(item));
      });
    } else if (detailsInput && typeof detailsInput === 'object') {
      Object.entries(detailsInput).forEach(([key, value]) => {
        const label = clean(key || '');
        const text = productStatusTerminalDetailValue(value);
        if (!label && !text) return;
        if (!label) {
          pushLine(text);
          return;
        }
        if (!text) {
          pushLine(label);
          return;
        }
        pushLine(`${label}: ${text}`);
      });
    } else {
      pushLine(productStatusTerminalDetailValue(detailsInput));
    }
    return lines.slice(0, 40);
  }

  function nextProductStatusTerminalEntryId() {
    S.productStatusEntrySeq = Math.max(0, num(S.productStatusEntrySeq)) + 1;
    return `pst-${S.productStatusEntrySeq}`;
  }

  function removeProductStatusTerminalEntryById(entryIdInput = '') {
    const entryId = clean(entryIdInput || '');
    if (!entryId) return;
    const entries = Array.isArray(S.productStatusEntries) ? S.productStatusEntries : [];
    if (entries.length === 0) return;
    const next = entries.filter((entry) => clean(entry && entry.id ? entry.id : '') !== entryId);
    if (next.length === entries.length) return;
    S.productStatusEntries = next;
    S.productStatusTerminalUnseen = Math.min(Math.max(0, num(S.productStatusTerminalUnseen)), next.length);
    saveProductStatusTerminalSession();
    renderProductStatusTerminal();
  }

  function bindProductStatusTerminalRowSwipe(row) {
    if (!row || row.dataset.swipeBound === '1') return;
    row.dataset.swipeBound = '1';
    row.style.touchAction = 'pan-y';
    let pointerId = null;
    let startX = 0;
    let currentX = 0;
    let active = false;

    const resetRow = () => {
      row.classList.remove('is-swiping', 'is-swipe-ready');
      row.style.transition = 'transform 180ms ease, opacity 180ms ease';
      row.style.transform = 'translateX(0px)';
      row.style.opacity = '1';
      row.style.willChange = '';
    };

    const stopSwipe = (event, commit = false) => {
      if (!active) return;
      if (event && pointerId !== null && typeof event.pointerId === 'number' && event.pointerId !== pointerId) return;
      const delta = currentX - startX;
      const threshold = Math.max(90, Math.round((row.clientWidth || 320) * 0.24));
      const shouldDismiss = commit && Math.abs(delta) >= threshold;
      if (shouldDismiss) {
        const direction = delta >= 0 ? 1 : -1;
        const outX = direction * Math.max(280, (row.clientWidth || 320) + 80);
        row.classList.add('is-swipe-dismiss');
        row.style.transition = 'transform 190ms ease, opacity 190ms ease';
        row.style.transform = `translateX(${outX}px)`;
        row.style.opacity = '0';
        const entryId = row.getAttribute('data-entry-id');
        window.setTimeout(() => {
          removeProductStatusTerminalEntryById(entryId || '');
        }, 180);
      } else {
        resetRow();
      }
      active = false;
      pointerId = null;
      try {
        if (event && typeof event.pointerId === 'number' && row.hasPointerCapture && row.hasPointerCapture(event.pointerId)) {
          row.releasePointerCapture(event.pointerId);
        }
      } catch (_err) {}
    };

    row.addEventListener('pointerdown', (event) => {
      if (typeof event.button === 'number' && event.button !== 0) return;
      if (event.target && event.target.closest && event.target.closest('a,button,input,select,textarea,label')) return;
      pointerId = typeof event.pointerId === 'number' ? event.pointerId : null;
      startX = productStatusTerminalPointerX(event);
      currentX = startX;
      active = true;
      row.classList.add('is-swiping');
      row.style.transition = 'none';
      row.style.willChange = 'transform, opacity';
      try {
        if (typeof event.pointerId === 'number' && row.setPointerCapture) row.setPointerCapture(event.pointerId);
      } catch (_err) {}
    });

    row.addEventListener('pointermove', (event) => {
      if (!active) return;
      if (pointerId !== null && typeof event.pointerId === 'number' && event.pointerId !== pointerId) return;
      currentX = productStatusTerminalPointerX(event);
      const delta = currentX - startX;
      row.style.transform = `translateX(${delta}px)`;
      row.style.opacity = String(Math.max(0.28, 1 - (Math.min(220, Math.abs(delta)) / 260)));
      row.classList.toggle('is-swipe-ready', Math.abs(delta) >= 90);
      if (event.cancelable) event.preventDefault();
    });

    row.addEventListener('pointerup', (event) => stopSwipe(event, true));
    row.addEventListener('pointercancel', (event) => stopSwipe(event, false));
    row.addEventListener('lostpointercapture', (event) => stopSwipe(event, false));
  }

  function productStatusTerminalTone(toneInput = '') {
    const tone = clean(toneInput || '').toLowerCase();
    if (tone === 'data') return 'data';
    if (tone === 'danger' || tone === 'error') return 'danger';
    if (tone === 'success') return 'success';
    if (tone === 'warning') return 'warning';
    if (tone === 'muted') return 'muted';
    return 'info';
  }

  function productStatusTerminalTime(tsInput = 0) {
    const ts = num(tsInput) > 0 ? num(tsInput) : Date.now();
    const d = new Date(ts);
    const hh = String(d.getHours()).padStart(2, '0');
    const mm = String(d.getMinutes()).padStart(2, '0');
    const ss = String(d.getSeconds()).padStart(2, '0');
    return `${hh}:${mm}:${ss}`;
  }

  function ensureProductStatusTerminalElements() {
    if (!isStatusTerminalHostPage()) return null;
    initOpenFoodFactsToolsStyle();
    let root = document.getElementById('grocy-product-status-terminal');
    if (!root) {
      root = document.createElement('div');
      root.id = 'grocy-product-status-terminal';
      root.className = 'grocy-product-terminal d-none';
      root.innerHTML = `
        <button type="button" class="grocy-product-terminal-toggle" data-product-terminal-toggle="1"
          title="${escapeHtml(langText('Terminal des actions', 'Actions terminal'))}">
          <i class="fa-solid fa-terminal"></i>
          <span class="grocy-product-terminal-badge d-none" data-product-terminal-badge="1">0</span>
        </button>
        <section class="grocy-product-terminal-panel d-none" data-product-terminal-panel="1">
          <div class="grocy-product-terminal-head">
            <strong>${escapeHtml(langText('Terminal des actions', 'Actions terminal'))}</strong>
            <div class="grocy-product-terminal-head-actions">
              <button type="button" class="btn btn-outline-secondary btn-sm px-2 py-0" data-product-terminal-pin="1" title="${escapeHtml(langText('Épingler le terminal', 'Pin terminal'))}">
                <i class="fa-solid fa-thumbtack"></i>
              </button>
              <button type="button" class="btn btn-outline-secondary btn-sm px-2 py-0" data-product-terminal-clear="1">${escapeHtml(langText('Effacer', 'Clear'))}</button>
              <button type="button" class="btn btn-outline-secondary btn-sm px-2 py-0" data-product-terminal-collapse="1">
                <i class="fa-solid fa-chevron-down"></i>
              </button>
            </div>
          </div>
          <div class="grocy-product-terminal-list" data-product-terminal-list="1"></div>
        </section>
      `;
      document.body.appendChild(root);
    }

    if (root.dataset.bound !== '1') {
      root.dataset.bound = '1';
      const toggle = root.querySelector('[data-product-terminal-toggle="1"]');
      const pinBtn = root.querySelector('[data-product-terminal-pin="1"]');
      const clearBtn = root.querySelector('[data-product-terminal-clear="1"]');
      const collapseBtn = root.querySelector('[data-product-terminal-collapse="1"]');
      if (toggle) {
        toggle.addEventListener('click', () => {
          S.productStatusTerminalExpanded = !S.productStatusTerminalExpanded;
          if (S.productStatusTerminalExpanded) S.productStatusTerminalUnseen = 0;
          saveProductStatusTerminalSettings();
          saveProductStatusTerminalSession();
          renderProductStatusTerminal();
        });
      }
      if (pinBtn) {
        pinBtn.addEventListener('click', () => {
          S.productStatusTerminalPinned = !S.productStatusTerminalPinned;
          saveProductStatusTerminalSettings();
          saveProductStatusTerminalSession();
          renderProductStatusTerminal();
        });
      }
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          S.productStatusEntries = [];
          S.productStatusTerminalUnseen = 0;
          if (!S.productStatusTerminalPinned) {
            S.productStatusTerminalExpanded = false;
          }
          saveProductStatusTerminalSettings();
          clearProductStatusTerminalSession();
          renderProductStatusTerminal();
        });
      }
      if (collapseBtn) {
        collapseBtn.addEventListener('click', () => {
          S.productStatusTerminalExpanded = !S.productStatusTerminalExpanded;
          if (S.productStatusTerminalExpanded) S.productStatusTerminalUnseen = 0;
          saveProductStatusTerminalSettings();
          saveProductStatusTerminalSession();
          renderProductStatusTerminal();
        });
      }
    }
    S.productStatusTerminalReady = true;
    return {
      root,
      badge: root.querySelector('[data-product-terminal-badge="1"]'),
      panel: root.querySelector('[data-product-terminal-panel="1"]'),
      list: root.querySelector('[data-product-terminal-list="1"]'),
      pinBtn: root.querySelector('[data-product-terminal-pin="1"]'),
      collapseBtn: root.querySelector('[data-product-terminal-collapse="1"]'),
    };
  }

  function renderProductStatusTerminal() {
    if (!isStatusTerminalHostPage()) return;
    const nodes = ensureProductStatusTerminalElements();
    if (!nodes) return;
    const entries = Array.isArray(S.productStatusEntries) ? S.productStatusEntries : [];
    const pinned = S.productStatusTerminalPinned === true;
    if (entries.length === 0 && !pinned) {
      nodes.root.classList.add('d-none');
      nodes.panel?.classList.add('d-none');
      if (nodes.badge) {
        nodes.badge.textContent = '0';
        nodes.badge.classList.add('d-none');
      }
      return;
    }

    nodes.root.classList.remove('d-none');
    nodes.root.classList.toggle('is-pinned', pinned);
    if (nodes.pinBtn) {
      nodes.pinBtn.classList.toggle('is-active', pinned);
      nodes.pinBtn.setAttribute(
        'title',
        pinned
          ? langText('Terminal épinglé', 'Terminal pinned')
          : langText('Épingler le terminal', 'Pin terminal')
      );
    }
    if (S.productStatusTerminalExpanded) {
      nodes.panel?.classList.remove('d-none');
      S.productStatusTerminalUnseen = 0;
    } else {
      nodes.panel?.classList.add('d-none');
    }
    if (nodes.collapseBtn) {
      nodes.collapseBtn.innerHTML = S.productStatusTerminalExpanded
        ? '<i class="fa-solid fa-chevron-down"></i>'
        : '<i class="fa-solid fa-chevron-up"></i>';
      nodes.collapseBtn.setAttribute(
        'title',
        S.productStatusTerminalExpanded
          ? langText('Réduire', 'Collapse')
          : langText('Ouvrir', 'Expand')
      );
    }

    if (nodes.badge) {
      const unseen = S.productStatusTerminalExpanded ? 0 : Math.max(0, num(S.productStatusTerminalUnseen));
      if (unseen > 0) {
        nodes.badge.textContent = unseen > 99 ? '99+' : String(unseen);
        nodes.badge.classList.remove('d-none');
      } else {
        nodes.badge.textContent = '0';
        nodes.badge.classList.add('d-none');
      }
    }

    if (!nodes.list) return;
    const toneLabel = (tone) => {
      if (tone === 'data') return langText('Donnée', 'Data');
      if (tone === 'danger') return langText('Erreur', 'Error');
      if (tone === 'success') return langText('Succès', 'Success');
      if (tone === 'warning') return langText('Avertissement', 'Warning');
      if (tone === 'muted') return langText('Info', 'Info');
      return langText('Info', 'Info');
    };
    if (entries.length === 0) {
      nodes.list.innerHTML = `
        <div class="grocy-product-terminal-row is-muted is-empty">
          <div class="grocy-product-terminal-row-text">${escapeHtml(langText('Aucune alerte pour le moment.', 'No alerts for now.'))}</div>
        </div>
      `;
      return;
    }

    const visibleEntries = entries.slice(-140).reverse();
    nodes.list.innerHTML = visibleEntries.map((entry) => {
      const tone = productStatusTerminalTone(entry && entry.tone ? entry.tone : 'info');
      const text = clean(entry && entry.text ? entry.text : '');
      const source = clean(entry && entry.source ? entry.source : '');
      const repeat = Math.max(1, num(entry && entry.repeat));
      const time = clean(entry && entry.timeLabel ? entry.timeLabel : productStatusTerminalTime(entry && entry.ts ? entry.ts : Date.now()));
      if (!entry.id) entry.id = nextProductStatusTerminalEntryId();
      const detailLines = normalizeProductStatusTerminalDetails(entry && entry.details ? entry.details : []);
      const repeatHtml = repeat > 1 ? `<span class="grocy-product-terminal-repeat">x${repeat}</span>` : '';
      const sourceHtml = source ? `<span class="grocy-product-terminal-source">${escapeHtml(source)}</span>` : '';
      const detailsHtml = detailLines.length > 0
        ? `<div class="grocy-product-terminal-row-details">${detailLines.map((line) => `<div class="grocy-product-terminal-row-detail">${escapeHtml(line)}</div>`).join('')}</div>`
        : '';
      return `
        <div class="grocy-product-terminal-row is-${escapeHtml(tone)} ${detailLines.length > 0 ? 'is-has-details' : ''}" data-entry-id="${escapeHtml(entry.id)}">
          <div class="grocy-product-terminal-row-meta">
            <span class="grocy-product-terminal-time">${escapeHtml(time)}</span>
            <span class="grocy-product-terminal-type">${escapeHtml(toneLabel(tone))}</span>
            ${sourceHtml}
            ${repeatHtml}
          </div>
          <div class="grocy-product-terminal-row-text">${escapeHtml(text)}</div>
          ${detailsHtml}
        </div>
      `;
    }).join('');
    nodes.list.querySelectorAll('.grocy-product-terminal-row[data-entry-id]').forEach((row) => {
      const entryId = clean(row.getAttribute('data-entry-id') || '');
      if (!entryId) return;
      bindProductStatusTerminalRowSwipe(row);
    });
  }

  function initProductStatusTerminal() {
    try {
      if (!isStatusTerminalHostPage()) {
        try { delete document.body.dataset.productStatusTerminalOnly; } catch (_err) {}
        const existing = document.getElementById('grocy-product-status-terminal');
        if (existing) existing.remove();
        S.productStatusTerminalReady = false;
        S.productStatusTerminalExpanded = false;
        S.productStatusTerminalPinned = false;
        S.productStatusTerminalSettingsLoaded = false;
        S.productStatusTerminalUnseen = 0;
        S.productStatusEntrySeq = 0;
        S.productStatusEntries = [];
        return;
      }
      if (!S.productStatusTerminalSettingsLoaded) {
        loadProductStatusTerminalSettings();
      }
      restoreProductStatusTerminalFromSession();
      if (isProductFormPage()) {
        try { document.body.dataset.productStatusTerminalOnly = '1'; } catch (_err) {}
      } else {
        try { delete document.body.dataset.productStatusTerminalOnly; } catch (_err) {}
      }
      ensureProductStatusTerminalElements();
      renderProductStatusTerminal();
    } catch (error) {
      console.error('Product status terminal init failed', error);
    }
  }

  function pushProductStatusTerminal(textInput = '', toneInput = 'info', sourceInput = '', detailsInput = null) {
    try {
      if (!isStatusTerminalHostPage()) return;
      const text = clean(textInput || '');
      if (!text) return;
      ensureProductStatusTerminalElements();
      const tone = productStatusTerminalTone(toneInput);
      const source = clean(sourceInput || '');
      const details = normalizeProductStatusTerminalDetails(detailsInput);
      const detailsSig = details.join(' | ');
      const now = Date.now();
      const entries = Array.isArray(S.productStatusEntries) ? S.productStatusEntries : [];
      const last = entries.length ? entries[entries.length - 1] : null;
      const isDuplicate = !!last
        && clean(last.text || '') === text
        && productStatusTerminalTone(last.tone || '') === tone
        && clean(last.source || '') === source
        && clean(last.detailsSig || '') === detailsSig;
      if (isDuplicate) {
        last.ts = now;
        last.timeLabel = productStatusTerminalTime(now);
        last.repeat = Math.max(1, num(last.repeat)) + 1;
      } else {
        entries.push({
          text,
          tone,
          source,
          details,
          detailsSig,
          ts: now,
          timeLabel: productStatusTerminalTime(now),
          id: nextProductStatusTerminalEntryId(),
          repeat: 1,
        });
        if (entries.length > 220) entries.splice(0, entries.length - 220);
        S.productStatusEntries = entries;
        if (!S.productStatusTerminalExpanded) {
          S.productStatusTerminalUnseen = Math.min(999, Math.max(0, num(S.productStatusTerminalUnseen)) + 1);
        }
      }
      saveProductStatusTerminalSession();
      renderProductStatusTerminal();
    } catch (error) {
      console.error('Product status terminal push failed', error);
    }
  }

  function parseBarcodeCandidate(rawValue) {
    const value = clean(rawValue || '').replace(/[^\d]/g, '');
    if (!value) return '';
    return /^\d{8,18}$/.test(value) ? value : '';
  }

  function readProductBarcodeCandidateFromPage() {
    const candidates = [];
    const push = (value) => {
      const parsed = parseBarcodeCandidate(value);
      if (parsed && !candidates.includes(parsed)) candidates.push(parsed);
    };

    const barcodeInput = document.getElementById('barcode');
    if (barcodeInput) push(barcodeInput.value);

    document.querySelectorAll('[data-product-barcode]').forEach((el) => {
      push(el.getAttribute('data-product-barcode'));
    });
    document.querySelectorAll('[data-barcode]').forEach((el) => {
      push(el.getAttribute('data-barcode'));
    });
    document.querySelectorAll('#barcode-table tbody tr').forEach((row) => {
      const cell = row.querySelector('td:nth-child(2)');
      if (cell) push(cell.textContent || '');
    });

    return candidates[0] || '';
  }

  function makeImageSearchUrl(productName, extension = 'png', engineInput = '') {
    const engine = normalizePhotoSearchEngine(engineInput || photoSearchSettings().engine);
    const ext = clean(extension || '').toLowerCase() === 'jpg' ? 'jpg' : 'png';
    const query = `${productName} filetype:${ext}`;
    const encoded = encodeURIComponent(query);
    if (engine === 'duckduckgo') return `https://duckduckgo.com/?iax=images&ia=images&q=${encoded}`;
    if (engine === 'bing') return `https://www.bing.com/images/search?q=${encoded}`;
    return `https://www.google.com/search?tbm=isch&q=${encoded}`;
  }

  function barcodeLookupProviderFromSettings(settingsInput = null) {
    const settings = normalizeBarcodeLookupSettings(settingsInput || barcodeLookupSettings());
    return normalizeBarcodeLookupProvider(settings.provider);
  }

  function barcodeLookupEnabledFromSettings(settingsInput = null) {
    const settings = normalizeBarcodeLookupSettings(settingsInput || barcodeLookupSettings());
    return settings.enabled === true;
  }

  function factsProviderIconDomain(providerIdInput = '') {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    return barcodeLookupProviderSearchHost(providerId);
  }

  function makeFactsSearchByNameUrl(productName, providerIdInput = '') {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) return '';
    const query = encodeURIComponent(productName);
    return `https://${host}/cgi/search.pl?search_terms=${query}&search_simple=1&action=process`;
  }

  function makeFactsProductUrl(barcode, providerIdInput = '') {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) return '';
    return `https://${host}/product/${encodeURIComponent(barcode)}`;
  }

  function makeGoogleFactsUrl(productName, providerIdInput = '') {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) return '';
    const providerQueryToken = providerId === 'openproductsfacts' ? 'openproductsfacts' : 'openfoodfacts';
    const query = encodeURIComponent(`${productName} ${providerQueryToken}`);
    return `https://www.google.com/search?q=${query}`;
  }

  function isFactsProductTypeMismatchDetail(detailInput = '') {
    const detail = clean(detailInput || '').toLowerCase();
    if (!detail) return false;
    return detail.includes('different product type');
  }

  async function fetchFactsJson(url, timeoutMs = 16000) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: { Accept: 'application/json' },
        signal: controller.signal,
      });
      if (!response.ok) {
        let detail = '';
        try {
          const text = await response.text();
          const trimmed = clean(text);
          if (trimmed) {
            try {
              const payload = JSON.parse(text);
              detail = clean(payload?.status_verbose || payload?.error || '') || trimmed.slice(0, 220);
            } catch (_jsonErr) {
              detail = trimmed.slice(0, 220);
            }
          }
        } catch (_bodyErr) {}
        if (response.status === 404 && isFactsProductTypeMismatchDetail(detail)) {
          return {
            status: 0,
            status_verbose: detail || 'not found',
            error: detail || 'not found',
            _softNotFound: true,
          };
        }
        throw new Error(`HTTP ${response.status}${detail ? ` - ${detail}` : ''}`);
      }
      return await response.json().catch(() => ({}));
    } catch (error) {
      const name = clean(error && error.name ? error.name : '');
      if (name === 'AbortError') {
        throw new Error(langText('timeout (16s)', 'timeout (16s)'));
      }
      throw error;
    } finally {
      clearTimeout(timeout);
    }
  }

  async function lookupFactsByBarcode(barcode, providerIdInput = '') {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(providerId);
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) throw new Error(langText('Fournisseur API invalide.', 'Invalid API provider.'));
    const url = `https://${host}/api/v2/product/${encodeURIComponent(barcode)}.json?fields=code,product_name,product_name_fr,product_name_en`;
    const payload = await fetchFactsJson(url, 15000);
    return {
      provider: providerId,
      providerLabel,
      found: num(payload && payload.status) === 1,
      code: parseBarcodeCandidate(payload && payload.code ? payload.code : barcode),
      name: pickFirstString(payload && payload.product ? payload.product : payload, ['product_name_fr', 'product_name_en', 'product_name']),
    };
  }

  async function lookupFactsByName(productName, providerIdInput = '') {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(providerId);
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) throw new Error(langText('Fournisseur API invalide.', 'Invalid API provider.'));
    const url = `https://${host}/cgi/search.pl?search_terms=${encodeURIComponent(productName)}&search_simple=1&action=process&json=1&page_size=1`;
    const payload = await fetchFactsJson(url, 15000);
    const products = Array.isArray(payload && payload.products) ? payload.products : [];
    return {
      provider: providerId,
      providerLabel,
      found: products.length > 0,
      firstName: products.length ? offBarcodeCandidateName(products[0]) : '',
    };
  }

  function normalizeFactsFieldKey(value) {
    return clean(value || '').toLowerCase().replace(/[^a-z0-9]+/g, '');
  }

  function pickFirstPositiveNumberFromObject(objInput, keysInput = []) {
    const obj = objInput && typeof objInput === 'object' ? objInput : {};
    const keys = Array.isArray(keysInput) ? keysInput : [];
    for (const rawKey of keys) {
      const key = clean(rawKey || '');
      if (!key) continue;
      const direct = num(obj[key]);
      if (direct > 0) return direct;
      const altA = key.replace(/-/g, '_');
      const altB = key.replace(/_/g, '-');
      const altC = key.replace(/\./g, '_');
      const altD = key.replace(/\./g, '-');
      const candidates = [altA, altB, altC, altD];
      for (const candidate of candidates) {
        const val = num(obj[candidate]);
        if (val > 0) return val;
      }
      const expectedNorm = normalizeFactsFieldKey(key);
      if (!expectedNorm) continue;
      for (const [entryKey, entryValue] of Object.entries(obj)) {
        if (normalizeFactsFieldKey(entryKey) !== expectedNorm) continue;
        const val = num(entryValue);
        if (val > 0) return val;
      }
    }
    return 0;
  }

  function parseServingSizeToQuantity(servingSizeInput = '') {
    const servingSize = clean(servingSizeInput || '');
    if (!servingSize) return null;
    const match = servingSize.match(/(\d+(?:[.,]\d+)?)\s*(kg|g|mg|l|dl|cl|ml)\b/i);
    if (!match) return null;
    const amount = num(clean(match[1]).replace(',', '.'));
    const unit = clean(match[2] || '').toLowerCase();
    if (!(amount > 0) || !unit) return null;
    return { amount, unit };
  }

  function factsEnergyCandidatesFromProduct(productInput = {}) {
    const product = productInput && typeof productInput === 'object' ? productInput : {};
    const nutriments = product.nutriments && typeof product.nutriments === 'object' ? product.nutriments : {};
    const out = [];

    const kcal100g = pickFirstPositiveNumberFromObject(nutriments, ['energy-kcal_100g', 'energy_kcal_100g']);
    if (kcal100g > 0) {
      out.push({
        kcal: kcal100g,
        basisAmount: 100,
        basisUnit: 'g',
        basisLabel: '100 g',
        domain: 'mass',
        priority: 100,
      });
    }

    const kcal100ml = pickFirstPositiveNumberFromObject(nutriments, ['energy-kcal_100ml', 'energy_kcal_100ml']);
    if (kcal100ml > 0) {
      out.push({
        kcal: kcal100ml,
        basisAmount: 100,
        basisUnit: 'ml',
        basisLabel: '100 ml',
        domain: 'volume',
        priority: 95,
      });
    }

    const kcalServing = pickFirstPositiveNumberFromObject(nutriments, ['energy-kcal_serving', 'energy_kcal_serving']);
    if (kcalServing > 0) {
      const serving = parseServingSizeToQuantity(pickFirstString(product, ['serving_size']));
      if (serving && serving.amount > 0) {
        const info = describeQuantityUnit(serving.unit);
        if ((info.domain === 'mass' || info.domain === 'volume') && info.factor > 0) {
          out.push({
            kcal: kcalServing,
            basisAmount: serving.amount,
            basisUnit: serving.unit,
            basisLabel: `${fmt(serving.amount, serving.amount % 1 === 0 ? 0 : 2)} ${serving.unit}`,
            domain: info.domain,
            priority: 80,
          });
        }
      }
    }

    return out.sort((a, b) => num(b.priority) - num(a.priority));
  }

  async function lookupFactsEnergyByBarcode(barcodeInput = '', providerIdInput = '') {
    const barcode = parseBarcodeCandidate(barcodeInput || '');
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(providerId);
    if (!barcode) {
      throw new Error(langText('Code-barres introuvable.', 'Barcode not found.'));
    }
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) {
      throw new Error(langText('Fournisseur API invalide.', 'Invalid API provider.'));
    }
    const url = `https://${host}/api/v2/product/${encodeURIComponent(barcode)}.json?fields=code,product_name,product_name_fr,product_name_en,nutriments,serving_size`;
    const payload = await fetchFactsJson(url, 17000);
    if (num(payload && payload.status) !== 1) {
      const verbose = clean(payload && payload.status_verbose ? payload.status_verbose : '');
      throw new Error(verbose || langText('Produit introuvable.', 'Product not found.'));
    }
    const product = payload && payload.product && typeof payload.product === 'object' ? payload.product : {};
    const candidates = factsEnergyCandidatesFromProduct(product);
    if (!candidates.length) {
      throw new Error(langText('Aucune donnée kcal exploitable.', 'No usable kcal data.'));
    }
    const best = candidates[0];
    return {
      provider: providerId,
      providerLabel,
      productName: offBarcodeCandidateName(product),
      ...best,
    };
  }

  async function loadQuantityConversionContextForProduct(productIdInput = 0) {
    const productId = num(productIdInput);
    const unitMap = await loadQuantityUnitMapFromApi();
    S.apiQuantityUnitById = unitMap;
    S.apiQuantityUnitIdsByNorm = indexQuantityUnitNames(unitMap);
    const conversionData = await loadQuantityConversionsFromApi(productId > 0 ? [productId] : [], unitMap);
    S.apiQuantityConversionsByProductId = conversionData.byProduct;
    S.apiQuantityConversionsGlobalByUnitId = conversionData.globalByUnit;
    return conversionData;
  }

  function caloriesInputDecimals(inputNode) {
    if (!inputNode) return 2;
    const stepRaw = clean(inputNode.getAttribute('step') || '');
    if (!stepRaw) return 2;
    if (!stepRaw.includes('.')) return 0;
    const decimals = stepRaw.split('.')[1].length;
    return Math.min(4, Math.max(0, decimals));
  }

  function normalizeFactsImageUrl(rawUrl, providerIdInput = '') {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const host = barcodeLookupProviderSearchHost(providerId);
    const value = clean(rawUrl || '');
    if (!value) return '';
    if (/^https?:\/\//i.test(value)) return value;
    if (value.startsWith('//')) return `https:${value}`;
    if (value.startsWith('/') && host) return `https://${host}${value}`;
    return '';
  }

  function extractFactsImageUrl(productInput, providerIdInput = '') {
    const product = productInput && typeof productInput === 'object' ? productInput : {};
    const selectedFront = product?.selected_images?.front || {};
    const display = selectedFront?.display || {};
    const thumb = selectedFront?.thumb || {};
    const small = selectedFront?.small || {};
    const candidates = [
      pickFirstString(product, ['image_front_url', 'image_url', 'image_front_small_url']),
      pickFirstString(display, ['fr', 'en', 'main']),
      pickFirstString(thumb, ['fr', 'en', 'main']),
      pickFirstString(small, ['fr', 'en', 'main']),
    ];
    for (const candidate of candidates) {
      const normalized = normalizeFactsImageUrl(candidate, providerIdInput);
      if (normalized) return normalized;
    }
    return '';
  }

  function bestFactsPhotoProductByName(productsInput, productNameInput = '') {
    const products = Array.isArray(productsInput) ? productsInput : [];
    const productName = clean(productNameInput || '');
    if (products.length === 0) return null;
    let best = null;
    let bestScore = -Infinity;
    for (const product of products) {
      if (!product || typeof product !== 'object') continue;
      const score = offBarcodeCandidateScore(product, productName) + (extractFactsImageUrl(product) ? 8 : 0);
      if (score > bestScore) {
        bestScore = score;
        best = product;
      }
    }
    return best || products[0] || null;
  }

  async function lookupFactsPhotoByBarcode(barcodeInput, providerIdInput = '') {
    const barcode = parseBarcodeCandidate(barcodeInput || '');
    if (!barcode) return { found: false, imageUrl: '', provider: normalizeBarcodeLookupProvider(providerIdInput), providerLabel: '' };
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(providerId);
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) throw new Error(langText('Fournisseur API invalide.', 'Invalid API provider.'));
    const url = `https://${host}/api/v2/product/${encodeURIComponent(barcode)}.json?fields=code,product_name,product_name_fr,product_name_en,image_front_url,image_front_small_url,image_url,selected_images`;
    const payload = await fetchFactsJson(url, 16000);
    const product = payload && payload.product && typeof payload.product === 'object' ? payload.product : {};
    const imageUrl = extractFactsImageUrl(product, providerId);
    const resolvedCode = parseBarcodeCandidate(pickFirstString(payload, ['code']) || pickFirstString(product, ['code']) || barcode);
    return {
      provider: providerId,
      providerLabel,
      found: num(payload && payload.status) === 1 && !!imageUrl,
      code: resolvedCode || barcode,
      name: offBarcodeCandidateName(product),
      imageUrl,
      via: 'barcode',
    };
  }

  async function lookupFactsPhotoByName(productNameInput, providerIdInput = '') {
    const productName = clean(productNameInput || '');
    if (!productName) return { found: false, imageUrl: '', provider: normalizeBarcodeLookupProvider(providerIdInput), providerLabel: '' };
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(providerId);
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) throw new Error(langText('Fournisseur API invalide.', 'Invalid API provider.'));
    const url = `https://${host}/cgi/search.pl?search_terms=${encodeURIComponent(productName)}&search_simple=1&action=process&json=1&page_size=24&fields=code,product_name,product_name_fr,product_name_en,image_front_url,image_front_small_url,image_url,selected_images`;
    const payload = await fetchFactsJson(url, 16000);
    const products = Array.isArray(payload && payload.products) ? payload.products : [];
    const best = bestFactsPhotoProductByName(products, productName);
    const imageUrl = best ? extractFactsImageUrl(best, providerId) : '';
    return {
      provider: providerId,
      providerLabel,
      found: !!imageUrl,
      code: parseBarcodeCandidate(best ? pickFirstString(best, ['code']) : ''),
      name: best ? offBarcodeCandidateName(best) : '',
      imageUrl,
      via: 'name',
    };
  }

  async function lookupFactsPhotoByNameFallbackChain(productNameInput, providerIdInput = '', optionsInput = {}) {
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(providerId);
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const variants = buildProductNameFallbackVariants(productNameInput, options.limit || 12);
    if (!variants.length) {
      return { found: false, imageUrl: '', provider: providerId, providerLabel, via: 'name' };
    }

    const failures = [];
    for (let i = 0; i < variants.length; i += 1) {
      const variant = variants[i];
      try {
        const byName = await lookupFactsPhotoByName(variant, providerId);
        if (byName && byName.found && clean(byName.imageUrl)) {
          return { ...byName, usedName: variant, triedNames: variants.slice(0, i + 1) };
        }
      } catch (error) {
        const msg = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
        if (!isLookupNotFoundMessage(msg) && !isFactsProductTypeMismatchDetail(msg)) {
          failures.push(msg);
        }
      }
    }

    if (failures.length > 0) {
      throw new Error(failures[0]);
    }
    return { found: false, imageUrl: '', provider: providerId, providerLabel, via: 'name', triedNames: variants };
  }

  function xhrErrorMessage(xhrInput) {
    const xhr = xhrInput && typeof xhrInput === 'object' ? xhrInput : {};
    const primary = clean(xhr?.responseJSON?.error_message || xhr?.responseJSON?.error || xhr?.responseJSON?.message || '');
    if (primary) return primary;
    const text = clean(xhr?.responseText || '');
    if (text) {
      try {
        const parsed = JSON.parse(text);
        const message = clean(parsed?.error_message || parsed?.error || parsed?.message || '');
        if (message) return message;
      } catch (_err) {}
      return text.slice(0, 220);
    }
    const statusText = clean(xhr?.statusText || '');
    if (statusText) return statusText;
    const status = num(xhr?.status);
    if (status > 0) return `HTTP ${status}`;
    return t('focus_unknown_error');
  }

  function grocyApiPutPromise(pathInput, payloadInput = {}) {
    return new Promise((resolve, reject) => {
      if (!window.Grocy || !window.Grocy.Api || typeof window.Grocy.Api.Put !== 'function') {
        reject(new Error(langText('API Grocy indisponible.', 'Grocy API unavailable.')));
        return;
      }
      window.Grocy.Api.Put(pathInput, payloadInput,
        (result) => resolve(result),
        (xhr) => reject(new Error(xhrErrorMessage(xhr)))
      );
    });
  }

  function grocyApiUploadFilePromise(fileInput, groupInput, fileNameInput) {
    return new Promise((resolve, reject) => {
      if (!window.Grocy || !window.Grocy.Api || typeof window.Grocy.Api.UploadFile !== 'function') {
        reject(new Error(langText('Upload Grocy indisponible.', 'Grocy upload API unavailable.')));
        return;
      }
      window.Grocy.Api.UploadFile(fileInput, groupInput, fileNameInput,
        (result) => resolve(result),
        (xhr) => reject(new Error(xhrErrorMessage(xhr)))
      );
    });
  }

  function sanitizeFileNamePart(rawInput, fallback = 'image') {
    const raw = clean(rawInput || '');
    const sanitized = norm(raw).replace(/[^a-z0-9._-]+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
    return sanitized || fallback;
  }

  function utf8ToBase64(rawInput) {
    const raw = clean(rawInput || '');
    if (!raw) return '';
    try {
      return window.btoa(unescape(encodeURIComponent(raw)));
    } catch (_err) {
      try {
        return window.btoa(raw);
      } catch (_err2) {
        return '';
      }
    }
  }

  function imageExtensionFromBlob(blobInput, fallbackUrlInput = '') {
    const blob = blobInput && typeof blobInput === 'object' ? blobInput : {};
    const mime = clean(blob.type || '').toLowerCase();
    if (mime.includes('png')) return 'png';
    if (mime.includes('webp')) return 'webp';
    if (mime.includes('gif')) return 'gif';
    if (mime.includes('bmp')) return 'bmp';
    if (mime.includes('svg')) return 'svg';
    if (mime.includes('jpeg') || mime.includes('jpg')) return 'jpg';
    const fallbackUrl = clean(fallbackUrlInput || '');
    const match = fallbackUrl.match(/\.([a-zA-Z0-9]{3,4})(?:[\?#]|$)/);
    if (match) {
      const ext = clean(match[1] || '').toLowerCase();
      if (['png', 'jpg', 'jpeg', 'webp', 'gif', 'bmp', 'svg'].includes(ext)) return ext === 'jpeg' ? 'jpg' : ext;
    }
    return 'jpg';
  }

  function assignFileToProductPictureInput(fileInput) {
    const file = fileInput instanceof File ? fileInput : null;
    const pictureInput = document.getElementById('product-picture');
    if (!pictureInput || !file) return;
    try {
      const dt = new DataTransfer();
      dt.items.add(file);
      pictureInput.files = dt.files;
    } catch (_err) {}
    pictureInput.dispatchEvent(new Event('change', { bubbles: true }));
  }

  function refreshProductPicturePreview(fileNameInput = '') {
    const fileName = clean(fileNameInput || '');
    if (!fileName) return;
    const encoded = utf8ToBase64(fileName);
    if (!encoded) return;
    const imgSrc = `${U('/api/files/productpictures/')}${encoded}?force_serve_as=picture&best_fit_width=400&_=${Date.now()}`;

    let currentPicture = document.getElementById('current-product-picture');
    const noPictureHint = document.getElementById('no-current-product-picture-hint');
    if (!currentPicture) {
      currentPicture = document.createElement('img');
      currentPicture.id = 'current-product-picture';
      currentPicture.className = 'img-fluid img-thumbnail mt-2 mb-5';
      currentPicture.loading = 'lazy';
      if (noPictureHint && noPictureHint.parentNode) {
        noPictureHint.parentNode.insertBefore(currentPicture, noPictureHint);
      } else {
        const pictureInput = document.getElementById('product-picture');
        const mount = pictureInput && pictureInput.closest('.col') ? pictureInput.closest('.col') : null;
        if (mount) mount.appendChild(currentPicture);
      }
    }
    currentPicture.src = imgSrc;
    currentPicture.classList.remove('d-none');

    const label = document.getElementById('product-picture-label');
    const labelNone = document.getElementById('product-picture-label-none');
    if (label) {
      label.textContent = fileName;
      label.classList.remove('d-none');
    }
    if (labelNone) labelNone.classList.add('d-none');

    const deleteHint = document.getElementById('delete-current-product-picture-on-save-hint');
    if (deleteHint) deleteHint.classList.add('d-none');
    if (noPictureHint) noPictureHint.classList.add('d-none');
    if (window.Grocy) {
      window.Grocy.ProductPictureFileName = fileName;
      window.Grocy.DeleteProductPictureOnSave = false;
    }
  }

  function setCurrentProductPictureTemporaryHidden(hiddenInput = false) {
    const hidden = hiddenInput === true;
    const currentPicture = document.getElementById('current-product-picture');
    if (!currentPicture || !currentPicture.classList) return;
    currentPicture.classList.toggle('grocy-current-picture-temp-hidden', hidden);
  }

  function buildCurrentProductPutPayload() {
    try {
      if (!window.jQuery || typeof window.jQuery !== 'function') return null;
      const form = window.jQuery('#product-form');
      if (!form || form.length === 0 || typeof form.serializeJSON !== 'function') return null;
      const jsonData = form.serializeJSON();
      if (jsonData && Object.prototype.hasOwnProperty.call(jsonData, 'product_id')) {
        const parentProductId = jsonData.product_id;
        delete jsonData.product_id;
        jsonData.parent_product_id = parentProductId;
      }
      return jsonData;
    } catch (_err) {
      return null;
    }
  }

  async function saveFactsPhotoBlobToProduct(blobInput, candidateInput = {}, productNameInput = '', optionsInput = {}) {
    const blob = blobInput instanceof Blob ? blobInput : null;
    if (!blob || blob.size <= 0) throw new Error(langText('Photo vide.', 'Empty image payload.'));
    const productId = currentEditedProductId();
    if (productId <= 0) throw new Error(t('photo_search_error_need_saved_product'));
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const shouldRefreshPreview = options.refreshPreview !== false;
    const shouldAssignInput = options.assignFileInput !== false;

    const candidate = candidateInput && typeof candidateInput === 'object' ? candidateInput : {};
    const providerId = normalizeBarcodeLookupProvider(candidate.provider || barcodeLookupProviderFromSettings());
    const sourceName = sanitizeFileNamePart(candidate.name || productNameInput || 'product-photo', 'product-photo');
    const ext = imageExtensionFromBlob(blob, clean(candidate.imageUrl || ''));
    const randomPrefix = typeof window.RandomString === 'function'
      ? String(window.RandomString())
      : `${Date.now()}_`;
    const rawFileName = `${randomPrefix}${sourceName}.${ext}`;
    const finalFileName = typeof window.CleanFileName === 'function'
      ? String(window.CleanFileName(rawFileName))
      : rawFileName.replace(/[^a-zA-Z0-9._-]+/g, '_');
    const mime = clean(blob.type || '');
    const file = new File([blob], finalFileName, { type: mime || 'image/jpeg' });

    if (shouldAssignInput) {
      assignFileToProductPictureInput(file);
    }
    await grocyApiUploadFilePromise(file, 'productpictures', finalFileName);

    const payloadCandidates = [
      { picture_file_name: finalFileName },
      (() => {
        const full = buildCurrentProductPutPayload();
        if (!full || typeof full !== 'object') return null;
        full.picture_file_name = finalFileName;
        return full;
      })(),
    ].filter(Boolean);

    let lastError = null;
    for (const payload of payloadCandidates) {
      try {
        await grocyApiPutPromise(`objects/products/${productId}`, payload);
        if (shouldRefreshPreview) {
          refreshProductPicturePreview(finalFileName);
        }
        return {
          provider: providerId,
          providerLabel: barcodeLookupProviderLabel(providerId),
          productId,
          fileName: finalFileName,
        };
      } catch (error) {
        lastError = error;
      }
    }
    throw lastError || new Error(t('focus_unknown_error'));
  }

  function applyFactsIconToButton(button, providerIdInput = '', fallbackText = 'OFF') {
    if (!button) return;
    const providerId = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(providerId);
    const host = factsProviderIconDomain(providerId);
    const iconUrl = duckDuckGoIconUrl(host);
    if (!iconUrl) {
      button.textContent = fallbackText;
      return;
    }
    button.innerHTML = `<img class="grocy-off-ddg-icon" src="${iconUrl}" alt="${escapeHtml(providerLabel)}">`;
    const img = button.querySelector('img');
    if (img) {
      img.addEventListener('error', () => {
        button.textContent = fallbackText;
      });
    }
  }

  function initProductImageSearchButton() {
    if (!isProductFormPage()) {
      if (S.productImageSearchBarcodeObserver) {
        try { S.productImageSearchBarcodeObserver.disconnect(); } catch (_err) {}
        S.productImageSearchBarcodeObserver = null;
      }
      if (S.productImageSearchFocusHandler) {
        window.removeEventListener('focus', S.productImageSearchFocusHandler);
        S.productImageSearchFocusHandler = null;
      }
      S.productImageSearchRefresh = null;
      return;
    }

    const nameInput = document.getElementById('name');
    const pictureInput = document.getElementById('product-picture');
    if (!nameInput || !pictureInput) {
      if (S.productImageSearchBarcodeObserver) {
        try { S.productImageSearchBarcodeObserver.disconnect(); } catch (_err) {}
        S.productImageSearchBarcodeObserver = null;
      }
      if (S.productImageSearchFocusHandler) {
        window.removeEventListener('focus', S.productImageSearchFocusHandler);
        S.productImageSearchFocusHandler = null;
      }
      S.productImageSearchRefresh = null;
      return;
    }

    initOpenFoodFactsToolsStyle();

    const mountNode = pictureInput.closest('.form-group') || pictureInput.parentNode;
    if (!mountNode || !mountNode.parentNode) {
      S.productImageSearchRefresh = null;
      return;
    }

    let wrapper = document.getElementById('product-picture-search-tools-wrap');
    if (!wrapper) {
      wrapper = document.createElement('div');
      wrapper.id = 'product-picture-search-tools-wrap';
      wrapper.className = 'mt-2';
      mountNode.insertAdjacentElement('afterend', wrapper);
    }

    let controls = document.getElementById('product-picture-search-tools');
    if (!controls) {
      controls = document.createElement('div');
      controls.id = 'product-picture-search-tools';
      controls.className = 'grocy-photo-search-tools';
      wrapper.appendChild(controls);
    }

    let status = document.getElementById('product-picture-search-tools-status');
    if (!status) {
      status = document.createElement('div');
      status.id = 'product-picture-search-tools-status';
      status.className = 'form-text small mt-1 grocy-photo-status-box';
      status.innerHTML = `
        <div class="grocy-photo-status-line text-info d-none" data-photo-status="info"></div>
        <div class="grocy-photo-status-line text-success d-none" data-photo-status="success"></div>
        <div class="grocy-photo-status-line text-danger d-none" data-photo-status="error"></div>
      `;
      wrapper.appendChild(status);
    }
    const statusInfo = status.querySelector('[data-photo-status="info"]');
    const statusSuccess = status.querySelector('[data-photo-status="success"]');
    const statusError = status.querySelector('[data-photo-status="error"]');

    const pngBtn = document.createElement('button');
    pngBtn.type = 'button';
    pngBtn.id = 'product-picture-search-png';
    pngBtn.className = 'btn btn-outline-primary btn-sm';
    pngBtn.innerHTML = `<i class="fa-solid fa-image mr-1"></i>${langText('Rechercher une image PNG', 'Search PNG image')}`;

    const jpgBtn = document.createElement('button');
    jpgBtn.type = 'button';
    jpgBtn.id = 'product-picture-search-jpg';
    jpgBtn.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm';
    jpgBtn.textContent = t('photo_search_btn_jpg');

    const offBtn = document.createElement('button');
    offBtn.type = 'button';
    offBtn.id = 'product-picture-search-off';
    offBtn.className = 'btn btn-outline-info btn-sm grocy-off-btn-sm';

    const offRetryBtn = document.createElement('button');
    offRetryBtn.type = 'button';
    offRetryBtn.id = 'product-picture-search-off-retry';
    offRetryBtn.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm grocy-off-btn-icon d-none';
    offRetryBtn.innerHTML = '<i class="fa-solid fa-rotate-right"></i>';
    offRetryBtn.title = langText('Relancer avec simplification du nom', 'Retry with simplified name');
    offRetryBtn.setAttribute('aria-label', offRetryBtn.title);

    const refreshPreviewBtn = document.createElement('button');
    refreshPreviewBtn.type = 'button';
    refreshPreviewBtn.id = 'product-picture-search-refresh-preview';
    refreshPreviewBtn.className = 'btn btn-outline-success btn-sm grocy-off-btn-sm grocy-off-btn-icon d-none';
    refreshPreviewBtn.innerHTML = '<i class="fa-solid fa-rotate"></i>';
    refreshPreviewBtn.title = t('photo_search_btn_refresh_preview_title');
    refreshPreviewBtn.setAttribute('aria-label', refreshPreviewBtn.title);

    let factsResults = document.getElementById('product-picture-search-facts-results');
    if (!factsResults) {
      factsResults = document.createElement('div');
      factsResults.id = 'product-picture-search-facts-results';
      factsResults.className = 'grocy-facts-photo-results d-none';
      wrapper.appendChild(factsResults);
    }

    let factsPhotoCandidates = [];
    let canRetryFactsByName = false;
    let pendingPreviewFileName = '';

    controls.innerHTML = '';
    controls.appendChild(pngBtn);
    controls.appendChild(jpgBtn);
    controls.appendChild(offBtn);
    controls.appendChild(offRetryBtn);
    controls.appendChild(refreshPreviewBtn);

    const setFactsButtonLabel = (barcodeSettingsInput) => {
      const barcodeSettings = normalizeBarcodeLookupSettings(barcodeSettingsInput || barcodeLookupSettings());
      const activeProviders = (barcodeSettings.enabled === true ? BARCODE_LOOKUP_PROVIDER_IDS : barcodeLookupProviderOrder(barcodeSettings))
        .map((providerId) => normalizeBarcodeLookupProvider(providerId))
        .filter((providerId, index, arr) => providerId && arr.indexOf(providerId) === index);
      const hasCombined = barcodeSettings.enabled === true;
      if (hasCombined) {
        offBtn.innerHTML = `<i class="fa-solid fa-database mr-1"></i>${escapeHtml(t('photo_search_btn_facts_combined'))}`;
        return;
      }
      const providerId = activeProviders[0] || barcodeLookupProviderFromSettings(barcodeSettings);
      const host = factsProviderIconDomain(providerId);
      const icon = duckDuckGoIconUrl(host);
      const textKey = providerId === 'openproductsfacts'
        ? 'photo_search_btn_facts_openproductsfacts'
        : 'photo_search_btn_facts_openfoodfacts';
      const label = t(textKey);
      offBtn.innerHTML = icon
        ? `<img class="grocy-off-ddg-icon mr-1" src="${icon}" alt="${escapeHtml(barcodeLookupProviderLabel(providerId))}"><span>${escapeHtml(label)}</span>`
        : `<i class="fa-solid fa-database mr-1"></i>${escapeHtml(label)}`;
      const iconNode = offBtn.querySelector('img');
      if (iconNode) {
        iconNode.addEventListener('error', () => {
          const fallback = t(textKey);
          offBtn.innerHTML = `<i class="fa-solid fa-database mr-1"></i>${escapeHtml(fallback)}`;
        });
      }
    };

    const renderFactsPhotoCards = (candidatesInput = [], optionsInput = {}) => {
      const candidates = Array.isArray(candidatesInput) ? candidatesInput : [];
      const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
      const currentPicture = document.getElementById('current-product-picture');
      const currentPictureUrl = clean(currentPicture && (currentPicture.getAttribute('src') || currentPicture.src) ? (currentPicture.getAttribute('src') || currentPicture.src) : '');
      const currentPictureLabel = clean(((document.getElementById('product-picture-label') || {}).textContent) || '');
      const includeCurrentImage = options.includeCurrentImage === true || candidates.length > 0;
      const currentCandidate = (includeCurrentImage && currentPictureUrl)
        ? {
          __isCurrentImage: true,
          provider: 'grocy-current',
          providerLabel: t('photo_search_card_source_current'),
          name: currentPictureLabel || t('photo_search_card_keep_current'),
          imageUrl: currentPictureUrl,
        }
        : null;
      factsPhotoCandidates = (currentCandidate ? [currentCandidate] : []).concat(candidates);
      if (factsPhotoCandidates.length === 0) {
        factsResults.innerHTML = '';
        factsResults.classList.add('d-none');
        setCurrentProductPictureTemporaryHidden(false);
        return;
      }
      factsResults.innerHTML = factsPhotoCandidates.map((candidate, index) => {
        const isCurrentImage = !!(candidate && candidate.__isCurrentImage === true);
        const isLoading = !!(candidate && candidate.__isLoading === true);
        const isUnavailable = !!(candidate && candidate.__isUnavailable === true);
        const providerLabel = clean(candidate && candidate.providerLabel ? candidate.providerLabel : t('default_na'));
        const displayName = clean(candidate && candidate.name ? candidate.name : '');
        const imageUrl = clean(candidate && candidate.imageUrl ? candidate.imageUrl : '');
        const isSelectable = !!imageUrl || isCurrentImage;
        const label = displayName || (isCurrentImage ? t('photo_search_card_keep_current') : providerLabel);
        const head = isCurrentImage
          ? t('photo_search_card_source_current')
          : t('photo_search_card_source', { provider: providerLabel || t('default_na') });
        const overlay = isCurrentImage ? t('photo_search_card_keep_current') : t('photo_search_card_choose');
        const cardClassList = ['grocy-facts-photo-card'];
        if (isCurrentImage) cardClassList.push('is-current-image');
        if (isLoading) cardClassList.push('is-loading');
        if (isUnavailable) cardClassList.push('is-unavailable');
        if (!isSelectable) cardClassList.push('is-disabled');
        const loadingText = escapeHtml(langText('En chargement...', 'Loading...'));
        const thumbInner = imageUrl
          ? `
            <div class="grocy-facts-photo-loader grocy-facts-photo-loader-inline" role="status" aria-live="polite">
              <span class="grocy-facts-photo-spinner" aria-hidden="true"></span>
              <span class="grocy-facts-photo-loader-text">${loadingText}</span>
            </div>
            <img class="grocy-facts-photo-thumb" src="${escapeHtml(imageUrl)}" alt="${escapeHtml(label)}" loading="lazy" referrerpolicy="no-referrer">
          `
          : (isLoading
            ? `
              <div class="grocy-facts-photo-loader" role="status" aria-live="polite">
                <span class="grocy-facts-photo-spinner" aria-hidden="true"></span>
                <span class="grocy-facts-photo-loader-text">${loadingText}</span>
              </div>
            `
            : `
              <div class="grocy-facts-photo-empty">
                <i class="fa-solid fa-image"></i>
                <span>${escapeHtml(displayName || langText('Aucune image trouvée', 'No image found'))}</span>
              </div>
            `);
        const overlayHtml = imageUrl
          ? `<span class="grocy-facts-photo-overlay">${escapeHtml(overlay)}</span>`
          : '';
        const disabledAttr = isSelectable ? '' : ' disabled aria-disabled="true"';
        return `
          <button type="button" class="${cardClassList.join(' ')}" data-facts-photo-index="${index}" title="${escapeHtml(t('photo_search_card_choose_title'))}"${disabledAttr}>
            <div class="grocy-facts-photo-head">${escapeHtml(head)}</div>
            <div class="grocy-facts-photo-thumb-wrap${isLoading ? ' is-loading' : ''}${isUnavailable ? ' is-empty' : ''}${imageUrl ? ' is-image-loading' : ''}">
              ${thumbInner}
              ${overlayHtml}
            </div>
            <div class="grocy-facts-photo-name">${escapeHtml(label)}</div>
          </button>
        `;
      }).join('');
      factsResults.classList.remove('d-none');
      setCurrentProductPictureTemporaryHidden(true);
      factsResults.querySelectorAll('.grocy-facts-photo-thumb-wrap.is-image-loading img').forEach((imgNode) => {
        const thumbWrap = imgNode && imgNode.closest ? imgNode.closest('.grocy-facts-photo-thumb-wrap') : null;
        if (!thumbWrap) return;
        const markLoaded = () => {
          thumbWrap.classList.remove('is-image-loading');
          thumbWrap.classList.add('is-image-loaded');
        };
        const markFailed = () => {
          thumbWrap.classList.remove('is-image-loading');
          thumbWrap.classList.remove('is-image-loaded');
          thumbWrap.classList.add('is-empty');
          imgNode.classList.add('d-none');
          const loaderTextNode = thumbWrap.querySelector('.grocy-facts-photo-loader-inline .grocy-facts-photo-loader-text');
          if (loaderTextNode) loaderTextNode.textContent = langText('Image indisponible', 'Image unavailable');
        };
        if (imgNode.complete) {
          if (num(imgNode.naturalWidth) > 0) {
            markLoaded();
          } else {
            markFailed();
          }
          return;
        }
        imgNode.addEventListener('load', markLoaded, { once: true });
        imgNode.addEventListener('error', markFailed, { once: true });
      });
    };

    const renderState = () => {
      const parentMode = isProductParentModeEnabled();
      const productName = clean(nameInput.value);
      const hasName = productName !== '';
      const progress = photoSearchProgress();
      const settings = photoSearchSettings();
      const barcodeSettings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
      const activeProviders = barcodeLookupProviderOrder(barcodeSettings)
        .map((providerId) => normalizeBarcodeLookupProvider(providerId))
        .filter((providerId, index, arr) => providerId && arr.indexOf(providerId) === index);
      const providersLabel = activeProviders.map((providerId) => barcodeLookupProviderLabel(providerId)).join(' + ');
      const barcode = readProductBarcodeCandidateFromPage();
      const canFallbackByName = settings.offNameFallback === true && hasName;
      const canQueryFacts = barcodeSettings.enabled === true && (!!barcode || canFallbackByName);

      const engineLabel = photoSearchEngineLabel(settings.engine);
      pngBtn.disabled = !hasName;
      pngBtn.title = `${engineLabel} | ${langText('Recherche image PNG', 'PNG image search')}`;

      jpgBtn.classList.toggle('d-none', progress.pngClicked !== true);
      jpgBtn.disabled = !hasName;
      jpgBtn.title = `${engineLabel} | ${langText('Recherche image JPG', 'JPG image search')}`;

      offBtn.classList.toggle('d-none', parentMode || progress.jpgClicked !== true);
      offRetryBtn.classList.toggle('d-none', parentMode || !(progress.jpgClicked === true && canRetryFactsByName));
      setFactsButtonLabel(barcodeSettings);
      const offTitle = t('photo_search_btn_off_title', { provider: providersLabel || t('default_na') });
      offBtn.disabled = parentMode || !canQueryFacts;
      offBtn.title = parentMode
        ? langText('Mode parent actif: recherche OFF/OPF masquée.', 'Parent mode active: OFF/OPF search hidden.')
        : barcodeSettings.enabled !== true
        ? t('facts_provider_disabled')
        : (offBtn.disabled
          ? `${offTitle} - ${t('photo_search_status_need_barcode_or_name')}`
          : offTitle);
      offBtn.setAttribute('aria-label', offBtn.title);
      offRetryBtn.disabled = offBtn.disabled;
      refreshPreviewBtn.classList.toggle('d-none', !pendingPreviewFileName);
      refreshPreviewBtn.disabled = !pendingPreviewFileName;
      refreshPreviewBtn.title = t('photo_search_btn_refresh_preview_title');
      refreshPreviewBtn.setAttribute('aria-label', refreshPreviewBtn.title);
    };

    const setStatusLines = ({ info = '', success = '', error = '' } = {}) => {
      const setLine = (node, text) => {
        if (!node) return;
        const value = clean(text || '');
        node.textContent = value;
        node.classList.toggle('d-none', !value);
      };
      setLine(statusInfo, info);
      setLine(statusSuccess, success);
      setLine(statusError, error);
    };

    const setStatus = (text, tone = 'muted') => {
      const value = clean(text || '');
      setStatusLines({});
      if (!value) return;
      pushProductStatusTerminal(value, tone, langText('Photo', 'Photo'));
    };

    const onPngClick = () => {
      const productName = clean(nameInput.value);
      if (!productName) {
        setStatus(t('photo_search_status_need_name'), 'danger');
        renderState();
        return;
      }
      const current = photoSearchProgress();
      savePhotoSearchProgress({ ...current, pngClicked: true });
      openNewTab(makeImageSearchUrl(productName, 'png'));
      setStatus('', 'muted');
    };

    const onJpgClick = () => {
      const productName = clean(nameInput.value);
      if (!productName) {
        setStatus(t('photo_search_status_need_name'), 'danger');
        renderState();
        return;
      }
      const current = photoSearchProgress();
      savePhotoSearchProgress({ ...current, jpgClicked: true });
      openNewTab(makeImageSearchUrl(productName, 'jpg'));
      setStatus('', 'muted');
    };

    const onOffClick = async (useFallbackChain = false) => {
      if (isProductParentModeEnabled()) {
        setStatus(langText('Mode parent actif: recherche OFF/OPF indisponible.', 'Parent mode active: OFF/OPF lookup unavailable.'), 'warning');
        renderState();
        return;
      }
      const barcode = readProductBarcodeCandidateFromPage();
      const productName = clean(nameInput.value);
      const barcodeSettings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
      const configuredProviderOrder = barcodeLookupProviderOrder(barcodeSettings)
        .map((providerId) => normalizeBarcodeLookupProvider(providerId))
        .filter((providerId, index, arr) => providerId && arr.indexOf(providerId) === index);
      const providerOrder = configuredProviderOrder
        .concat(BARCODE_LOOKUP_PROVIDER_IDS)
        .map((providerId) => normalizeBarcodeLookupProvider(providerId))
        .filter((providerId, index, arr) => providerId && arr.indexOf(providerId) === index);
      const providerLabels = providerOrder.map((providerId) => barcodeLookupProviderLabel(providerId));
      const providerChain = providerLabels.join(' + ');
      const allowNameFallback = photoSearchSettings().offNameFallback === true;

      if (barcodeSettings.enabled !== true) {
        setStatus(t('facts_provider_disabled'), 'warning');
        renderState();
        return;
      }
      if (!barcode && !(allowNameFallback && productName)) {
        setStatus(t('photo_search_status_need_barcode_or_name'), 'danger');
        renderState();
        return;
      }

      canRetryFactsByName = false;
      pendingPreviewFileName = '';
      const providerState = new Map();
      providerOrder.forEach((providerId) => {
        providerState.set(providerId, {
          providerId,
          providerLabel: barcodeLookupProviderLabel(providerId),
          loading: true,
          candidate: null,
          error: '',
        });
      });
      const buildVisualCandidates = () => providerOrder.map((providerId) => {
        const state = providerState.get(providerId) || {};
        const providerLabel = clean(state.providerLabel || barcodeLookupProviderLabel(providerId));
        if (state.loading === true) {
          return {
            provider: providerId,
            providerLabel,
            name: langText('En chargement...', 'Loading...'),
            __isLoading: true,
          };
        }
        if (state.candidate && clean(state.candidate.imageUrl)) {
          return state.candidate;
        }
        return {
          provider: providerId,
          providerLabel,
          name: langText('Aucune image trouvée', 'No image found'),
          __isUnavailable: true,
        };
      });
      renderFactsPhotoCards(buildVisualCandidates(), { includeCurrentImage: true });
      setButtonBusy(offBtn, true);
      if (useFallbackChain) setButtonBusy(offRetryBtn, true);
      try {
        const runningText = useFallbackChain
          ? langText(
            `Recherche avancée (${providerChain || t('default_na')}) avec simplification du nom…`,
            `Advanced lookup (${providerChain || t('default_na')}) with progressive name simplification...`
          )
          : t('photo_search_status_running_images', { providers: providerChain || t('default_na') });
        setStatus(runningText, 'info');
        const runLookupForProvider = async (providerId) => {
          const providerLabel = barcodeLookupProviderLabel(providerId);
          let candidate = null;
          let errorText = '';
          try {
            if (barcode) {
              const byBarcode = await lookupFactsPhotoByBarcode(barcode, providerId);
              if (byBarcode && byBarcode.found && clean(byBarcode.imageUrl)) {
                candidate = byBarcode;
              }
            }
          } catch (error) {
            const msg = clean(error && error.message ? error.message : String(error));
            if (!isFactsProductTypeMismatchDetail(msg)) {
              errorText = `${providerLabel}: ${msg || t('focus_unknown_error')}`;
            }
          }
          if (!candidate && allowNameFallback && productName) {
            try {
              const byName = useFallbackChain
                ? await lookupFactsPhotoByNameFallbackChain(productName, providerId, { limit: 12 })
                : await lookupFactsPhotoByName(productName, providerId);
              if (byName && byName.found && clean(byName.imageUrl)) {
                candidate = byName;
              }
            } catch (error) {
              const msg = clean(error && error.message ? error.message : String(error));
              if (!errorText && !isFactsProductTypeMismatchDetail(msg)) {
                errorText = `${providerLabel}: ${msg || t('focus_unknown_error')}`;
              }
            }
          }
          return {
            providerId,
            candidate: candidate && clean(candidate.imageUrl) ? candidate : null,
            error: errorText,
          };
        };

        const providerResults = await Promise.all(providerOrder.map((providerId) => (
          runLookupForProvider(providerId).then((result) => {
            const state = providerState.get(providerId) || {};
            state.loading = false;
            state.candidate = result.candidate || null;
            state.error = clean(result.error || '');
            providerState.set(providerId, state);
            renderFactsPhotoCards(buildVisualCandidates(), { includeCurrentImage: true });
            return result;
          })
        )));

        const candidates = providerResults
          .map((result) => result && result.candidate)
          .filter((candidate) => candidate && clean(candidate.imageUrl));
        const errors = providerResults
          .map((result) => clean(result && result.error ? result.error : ''))
          .filter((value) => !!value);

        renderFactsPhotoCards(buildVisualCandidates(), { includeCurrentImage: true });
        if (candidates.length > 0) {
          canRetryFactsByName = false;
          const suffix = errors.length > 0
            ? ` ${t('photo_search_status_api_error', { provider: providerChain, msg: errors.join(' | ') })}`
            : '';
          setStatus(`${t('photo_search_status_images_found', { count: candidates.length })}${suffix}`, errors.length > 0 ? 'warning' : 'success');
          return;
        }

        if (!useFallbackChain && allowNameFallback && productName && errors.length === 0) {
          canRetryFactsByName = true;
        }

        if (errors.length > 0) {
          setStatus(t('photo_search_status_api_error', { provider: providerChain || t('default_na'), msg: errors.join(' | ') }), 'danger');
        } else {
          setStatus(t('photo_search_status_images_none', { providers: providerChain || t('default_na') }), 'danger');
        }
      } catch (error) {
        const msg = clean(error && error.message ? error.message : String(error));
        providerState.forEach((state, providerId) => {
          if (state && state.loading === true) {
            state.loading = false;
            providerState.set(providerId, state);
          }
        });
        renderFactsPhotoCards(buildVisualCandidates(), { includeCurrentImage: true });
        if (!useFallbackChain && allowNameFallback && productName && isLookupNotFoundMessage(msg)) {
          canRetryFactsByName = true;
        }
        setStatus(t('photo_search_status_api_error', { provider: providerChain || t('default_na'), msg: msg || t('focus_unknown_error') }), 'danger');
      } finally {
        setButtonBusy(offBtn, false);
        setButtonBusy(offRetryBtn, false);
        renderState();
      }
    };

    const activatePhotoCandidate = async (candidateIndexInput) => {
      const candidateIndex = num(candidateIndexInput);
      if (!(candidateIndex >= 0) || candidateIndex >= factsPhotoCandidates.length) return;
      const candidate = factsPhotoCandidates[candidateIndex] || {};
      if (candidate && candidate.__isCurrentImage === true) {
        pendingPreviewFileName = '';
        renderFactsPhotoCards([]);
        setStatus(t('photo_search_status_keep_current'), 'info');
        renderState();
        return;
      }
      const imageUrl = clean(candidate.imageUrl || '');
      const providerLabel = clean(candidate.providerLabel || t('default_na'));
      if (!imageUrl) return;

      factsResults.classList.add('is-busy');
      setStatus(t('photo_search_status_image_saving', { provider: providerLabel }), 'info');
      try {
        const response = await fetch(imageUrl, {
          method: 'GET',
          mode: 'cors',
          credentials: 'omit',
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const blob = await response.blob();
        if (!(blob && blob.size > 0)) {
          throw new Error(langText('Réponse image vide.', 'Empty image response.'));
        }
        const saveResult = await saveFactsPhotoBlobToProduct(
          blob,
          candidate,
          productNameFromMainForm() || clean(nameInput.value),
          { refreshPreview: false, assignFileInput: false }
        );
        pendingPreviewFileName = clean(saveResult && saveResult.fileName ? saveResult.fileName : '');
        factsResults.querySelectorAll('.grocy-facts-photo-card').forEach((node) => node.classList.remove('is-selected'));
        const chosen = factsResults.querySelector(`.grocy-facts-photo-card[data-facts-photo-index="${candidateIndex}"]`);
        if (chosen) chosen.classList.add('is-selected');
        setStatus(t('photo_search_status_image_pending_refresh', { provider: providerLabel }), 'success');
      } catch (error) {
        const msg = clean(error && error.message ? error.message : String(error));
        const isDownloadError = /cors|network|http\s+\d+/i.test(msg);
        setStatus(
          isDownloadError
            ? t('photo_search_status_image_download_error', { msg: msg || t('focus_unknown_error') })
            : t('photo_search_status_image_save_error', { msg: msg || t('focus_unknown_error') }),
          'danger'
        );
      } finally {
        factsResults.classList.remove('is-busy');
        renderState();
      }
    };

    const onRefreshPreviewClick = () => {
      const fileName = clean(pendingPreviewFileName || '');
      if (!fileName) {
        renderState();
        return;
      }
      refreshProductPicturePreview(fileName);
      pendingPreviewFileName = '';
      setStatus(t('photo_search_status_image_refreshed'), 'success');
      renderState();
    };

    factsResults.onclick = (event) => {
      const target = event.target && event.target.closest
        ? event.target.closest('.grocy-facts-photo-card[data-facts-photo-index]')
        : null;
      if (!target || factsResults.classList.contains('is-busy')) return;
      activatePhotoCandidate(target.dataset.factsPhotoIndex);
    };
    factsResults.onkeydown = (event) => {
      const target = event.target && event.target.closest
        ? event.target.closest('.grocy-facts-photo-card[data-facts-photo-index]')
        : null;
      if (!target || factsResults.classList.contains('is-busy')) return;
      const key = clean(event.key || '').toLowerCase();
      if (key === 'enter' || key === ' ') {
        event.preventDefault();
        activatePhotoCandidate(target.dataset.factsPhotoIndex);
      }
    };

    pngBtn.addEventListener('click', onPngClick);
    jpgBtn.addEventListener('click', onJpgClick);
    offBtn.addEventListener('click', () => onOffClick(false));
    offRetryBtn.addEventListener('click', () => onOffClick(true));
    refreshPreviewBtn.addEventListener('click', onRefreshPreviewClick);
    nameInput.addEventListener('input', renderState);
    nameInput.addEventListener('change', renderState);

    if (S.productImageSearchBarcodeObserver) {
      try { S.productImageSearchBarcodeObserver.disconnect(); } catch (_err) {}
      S.productImageSearchBarcodeObserver = null;
    }
    const barcodeTable = document.getElementById('barcode-table');
    if (barcodeTable && window.MutationObserver) {
      const observer = new MutationObserver(() => renderState());
      observer.observe(barcodeTable, { childList: true, subtree: true, attributes: true });
      S.productImageSearchBarcodeObserver = observer;
    }

    const focusRefresh = () => {
      loadPhotoSearchProgress();
      renderState();
    };
    if (S.productImageSearchFocusHandler) {
      window.removeEventListener('focus', S.productImageSearchFocusHandler);
    }
    S.productImageSearchFocusHandler = focusRefresh;
    window.addEventListener('focus', S.productImageSearchFocusHandler);

    S.productImageSearchRefresh = () => {
      loadPhotoSearchSettings();
      loadPhotoSearchProgress();
      renderState();
    };

    loadPhotoSearchSettings();
    loadPhotoSearchProgress();
    setCurrentProductPictureTemporaryHidden(false);
    renderState();
  }

  function initProductEnergyRobotButton() {
    try {
      if (!isProductEditPage()) {
        if (S.productEnergyRobotObserver) {
          try { S.productEnergyRobotObserver.disconnect(); } catch (_err) {}
          S.productEnergyRobotObserver = null;
        }
        S.productEnergyRobotRefresh = null;
        return;
      }

      const caloriesInput = document.getElementById('calories');
      if (!caloriesInput) {
        S.productEnergyRobotRefresh = null;
        return;
      }
      const caloriesGroup = caloriesInput.closest('.form-group');
      const caloriesLabel = (caloriesGroup && caloriesGroup.querySelector('label[for="calories"]'))
        || document.querySelector('label[for="calories"]');
      if (!caloriesLabel) {
        S.productEnergyRobotRefresh = null;
        return;
      }
      caloriesLabel.classList.add('grocy-energy-robot-label');

    initOpenFoodFactsToolsStyle();

    let actions = caloriesLabel.querySelector('.grocy-energy-robot-actions');
    if (!actions) {
      actions = document.createElement('span');
      actions.className = 'grocy-energy-robot-actions';
      caloriesLabel.appendChild(actions);
    }

    let robotButton = actions.querySelector('[data-energy-robot]');
    if (!robotButton) {
      robotButton = document.createElement('button');
      robotButton.type = 'button';
      robotButton.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm grocy-off-btn-icon';
      robotButton.setAttribute('data-energy-robot', '1');
      robotButton.innerHTML = '<i class="fa-solid fa-robot"></i>';
      actions.appendChild(robotButton);
    }

    let status = actions.querySelector('.grocy-energy-robot-status');
    if (!status) {
      status = document.createElement('span');
      status.className = 'grocy-energy-robot-status text-muted';
      actions.appendChild(status);
    }
    status.dataset.terminalSource = langText('Énergie', 'Energy');

    const setStatus = (text = '', tone = 'muted') => {
      setBarcodeAutofillStatus(status, text, tone);
    };

    const refreshState = () => {
      const hiddenForGroup = applyProductEnergyVisibilityRules({
        caloriesInput,
        caloriesGroup,
        caloriesLabel,
        robotButton,
        actionsNode: actions,
        statusNode: status,
      });
      if (hiddenForGroup) {
        robotButton.title = isProductParentModeEnabled()
          ? langText(
            'Énergie désactivée en mode parent',
            'Energy disabled in parent mode'
          )
          : langText(
            'Énergie désactivée pour ce groupe non comestible',
            'Energy disabled for this non-edible group'
          );
        robotButton.setAttribute('aria-label', robotButton.title);
        return;
      }

      const hasName = productNameFromMainForm() !== '';
      const hasBarcode = readProductBarcodeCandidateFromPage() !== '';
      const stockUnitId = currentProductStockUnitId();
      const ready = hasName && hasBarcode && stockUnitId > 0;
      robotButton.disabled = !ready;
      robotButton.title = langText(
        'Robot énergie: récupère kcal et convertit vers l’unité de stock',
        'Energy robot: fetches kcal and converts to stock unit'
      );
      robotButton.setAttribute('aria-label', robotButton.title);
      if (!ready) {
        const missing = [];
        if (!hasName) missing.push(langText('nom', 'name'));
        if (!hasBarcode) missing.push(langText('code-barres', 'barcode'));
        if (!(stockUnitId > 0)) missing.push(langText('unité stock', 'stock unit'));
        setStatus(
          langText(`Manquant: ${missing.join(', ')}`, `Missing: ${missing.join(', ')}`),
          'muted'
        );
      } else if (!clean(status.textContent)) {
        setStatus('', 'muted');
      }
    };

    if (robotButton.dataset.energyRobotBound !== '1') {
      robotButton.dataset.energyRobotBound = '1';
      robotButton.addEventListener('click', async () => {
        const productId = currentEditedProductId();
        const productName = productNameFromMainForm();
        const barcode = readProductBarcodeCandidateFromPage();
        const stockUnitId = currentProductStockUnitId();
        const stockUnitName = currentProductStockUnitLabel();

        if (productId <= 0) {
          setStatus(langText('Erreur: ID produit manquant.', 'Error: missing product ID.'), 'danger');
          refreshState();
          return;
        }
        if (!productName || !barcode || !(stockUnitId > 0)) {
          refreshState();
          return;
        }

        const baseSettings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
        const primaryProvider = normalizeBarcodeLookupProvider(baseSettings.provider || 'openfoodfacts');
        const providerOrder = [primaryProvider, alternateBarcodeLookupProvider(primaryProvider)]
          .filter((id, index, arr) => id && arr.indexOf(id) === index);

        setButtonBusy(robotButton, true);
        let energyData = null;
        const providerErrors = [];
        const providersTried = [];
        let stockFactor = 0;
        let basisInfo = null;
        let basisBaseAmount = 0;
        let caloriesPerStockUnit = 0;
        let rounded = null;
        let decimals = caloriesInputDecimals(caloriesInput);
        let terminalError = '';
        try {
          setStatus(langText('1/4 Récupération kcal…', '1/4 Fetching kcal...'), 'info');
          for (const providerId of providerOrder) {
            const providerLabel = barcodeLookupProviderLabel(providerId);
            providersTried.push(providerLabel);
            try {
              setStatus(langText(`1/4 ${providerLabel}…`, `1/4 ${providerLabel}...`), 'info');
              energyData = await lookupFactsEnergyByBarcode(barcode, providerId);
              break;
            } catch (error) {
              const msg = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
              if (!isFactsProductTypeMismatchDetail(msg)) {
                providerErrors.push(`${providerLabel}: ${msg}`);
              }
            }
          }
          if (!energyData) {
            throw new Error(providerErrors.join(' | ') || langText('Aucune donnée énergie trouvée.', 'No energy data found.'));
          }

          setStatus(langText('2/4 Chargement conversions UQ…', '2/4 Loading UQ conversions...'), 'info');
          await loadQuantityConversionContextForProduct(productId);

          setStatus(langText('3/4 Conversion vers unité stock…', '3/4 Converting to stock unit...'), 'info');
          const factors = quantityFactorCandidatesForRow({
            id: productId,
            name: productName,
            stockUnitId,
            stockUnitName,
          });
          stockFactor = num(factors && factors[energyData.domain]);
          if (!(stockFactor > 0)) {
            throw new Error(langText(
              `Conversion impossible vers ${stockUnitName}.`,
              `No conversion path to ${stockUnitName}.`
            ));
          }

          basisInfo = describeQuantityUnit(energyData.basisUnit);
          basisBaseAmount = num(energyData.basisAmount) * num(basisInfo.factor);
          if (!(basisBaseAmount > 0)) {
            throw new Error(langText('Base nutrition invalide.', 'Invalid nutrition basis.'));
          }

          caloriesPerStockUnit = num(energyData.kcal) * (stockFactor / basisBaseAmount);
          if (!(caloriesPerStockUnit >= 0)) {
            throw new Error(langText('Calcul énergie invalide.', 'Invalid energy calculation.'));
          }

          decimals = caloriesInputDecimals(caloriesInput);
          rounded = Math.round(caloriesPerStockUnit * (10 ** decimals)) / (10 ** decimals);
          caloriesInput.value = String(rounded);
          caloriesInput.dispatchEvent(new Event('input', { bubbles: true }));
          caloriesInput.dispatchEvent(new Event('change', { bubbles: true }));

          setStatus(
            langText(
              `4/4 OK (${fmt(rounded, decimals)} kcal/${stockUnitName}) via ${energyData.providerLabel} (${energyData.basisLabel})`,
              `4/4 OK (${fmt(rounded, decimals)} kcal/${stockUnitName}) via ${energyData.providerLabel} (${energyData.basisLabel})`
            ),
            'success'
          );
        } catch (error) {
          const msg = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
          terminalError = msg;
          setStatus(langText(`Erreur: ${msg}`, `Error: ${msg}`), 'danger');
        } finally {
          const dataLines = [
            `${langText('Produit', 'Product')}: ${productName}`,
            `${langText('ID produit', 'Product ID')}: ${productId}`,
            `${langText('Code-barres', 'Barcode')}: ${barcode}`,
            `${langText('Unité de stock', 'Stock unit')}: ${stockUnitName} (#${stockUnitId})`,
            `${langText('Chaîne de fournisseurs', 'Provider chain')}: ${providerOrder.map((id) => barcodeLookupProviderLabel(id)).join(' -> ') || t('default_na')}`,
            `${langText('Fournisseurs tentés', 'Attempted providers')}: ${providersTried.join(' -> ') || t('default_na')}`,
          ];
          if (energyData) {
            dataLines.push(`${langText('Domaine', 'Domain')}: ${energyData.domain === 'mass' ? langText('Masse', 'Mass') : langText('Volume', 'Volume')}`);
            dataLines.push(`${langText('Base nutrition', 'Nutrition basis')}: ${fmt(num(energyData.basisAmount), 4)} ${energyData.basisLabel || t('default_na')}`);
            dataLines.push(`${langText('kcal source', 'Source kcal')}: ${fmt(num(energyData.kcal), 4)} kcal`);
            dataLines.push(`${langText('Facteur unité stock', 'Stock unit factor')}: ${fmt(stockFactor, 6)}`);
            dataLines.push(`${langText('Base normalisée', 'Normalized basis')}: ${fmt(basisBaseAmount, 6)} ${basisInfo && basisInfo.baseUnit ? basisInfo.baseUnit : t('default_na')}`);
            dataLines.push(`${langText('kcal/unité stock', 'kcal/stock unit')}: ${fmt(caloriesPerStockUnit, 6)}`);
          }
          if (rounded !== null && Number.isFinite(rounded)) {
            dataLines.push(`${langText('Valeur finale', 'Final value')}: ${fmt(rounded, decimals)} kcal/${stockUnitName}`);
          }
          if (providerErrors.length > 0) {
            dataLines.push(`${langText('Erreurs fournisseurs', 'Provider errors')}: ${providerErrors.join(' | ')}`);
          }
          if (terminalError) {
            dataLines.push(`${langText('Erreur finale', 'Final error')}: ${terminalError}`);
          }
          pushProductStatusTerminal(
            langText('Données de conversion kcal', 'kcal conversion data'),
            'data',
            langText('Énergie', 'Energy'),
            dataLines
          );
          setButtonBusy(robotButton, false);
          refreshState();
        }
      });
    }

    const nameInput = document.getElementById('name');
    if (nameInput && nameInput.dataset.energyRobotBound !== '1') {
      nameInput.dataset.energyRobotBound = '1';
      nameInput.addEventListener('input', refreshState);
      nameInput.addEventListener('change', refreshState);
    }
    const stockUnitSelect = document.getElementById('qu_id_stock');
    if (stockUnitSelect && stockUnitSelect.dataset.energyRobotBound !== '1') {
      stockUnitSelect.dataset.energyRobotBound = '1';
      stockUnitSelect.addEventListener('change', refreshState);
      stockUnitSelect.addEventListener('input', refreshState);
    }
    const productGroupSelect = currentProductGroupSelectElement();
    if (productGroupSelect && productGroupSelect.dataset.energyRobotBound !== '1') {
      productGroupSelect.dataset.energyRobotBound = '1';
      productGroupSelect.addEventListener('change', refreshState);
      productGroupSelect.addEventListener('input', refreshState);
    }

    if (S.productEnergyRobotObserver) {
      try { S.productEnergyRobotObserver.disconnect(); } catch (_err) {}
      S.productEnergyRobotObserver = null;
    }
    const barcodeTable = document.getElementById('barcode-table');
    if (barcodeTable && window.MutationObserver) {
      const observer = new MutationObserver(() => refreshState());
      observer.observe(barcodeTable, { childList: true, subtree: true, attributes: true });
      S.productEnergyRobotObserver = observer;
    }

      S.productEnergyRobotRefresh = refreshState;
      refreshState();
    } catch (error) {
      console.error('Energy robot init failed', error);
      try {
        if (S.productEnergyRobotObserver) {
          S.productEnergyRobotObserver.disconnect();
          S.productEnergyRobotObserver = null;
        }
      } catch (_err) {}
      S.productEnergyRobotRefresh = null;
    }
  }

  function initOpenFoodFactsToolsStyle() {
    if (document.getElementById('grocy-off-tools-style')) return;
    const style = document.createElement('style');
    style.id = 'grocy-off-tools-style';
    style.textContent = `
      .grocy-off-heading-actions {
        display: inline-flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.35rem;
        margin-left: 0.55rem;
        vertical-align: middle;
      }
      .grocy-off-heading-status {
        display: block;
        margin-top: 0.38rem;
        font-size: 0.78rem;
        line-height: 1.25;
        max-width: 100%;
        white-space: normal;
        overflow-wrap: anywhere;
      }
      .grocy-off-btn-sm {
        min-width: 2rem;
        height: 1.75rem;
        padding: 0.1rem 0.5rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 0.35rem;
        font-size: 0.78rem;
        line-height: 1;
      }
      .grocy-off-btn-sm.grocy-off-btn-icon {
        width: 1.9rem;
        min-width: 1.9rem;
        padding: 0;
      }
      .grocy-off-btn-sm.grocy-off-btn-toggle {
        width: 2.25rem;
        min-width: 2.25rem;
        padding: 0;
      }
      .grocy-off-btn-sm.grocy-off-btn-toggle i {
        font-size: 0.98rem;
        line-height: 1;
      }
      .grocy-off-btn-sm.grocy-off-btn-toggle.is-on {
        border-color: rgba(40,167,69,0.8);
        color: #97f0b4;
        background: rgba(40,167,69,0.16);
      }
      .grocy-off-btn-sm.grocy-off-btn-toggle.is-off {
        border-color: rgba(255,255,255,0.28);
      }
      .grocy-off-label-actions {
        display: inline-flex;
        align-items: center;
        margin-left: 0.35rem;
      }
      .grocy-energy-robot-actions {
        display: inline-flex;
        align-items: center;
        justify-content: flex-end;
        flex-wrap: wrap;
        gap: 0.35rem;
        margin-left: auto;
        vertical-align: middle;
        max-width: min(65vw, 720px);
      }
      .grocy-energy-robot-status {
        font-size: 0.76rem;
        line-height: 1.2;
        max-width: min(58vw, 560px);
        white-space: normal;
        overflow-wrap: anywhere;
        text-align: right;
      }
      .grocy-energy-robot-label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }
      .grocy-off-autofill-status {
        margin-top: 0.25rem;
      }
      .grocy-photo-search-tools {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.35rem;
      }
      #current-product-picture.grocy-current-picture-temp-hidden {
        display: none !important;
      }
      .grocy-off-ddg-icon {
        width: 0.95rem;
        height: 0.95rem;
        object-fit: contain;
        border-radius: 0.15rem;
        filter: grayscale(100%) brightness(1.05);
      }
      .grocy-facts-photo-results {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.55rem;
        margin-top: 0.55rem;
      }
      .grocy-facts-photo-results.is-busy {
        pointer-events: none;
        opacity: 0.72;
      }
      .grocy-facts-photo-card {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 0.5rem;
        background: linear-gradient(150deg, rgba(27,34,46,0.95), rgba(23,28,36,0.95));
        color: #d7deea;
        text-align: left;
        padding: 0.38rem;
        min-height: 180px;
        transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
      }
      .grocy-facts-photo-card:hover {
        border-color: rgba(0,123,255,0.8);
        box-shadow: 0 0 0 1px rgba(0,123,255,0.45), 0 8px 20px rgba(0,0,0,0.24);
        transform: translateY(-1px);
      }
      .grocy-facts-photo-card:focus {
        outline: none;
        border-color: rgba(0,123,255,0.9);
        box-shadow: 0 0 0 2px rgba(0,123,255,0.35);
      }
      .grocy-facts-photo-card.is-selected {
        border-color: rgba(40,167,69,0.95);
        box-shadow: 0 0 0 2px rgba(40,167,69,0.62), 0 12px 26px rgba(0,0,0,0.34);
        transform: translateY(-1px);
      }
      .grocy-facts-photo-card.is-current-image {
        border-style: dashed;
        border-color: rgba(102, 181, 255, 0.72);
        background: linear-gradient(150deg, rgba(23,35,54,0.95), rgba(16,24,38,0.95));
      }
      .grocy-facts-photo-card.is-current-image:hover,
      .grocy-facts-photo-card.is-current-image:focus {
        border-color: rgba(120, 200, 255, 0.95);
        box-shadow: 0 0 0 2px rgba(88, 176, 255, 0.4), 0 10px 24px rgba(0,0,0,0.3);
      }
      .grocy-facts-photo-card.is-loading {
        border-style: dashed;
        border-color: rgba(95, 196, 255, 0.72);
      }
      .grocy-facts-photo-card.is-disabled {
        cursor: default;
      }
      .grocy-facts-photo-card.is-disabled:hover,
      .grocy-facts-photo-card.is-disabled:focus {
        border-color: rgba(255,255,255,0.2);
        box-shadow: none;
        transform: none;
      }
      .grocy-facts-photo-head {
        font-size: 0.72rem;
        opacity: 0.88;
        margin-bottom: 0.32rem;
      }
      .grocy-facts-photo-thumb-wrap {
        position: relative;
        width: 100%;
        height: 120px;
        border-radius: 0.45rem;
        overflow: hidden;
        background: rgba(9,12,17,0.5);
        border: 1px solid rgba(255,255,255,0.08);
      }
      .grocy-facts-photo-thumb-wrap img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
        background: rgba(0,0,0,0.2);
      }
      .grocy-facts-photo-thumb-wrap .grocy-facts-photo-thumb {
        opacity: 1;
        transition: opacity 0.16s ease;
      }
      .grocy-facts-photo-thumb-wrap.is-loading,
      .grocy-facts-photo-thumb-wrap.is-empty {
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .grocy-facts-photo-thumb-wrap.is-image-loading .grocy-facts-photo-thumb {
        opacity: 0;
      }
      .grocy-facts-photo-thumb-wrap.is-image-loaded .grocy-facts-photo-thumb {
        opacity: 1;
      }
      .grocy-facts-photo-loader {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.34rem;
        width: 100%;
        height: 100%;
        color: #c0d7f4;
        font-size: 0.74rem;
      }
      .grocy-facts-photo-loader-inline {
        position: absolute;
        inset: 0;
        z-index: 2;
        background: rgba(11, 18, 27, 0.72);
      }
      .grocy-facts-photo-thumb-wrap.is-image-loaded .grocy-facts-photo-loader-inline {
        display: none;
      }
      .grocy-facts-photo-spinner {
        width: 1.55rem;
        height: 1.55rem;
        border-radius: 50%;
        border: 2px solid rgba(150, 196, 255, 0.35);
        border-top-color: rgba(75, 186, 255, 0.95);
        animation: grocyFactsPhotoSpin 0.82s linear infinite;
      }
      .grocy-facts-photo-loader-text {
        opacity: 0.92;
      }
      .grocy-facts-photo-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 0.34rem;
        width: 100%;
        height: 100%;
        color: #9fb3ca;
        font-size: 0.74rem;
        text-align: center;
        padding: 0.45rem;
      }
      .grocy-facts-photo-empty i {
        font-size: 1.05rem;
        opacity: 0.84;
      }
      @keyframes grocyFactsPhotoSpin {
        to { transform: rotate(360deg); }
      }
      .grocy-facts-photo-overlay {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 0.32rem 0.45rem;
        font-size: 0.74rem;
        font-weight: 600;
        color: #f4fbff;
        background: linear-gradient(0deg, rgba(16,22,31,0.92), rgba(16,22,31,0.18));
        opacity: 0;
        transform: translateY(4px);
        transition: opacity 0.16s ease, transform 0.16s ease;
        pointer-events: none;
      }
      .grocy-facts-photo-card:hover .grocy-facts-photo-overlay,
      .grocy-facts-photo-card:focus .grocy-facts-photo-overlay {
        opacity: 1;
        transform: translateY(0);
      }
      .grocy-facts-photo-name {
        margin-top: 0.4rem;
        font-size: 0.78rem;
        line-height: 1.2;
        color: #b8c6dd;
        min-height: 2.2em;
        overflow: hidden;
      }
      .grocy-barcode-robot-card {
        margin-top: 0.5rem;
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.56rem;
        background: rgba(255,255,255,0.04);
        padding: 0.45rem 0.55rem;
      }
      .grocy-barcode-robot-card-head {
        font-size: 0.74rem;
        color: #9ec2e9;
        margin-bottom: 0.28rem;
      }
      .grocy-barcode-robot-card-body {
        display: flex;
        align-items: flex-start;
        gap: 0.55rem;
      }
      .grocy-barcode-robot-card-thumb {
        width: 3.2rem;
        height: 3.2rem;
        border-radius: 0.45rem;
        border: 1px solid rgba(255,255,255,0.18);
        object-fit: cover;
        background: rgba(255,255,255,0.04);
        flex: 0 0 3.2rem;
      }
      .grocy-barcode-robot-card-thumb-empty {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: #8ea9c8;
      }
      .grocy-barcode-robot-card-meta {
        min-width: 0;
      }
      .grocy-barcode-robot-card-name {
        font-size: 0.82rem;
        font-weight: 600;
        color: #e7f0ff;
        line-height: 1.2;
        margin-bottom: 0.2rem;
      }
      .grocy-barcode-robot-card-code {
        font-size: 0.76rem;
        color: #bdd1e8;
      }
      .grocy-barcode-robot-card-link {
        margin-top: 0.18rem;
        display: inline-block;
        font-size: 0.75rem;
      }
      .grocy-product-terminal {
        position: fixed;
        right: 1rem;
        bottom: 1rem;
        z-index: 2146;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.45rem;
      }
      .grocy-product-terminal-toggle {
        width: 2.5rem;
        height: 2.5rem;
        border: 1px solid rgba(80, 170, 255, 0.65);
        border-radius: 0.65rem;
        background: linear-gradient(150deg, rgba(16,23,33,0.94), rgba(10,16,24,0.94));
        color: #d5e9ff;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 18px rgba(0,0,0,0.35);
        position: relative;
      }
      .grocy-product-terminal-toggle:hover {
        border-color: rgba(110, 190, 255, 0.95);
        color: #f1f8ff;
      }
      .grocy-product-terminal.is-pinned .grocy-product-terminal-toggle {
        border-color: rgba(85, 196, 142, 0.92);
        box-shadow: 0 8px 18px rgba(20, 125, 77, 0.36);
      }
      .grocy-product-terminal-badge {
        position: absolute;
        top: -0.38rem;
        right: -0.38rem;
        min-width: 1.1rem;
        height: 1.1rem;
        padding: 0 0.28rem;
        border-radius: 99px;
        font-size: 0.66rem;
        line-height: 1.1rem;
        font-weight: 700;
        text-align: center;
        color: #fff;
        background: linear-gradient(160deg, #ff5e62, #ff7f4a);
        box-shadow: 0 4px 10px rgba(255, 80, 80, 0.45);
      }
      .grocy-product-terminal-panel {
        width: min(430px, 92vw);
        max-height: min(48vh, 420px);
        overflow: hidden;
        border: 1px solid rgba(120, 170, 220, 0.36);
        border-radius: 0.72rem;
        background: linear-gradient(160deg, rgba(12,18,27,0.95), rgba(9,14,22,0.95));
        box-shadow: 0 18px 34px rgba(0,0,0,0.5);
        display: flex;
        flex-direction: column;
      }
      .grocy-product-terminal-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        padding: 0.5rem 0.65rem;
        border-bottom: 1px solid rgba(255,255,255,0.08);
        color: #dbe9ff;
      }
      .grocy-product-terminal-head-actions {
        display: inline-flex;
        gap: 0.3rem;
      }
      .grocy-product-terminal-head-actions [data-product-terminal-pin="1"].is-active {
        border-color: rgba(85, 196, 142, 0.92) !important;
        color: #c7f5dc !important;
        background: rgba(22, 126, 78, 0.28);
      }
      .grocy-product-terminal-list {
        overflow: auto;
        padding: 0.45rem;
        display: grid;
        gap: 0.4rem;
      }
      .grocy-product-terminal-row {
        border: 1px solid rgba(255,255,255,0.09);
        border-radius: 0.52rem;
        background: rgba(255,255,255,0.03);
        padding: 0.45rem 0.5rem;
        transition: transform 0.18s ease, opacity 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease;
        cursor: grab;
        user-select: none;
        position: relative;
      }
      .grocy-product-terminal-row.is-swiping {
        cursor: grabbing;
        z-index: 2;
        box-shadow: 0 8px 16px rgba(0,0,0,0.34);
      }
      .grocy-product-terminal-row.is-swipe-ready {
        border-color: rgba(95, 186, 255, 0.82);
      }
      .grocy-product-terminal-row.is-info { border-left: 3px solid rgba(45, 170, 255, 0.9); }
      .grocy-product-terminal-row.is-data { border-left: 3px solid rgba(30, 215, 214, 0.95); }
      .grocy-product-terminal-row.is-success { border-left: 3px solid rgba(58, 210, 130, 0.9); }
      .grocy-product-terminal-row.is-warning { border-left: 3px solid rgba(247, 179, 61, 0.95); }
      .grocy-product-terminal-row.is-danger { border-left: 3px solid rgba(255, 99, 99, 0.95); }
      .grocy-product-terminal-row.is-muted { border-left: 3px solid rgba(170, 182, 198, 0.65); }
      .grocy-product-terminal-row.is-empty {
        cursor: default;
      }
      .grocy-product-terminal-row-meta {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.67rem;
        color: #9db4cc;
        margin-bottom: 0.2rem;
      }
      .grocy-product-terminal-type {
        border: 1px solid rgba(255,255,255,0.16);
        border-radius: 0.3rem;
        padding: 0 0.24rem;
      }
      .grocy-product-terminal-source,
      .grocy-product-terminal-repeat {
        color: #bfd7f0;
      }
      .grocy-product-terminal-row-text {
        font-size: 0.77rem;
        line-height: 1.25;
        color: #e4eefc;
        white-space: normal;
        overflow-wrap: anywhere;
      }
      .grocy-product-terminal-row-details {
        margin-top: 0.28rem;
        padding-top: 0.26rem;
        border-top: 1px dashed rgba(170, 198, 226, 0.18);
        display: grid;
        gap: 0.12rem;
      }
      .grocy-product-terminal-row-detail {
        font-size: 0.69rem;
        line-height: 1.26;
        color: #bdd0e6;
        white-space: normal;
        overflow-wrap: anywhere;
      }
      body[data-product-status-terminal-only="1"] .grocy-off-autofill-status,
      body[data-product-status-terminal-only="1"] #product-picture-search-tools-status,
      body[data-product-status-terminal-only="1"] .grocy-energy-robot-status,
      body[data-product-status-terminal-only="1"] .grocy-off-heading-status {
        display: none !important;
      }
    `;
    document.head.appendChild(style);
  }

  function isProductEditPage() {
    const path = clean(window.location.pathname);
    return /\/product\/\d+\/?$/.test(path);
  }

  function initProductFormTypeRulesStyle() {
    if (document.getElementById('grocy-product-type-rules-style')) return;
    const style = document.createElement('style');
    style.id = 'grocy-product-type-rules-style';
    style.textContent = `
      .grocy-parent-mode-hidden,
      .grocy-product-type-hidden,
      .grocy-parent-internal-hidden {
        display: none !important;
      }
      .grocy-parent-mode-dimmed {
        opacity: 0.56;
        filter: saturate(0.72);
      }
      .grocy-userfields-unboxed {
        border: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
      }
      .grocy-parent-source-group .custom-control-label {
        font-weight: 600;
      }
      .grocy-parent-conversions-tight-top {
        margin-top: 0 !important;
        padding-top: 0 !important;
      }
    `;
    document.head.appendChild(style);
  }

  function productFormElement() {
    return document.getElementById('product-form');
  }

  function productNoOwnStockCheckbox() {
    const input = document.getElementById('no_own_stock');
    if (!input) return null;
    if (input.closest && input.closest('form#barcode-form')) return null;
    return input;
  }

  function productDisableOpenCheckbox() {
    const input = document.getElementById('disable_open');
    if (!input) return null;
    if (input.closest && input.closest('form#barcode-form')) return null;
    return input;
  }

  function productUserfieldsForm() {
    const form = document.getElementById('userfields-form');
    if (!form) return null;
    return form;
  }

  function showUserfieldSaveError(xhrInput) {
    const message = xhrErrorMessage(xhrInput);
    try {
      if (window.Grocy && window.Grocy.FrontendHelpers && typeof window.Grocy.FrontendHelpers.ShowGenericError === 'function') {
        window.Grocy.FrontendHelpers.ShowGenericError('Error while saving, probably this item already exists', message);
        return;
      }
    } catch (_err) {}
    console.error('Userfield save error', message);
  }

  function userfieldApiPutPromise(pathInput, payloadInput = {}) {
    return new Promise((resolve, reject) => {
      if (!window.Grocy || !window.Grocy.Api || typeof window.Grocy.Api.Put !== 'function') {
        reject(new Error(langText('API Grocy indisponible.', 'Grocy API unavailable.')));
        return;
      }
      window.Grocy.Api.Put(pathInput, payloadInput,
        (result) => resolve(result),
        (xhr) => reject(xhr)
      );
    });
  }

  function userfieldApiUploadFilePromise(fileInput, groupInput, fileNameInput) {
    return new Promise((resolve, reject) => {
      if (!window.Grocy || !window.Grocy.Api || typeof window.Grocy.Api.UploadFile !== 'function') {
        reject(new Error(langText('Upload Grocy indisponible.', 'Grocy upload API unavailable.')));
        return;
      }
      window.Grocy.Api.UploadFile(fileInput, groupInput, fileNameInput,
        (result) => resolve(result),
        (xhr) => reject(xhr)
      );
    });
  }

  function userfieldApiDeleteFilePromise(fileNameInput, groupInput) {
    return new Promise((resolve, reject) => {
      if (!window.Grocy || !window.Grocy.Api || typeof window.Grocy.Api.DeleteFile !== 'function') {
        reject(new Error(langText('API suppression fichier indisponible.', 'File delete API unavailable.')));
        return;
      }
      window.Grocy.Api.DeleteFile(fileNameInput, groupInput,
        (result) => resolve(result),
        (xhr) => reject(xhr)
      );
    });
  }

  function collectDirtyProductUserfieldInputs() {
    const form = productFormElement();
    if (!form) return [];
    return Array.from(form.querySelectorAll('.userfield-input.is-dirty'))
      .filter((input) => !!input && input.nodeType === 1)
      .filter((input) => input.tagName && input.tagName.toLowerCase() !== 'div')
      .filter((input) => !(input.closest && input.closest('form#barcode-form')))
      .filter((input) => {
        const fieldName = clean(input.getAttribute('data-userfield-name') || '');
        return fieldName !== '';
      });
  }

  function buildUserfieldPayloadFromInput(inputEl) {
    const input = inputEl && inputEl.nodeType === 1 ? inputEl : null;
    if (!input) return null;
    const fieldName = clean(input.getAttribute('data-userfield-name') || '');
    if (!fieldName) return null;

    const type = clean(input.getAttribute('type') || '').toLowerCase();
    const payload = {};
    let oldFile = '';
    let newFile = '';
    let uploadFile = null;

    if (type === 'checkbox') {
      payload[fieldName] = input.checked ? '1' : '0';
    } else if (type === 'file') {
      oldFile = clean(input.getAttribute('data-old-file') || '');
      if (oldFile) payload[fieldName] = '';
      if (input.files && input.files.length > 0) {
        const selectedFile = input.files[0];
        uploadFile = selectedFile;
        const sourceName = clean(selectedFile && selectedFile.name ? selectedFile.name : 'file');
        const sourceParts = sourceName.split('.');
        const sourceExtRaw = sourceParts.length > 1 ? sourceParts[sourceParts.length - 1] : 'dat';
        const sourceExt = clean(typeof window.CleanFileName === 'function' ? window.CleanFileName(sourceExtRaw) : sourceExtRaw) || 'dat';
        const rand = typeof window.RandomString === 'function' ? String(window.RandomString()) : String(Date.now());
        newFile = `${rand}.${sourceExt}`;
        const cleanSourceName = clean(typeof window.CleanFileName === 'function' ? window.CleanFileName(sourceName) : sourceName) || 'file';
        try {
          payload[fieldName] = `${window.btoa(newFile)}_${window.btoa(cleanSourceName)}`;
        } catch (_err) {
          payload[fieldName] = '';
        }
      }
    } else if (input.multiple === true) {
      const values = Array.from(input.selectedOptions || [])
        .map((option) => clean(option && option.value ? option.value : ''))
        .filter((value) => value !== '');
      payload[fieldName] = values.join(',');
    } else {
      payload[fieldName] = input.value == null ? '' : String(input.value);
    }

    return {
      fieldName,
      payload,
      oldFile,
      newFile,
      uploadFile,
    };
  }

  async function saveSingleUserfieldInput(entityInput, objectIdInput, inputEl) {
    const entity = clean(entityInput || '');
    const objectId = num(objectIdInput);
    if (!entity || !(objectId > 0) || !inputEl) return;

    const data = buildUserfieldPayloadFromInput(inputEl);
    if (!data) return;

    await userfieldApiPutPromise(`userfields/${entity}/${objectId}`, data.payload);

    if (data.newFile && data.oldFile) {
      await userfieldApiDeleteFilePromise(data.oldFile, 'userfiles');
      await userfieldApiUploadFilePromise(data.uploadFile, 'userfiles', data.newFile);
      inputEl.setAttribute('data-old-file', '');
    } else if (data.newFile) {
      await userfieldApiUploadFilePromise(data.uploadFile, 'userfiles', data.newFile);
      inputEl.setAttribute('data-old-file', '');
    } else if (data.oldFile) {
      await userfieldApiDeleteFilePromise(data.oldFile, 'userfiles');
      inputEl.setAttribute('data-old-file', '');
    }
  }

  function patchUserfieldsFormSaveForProductForm() {
    if (S.productUserfieldsSavePatched) return;
    if (!isProductFormPage()) return;
    const component = window.Grocy && window.Grocy.Components && window.Grocy.Components.UserfieldsForm
      ? window.Grocy.Components.UserfieldsForm
      : null;
    if (!component || typeof component.Save !== 'function') return;
    if (component.Save.__grocyPatchedByCustomJs === true) {
      S.productUserfieldsSavePatched = true;
      return;
    }

    const originalSave = component.Save.bind(component);
    component.Save = function patchedUserfieldSave(success, error) {
      const userfieldsForm = productUserfieldsForm();
      const objectId = num(window?.Grocy?.EditObjectId);
      const entity = clean(userfieldsForm && userfieldsForm.getAttribute ? userfieldsForm.getAttribute('data-entity') : '');
      if (!userfieldsForm || !entity || !(objectId > 0)) {
        originalSave(success, error);
        return;
      }

      const dirtyInputs = collectDirtyProductUserfieldInputs();
      if (dirtyInputs.length === 0) {
        if (typeof success === 'function') success();
        return;
      }

      (async () => {
        try {
          for (const inputEl of dirtyInputs) {
            await saveSingleUserfieldInput(entity, objectId, inputEl);
            inputEl.classList.remove('is-dirty');
          }
          if (typeof success === 'function') success();
        } catch (xhr) {
          showUserfieldSaveError(xhr);
          if (typeof error === 'function') error();
        }
      })();
    };

    component.Save.__grocyPatchedByCustomJs = true;
    component.Save.__grocyOriginalSave = originalSave;
    S.productUserfieldsSavePatched = true;
  }

  function productUserfieldGroups() {
    const form = productFormElement();
    if (!form) return [];
    return Array.from(form.querySelectorAll('.form-group'))
      .filter((group) => !!group.querySelector('[data-userfield-name], [name^="userfields["], [name*="userfields["]'));
  }

  function productUserfieldGroupMeta(group) {
    if (!group) return null;
    const input = group.querySelector('[data-userfield-name], [name^="userfields["], [name*="userfields["]');
    if (!input) return null;
    const dataName = clean(input.getAttribute('data-userfield-name') || '');
    const nameAttr = clean(input.getAttribute('name') || '');
    const nameMatch = nameAttr.match(/userfields\[(.+?)\]/i);
    const name = dataName || clean(nameMatch ? nameMatch[1] : '');
    const labelNode = group.querySelector('label');
    const label = clean(labelNode ? labelNode.textContent : '');
    return {
      group,
      input,
      name,
      label,
      nameNorm: norm(name),
      labelNorm: norm(label),
    };
  }

  function isParentUserfieldMeta(meta) {
    if (!meta || !meta.input) return false;
    const type = clean(meta.input.type || '').toLowerCase();
    if (type && type !== 'checkbox') return false;
    const haystack = `${meta.nameNorm} ${meta.labelNorm}`.trim();
    if (!haystack) return false;
    if (meta.nameNorm === 'parent' || meta.labelNorm === 'parent') return true;
    return haystack.includes('parent')
      || haystack.includes('produit parent')
      || haystack.includes('mode parent');
  }

  function productParentSourceGroup() {
    const groups = productUserfieldGroups();
    for (const group of groups) {
      const meta = productUserfieldGroupMeta(group);
      if (isParentUserfieldMeta(meta)) return group;
    }
    const form = productFormElement();
    if (!form) return null;
    const allGroups = Array.from(form.querySelectorAll('.form-group'));
    for (const group of allGroups) {
      if (!group || !group.querySelector) continue;
      const checkbox = group.querySelector('input[type="checkbox"]');
      if (!checkbox) continue;
      const checkboxId = clean(checkbox.id || '').toLowerCase();
      if (checkboxId === 'no_own_stock' || checkboxId === 'active') continue;
      const labelNode = group.querySelector('label');
      const labelText = norm(labelNode ? labelNode.textContent : '');
      if (!labelText) continue;
      if (labelText.includes('parent') || labelText.includes('mode parent') || labelText.includes('agregat')) {
        return group;
      }
    }
    return null;
  }

  function productParentSourceCheckbox() {
    const group = productParentSourceGroup();
    if (!group) return null;
    const checkbox = group.querySelector('input[type="checkbox"][data-userfield-name], input[type="checkbox"][name^="userfields["], input[type="checkbox"][name*="userfields["], input[type="checkbox"]');
    return checkbox || null;
  }

  function productParentSourceUserfieldName() {
    const checkbox = productParentSourceCheckbox();
    if (!checkbox) return '';
    const fromData = clean(checkbox.getAttribute('data-userfield-name') || '');
    if (fromData) return fromData;
    const nameAttr = clean(checkbox.getAttribute('name') || '');
    if (nameAttr) {
      const match = nameAttr.match(/userfields\[(.+?)\]/i);
      if (match && match[1]) return clean(match[1]);
      return nameAttr;
    }
    return clean(checkbox.getAttribute('id') || '');
  }

  function updateLabelTextPreserveIcons(labelNode, textInput = '') {
    if (!labelNode) return;
    const text = clean(textInput || '');
    if (!text) return;
    Array.from(labelNode.childNodes || []).forEach((node) => {
      if (node && node.nodeType === 3) {
        labelNode.removeChild(node);
      }
    });
    const firstChild = labelNode.firstChild || null;
    const spacer = firstChild ? ' ' : '';
    labelNode.insertBefore(document.createTextNode(`${text}${spacer}`), firstChild);
  }

  function applyParentSourcePresentation() {
    const group = productParentSourceGroup();
    if (!group) return;
    const labelNode = group.querySelector('label');
    if (!labelNode) return;
    updateLabelTextPreserveIcons(
      labelNode,
      langText('Mode parent (produit agrégateur)', 'Parent mode (aggregator product)')
    );
  }

  function productParentPersistSnapshot() {
    if (!isProductEditPage()) return null;
    const productId = currentEditedProductId();
    if (!(productId > 0)) return null;
    const noOwnStockInput = productNoOwnStockCheckbox();
    const disableOpenInput = productDisableOpenCheckbox();
    const parentSourceInput = productParentSourceCheckbox();
    const parentSourceField = productParentSourceUserfieldName();
    const noOwnStock = !!(noOwnStockInput && noOwnStockInput.checked);
    const disableOpen = !!(disableOpenInput && disableOpenInput.checked);
    const parentSourceChecked = !!(parentSourceInput && parentSourceInput.checked);
    return {
      productId,
      noOwnStock,
      disableOpen,
      parentSourceChecked,
      parentSourceField,
      key: `${productId}|${noOwnStock ? 1 : 0}|${disableOpen ? 1 : 0}|${parentSourceField}|${parentSourceChecked ? 1 : 0}`,
    };
  }

  async function flushProductParentPersistQueue() {
    if (S.productParentPersistInFlight) return;
    const snapshot = S.productParentPersistPendingSnapshot;
    if (!snapshot) return;
    if (snapshot.key === S.productParentPersistLastKey) return;
    S.productParentPersistInFlight = true;
    try {
      await putJson(`api/objects/products/${snapshot.productId}`, {
        no_own_stock: snapshot.noOwnStock ? 1 : 0,
        disable_open: snapshot.disableOpen ? 1 : 0,
      });
      if (clean(snapshot.parentSourceField || '') && snapshot.parentSourceChecked === true) {
        await userfieldApiPutPromise(`userfields/products/${snapshot.productId}`, {
          [snapshot.parentSourceField]: '1',
        });
        if (isProductFormPage()) {
          pushProductStatusTerminal(
            langText('Mode parent synchronisé en base.', 'Parent mode synced to database.'),
            'success',
            langText('Produit', 'Product'),
            [
              `${langText('Champ parent', 'Parent field')}: ${snapshot.parentSourceField}`,
              `${langText('Valeur', 'Value')}: 1`,
            ]
          );
        }
      }
      S.productParentPersistLastKey = snapshot.key;
      try {
        if (window.Grocy && window.Grocy.EditObjectProduct) {
          window.Grocy.EditObjectProduct.no_own_stock = snapshot.noOwnStock ? 1 : 0;
          window.Grocy.EditObjectProduct.disable_open = snapshot.disableOpen ? 1 : 0;
        }
      } catch (_err) {}
    } catch (error) {
      console.warn('Parent mode auto-save failed', error);
      if (isProductFormPage()) {
        pushProductStatusTerminal(
          langText('Échec de synchronisation du mode parent.', 'Parent mode sync failed.'),
          'danger',
          langText('Produit', 'Product'),
          [
            `${langText('Détail', 'Detail')}: ${clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error')}`,
          ]
        );
      }
    } finally {
      S.productParentPersistInFlight = false;
      if (S.productParentPersistPendingSnapshot && S.productParentPersistPendingSnapshot.key !== S.productParentPersistLastKey) {
        setTimeout(() => {
          flushProductParentPersistQueue();
        }, 60);
      }
    }
  }

  function scheduleProductParentPersist() {
    const snapshot = productParentPersistSnapshot();
    if (!snapshot) return;
    if (snapshot.key === S.productParentPersistLastKey) return;
    S.productParentPersistPendingSnapshot = snapshot;
    if (S.productParentPersistTimer) {
      clearTimeout(S.productParentPersistTimer);
    }
    S.productParentPersistTimer = setTimeout(() => {
      S.productParentPersistTimer = null;
      flushProductParentPersistQueue();
    }, 260);
  }

  function findUserfieldGroupByKeywords(keywordsInput = []) {
    const keywords = Array.isArray(keywordsInput) ? keywordsInput.map((k) => norm(k)).filter((k) => !!k) : [];
    if (keywords.length === 0) return null;
    const groups = productUserfieldGroups();
    for (const group of groups) {
      const meta = productUserfieldGroupMeta(group);
      if (!meta) continue;
      const haystack = `${meta.nameNorm} ${meta.labelNorm}`.trim();
      if (!haystack) continue;
      if (keywords.some((keyword) => haystack.includes(keyword))) return group;
    }
    return null;
  }

  function moveGroupAfterAnchor(group, anchor) {
    if (!group || !anchor || !anchor.parentNode) return anchor;
    if (group === anchor) return group;
    anchor.insertAdjacentElement('afterend', group);
    return group;
  }

  function unboxProductUserfieldsForm() {
    const form = productUserfieldsForm();
    if (!form) return;
    form.classList.add('grocy-userfields-unboxed');
    form.classList.remove('border', 'border-info', 'p-2', 'mb-2');
    const title = form.querySelector('h2.small');
    if (title) title.classList.add('d-none');
  }

  function spreadProductUserfieldsByUtility() {
    if (!isProductFormPage()) return;
    unboxProductUserfieldsForm();

    const form = productFormElement();
    if (!form) return;

    let anchorTop = productNameFormGroup();
    if (!anchorTop) return;

    const parentGroup = productParentSourceGroup();
    if (parentGroup) {
      parentGroup.classList.add('grocy-parent-source-group');
      anchorTop = moveGroupAfterAnchor(parentGroup, anchorTop);
    }

    let anchorBrand = productFormGroupByInputId('product_group_id') || anchorTop;
    const brandGroup = findUserfieldGroupByKeywords(['marque', 'brand']);
    if (brandGroup && brandGroup !== parentGroup) {
      anchorBrand = moveGroupAfterAnchor(brandGroup, anchorBrand);
    }
    const subBrandGroup = findUserfieldGroupByKeywords(['sous-marque', 'sub-brand', 'subbrand']);
    if (subBrandGroup && subBrandGroup !== parentGroup && subBrandGroup !== brandGroup) {
      anchorBrand = moveGroupAfterAnchor(subBrandGroup, anchorBrand);
    }
    const originGroup = findUserfieldGroupByKeywords(['origine', 'origin', 'siqo', 'qualite']);
    if (originGroup && originGroup !== parentGroup && originGroup !== brandGroup && originGroup !== subBrandGroup) {
      moveGroupAfterAnchor(originGroup, anchorBrand);
    }

    let anchorMedication = productFormGroupByInputId('calories') || productFormGroupByInputId('quick_consume_amount') || anchorBrand;
    const activeSubstanceGroup = findUserfieldGroupByKeywords(['substance active', 'active substance']);
    if (activeSubstanceGroup && activeSubstanceGroup !== parentGroup) {
      anchorMedication = moveGroupAfterAnchor(activeSubstanceGroup, anchorMedication);
    }
    const renewalGroup = findUserfieldGroupByKeywords(['renouvellement', 'renewal', 'renew']);
    if (renewalGroup && renewalGroup !== parentGroup && renewalGroup !== activeSubstanceGroup) {
      moveGroupAfterAnchor(renewalGroup, anchorMedication);
    }
  }

  function isProductParentModeEnabled() {
    const parentSource = productParentSourceCheckbox();
    if (parentSource) return parentSource.checked === true;
    const noOwnStock = productNoOwnStockCheckbox();
    return !!(noOwnStock && noOwnStock.checked);
  }

  function productNameFormGroup() {
    const nameInput = document.getElementById('name');
    if (!nameInput) return null;
    return nameInput.closest('.form-group');
  }

  function productParentPickerSelect() {
    const form = productFormElement();
    if (!form) return null;
    const select = form.querySelector('select#product_id[name="product_id"]');
    return select || null;
  }

  function productParentPickerGroup() {
    const select = productParentPickerSelect();
    if (!select) return null;
    return select.closest('.form-group');
  }

  function productFormGroupByInputId(inputId) {
    const input = document.getElementById(inputId);
    if (!input) return null;
    if (input.closest && input.closest('form#barcode-form')) return null;
    return input.closest('.form-group');
  }

  function productBarcodeSectionRow() {
    const table = document.getElementById('barcode-table');
    if (!table) return null;
    return table.closest('.row');
  }

  function productBarcodeTitleWrap() {
    const table = document.getElementById('barcode-table');
    if (!table) return null;
    const section = table.closest('.col');
    if (!section) return null;
    const wraps = Array.from(section.querySelectorAll('.title-related-links'));
    for (const wrap of wraps) {
      const heading = wrap.querySelector('h4');
      const text = norm(heading ? heading.textContent : wrap.textContent);
      if (!text) continue;
      if (text.includes('barcode') || text.includes('code-barre')) return wrap;
    }
    return null;
  }

  function productBarcodeHeadlineInfoNode() {
    return document.getElementById('barcode-headline-info');
  }

  function productBarcodeTableContainer() {
    const table = document.getElementById('barcode-table');
    if (!table) return null;
    return table.closest('.dataTables_wrapper') || table;
  }

  function productGrocycodeSectionRow() {
    const grocycodeDownload = document.querySelector('a[href*="/grocycode?download=true"]');
    if (!grocycodeDownload) return null;
    return grocycodeDownload.closest('.row');
  }

  function productSpecificConversionsRow() {
    const table = document.getElementById('qu-conversions-table-products');
    if (!table) return null;
    return table.closest('.row');
  }

  function setParentModeNodeHidden(node, hidden) {
    if (!node || !node.classList) return;
    node.classList.toggle('grocy-parent-mode-hidden', hidden === true);
  }

  function setParentModeNodeDimmed(node, dimmed) {
    if (!node || !node.classList) return;
    node.classList.toggle('grocy-parent-mode-dimmed', dimmed === true);
  }

  function setGroupRequiredState(group, visible) {
    if (!group || !group.querySelectorAll) return;
    const controls = group.querySelectorAll('input, select, textarea');
    controls.forEach((control) => {
      if (!control) return;
      if (visible) {
        if (control.dataset.grocyRequiredRestore === '1') {
          control.setAttribute('required', 'required');
          delete control.dataset.grocyRequiredRestore;
        }
      } else if (control.hasAttribute('required')) {
        control.dataset.grocyRequiredRestore = '1';
        control.removeAttribute('required');
      }
    });
  }

  function normalizeProductTypeKey(typeInput = '') {
    const type = norm(typeInput || '');
    if (!type) return 'comestible';
    if (type.includes('parent')) return 'parent';
    if (type.includes('medic') || type.includes('pharma') || type.includes('drug')) return 'medicament';
    if (type.includes('hygiene') || type.includes('toilet') || type.includes('cosmet') || type.includes('soin')) return 'hygiene';
    if (type.includes('entretien') || type.includes('clean') || type.includes('lessive') || type.includes('deterg')) return 'entretien';
    if (type.includes('non') && (type.includes('comest') || type.includes('aliment') || type.includes('food'))) return 'non-comestible';
    if (type.includes('animal') || type.includes('pet') || type.includes('chien') || type.includes('chat')) return 'animal';
    return 'comestible';
  }

  function inferProductTypeFromGroupLabel(labelInput = '') {
    const groupLabel = norm(labelInput || '');
    if (!groupLabel) return 'comestible';

    const medicationMarkers = ['medicament', 'medicaments', 'medication', 'medicine', 'drug', 'pharma', 'sante', 'vitamine'];
    if (medicationMarkers.some((marker) => groupLabel.includes(marker))) return 'medicament';

    const hygieneMarkers = ['hygiene', 'soin', 'toilet', 'cosmet', 'beaute', 'personal care', 'shampo', 'dentifrice', 'savon'];
    if (hygieneMarkers.some((marker) => groupLabel.includes(marker))) return 'hygiene';

    const maintenanceMarkers = ['entretien', 'nettoy', 'clean', 'deterg', 'lessive', 'maison', 'household', 'vaisselle', 'desinfect'];
    if (maintenanceMarkers.some((marker) => groupLabel.includes(marker))) return 'entretien';

    const nonEdibleMarkers = ['non comestible', 'non alimentaire', 'non food', 'accessoire', 'materiel', 'outil'];
    if (nonEdibleMarkers.some((marker) => groupLabel.includes(marker))) return 'non-comestible';

    const animalMarkers = ['animal', 'animaux', 'pet', 'chien', 'chat', 'nourriture animale'];
    if (animalMarkers.some((marker) => groupLabel.includes(marker))) return 'animal';

    return 'comestible';
  }

  function currentProductTypeKey() {
    if (isProductParentModeEnabled()) return 'parent';
    return normalizeProductTypeKey(inferProductTypeFromGroupLabel(currentProductGroupLabel()));
  }

  function classifyUserfieldTags(haystackNormInput = '') {
    const haystack = norm(haystackNormInput || '');
    const tags = new Set();
    if (!haystack) {
      tags.add('generic');
      return tags;
    }

    const genericMarkers = ['marque', 'brand', 'fabricant', 'manufacturer', 'fournisseur', 'supplier', 'reference', 'ref', 'categorie', 'category'];
    if (genericMarkers.some((marker) => haystack.includes(marker))) tags.add('generic');

    const foodMarkers = ['calorie', 'kcal', 'energie', 'nutrition', 'nutri', 'ingredient', 'allergen', 'allergene', 'siqo', 'bio', 'conservation', 'recette', 'saveur', 'gout', 'origine', 'origin'];
    if (foodMarkers.some((marker) => haystack.includes(marker))) tags.add('food');

    const medicationMarkers = [
      'dosage',
      'posologie',
      'ordonnance',
      'prescription',
      'contre indication',
      'molecule',
      'dci',
      'notice',
      'cip',
      'pharma',
      'lot',
      'substance active',
      'active substance',
      'renouvellement',
      'renewal',
      'renew',
    ];
    if (medicationMarkers.some((marker) => haystack.includes(marker))) tags.add('medication');

    const hygieneMarkers = ['peau', 'cheveux', 'dermato', 'ph', 'toilet', 'hygiene', 'parfum', 'visage', 'corps'];
    if (hygieneMarkers.some((marker) => haystack.includes(marker))) tags.add('hygiene');

    const maintenanceMarkers = ['surface', 'dilution', 'nettoy', 'deterg', 'corros', 'inflamm', 'javel', 'lessive', 'vaisselle', 'entretien'];
    if (maintenanceMarkers.some((marker) => haystack.includes(marker))) tags.add('entretien');

    const nonFoodMarkers = ['voltage', 'watt', 'materiau', 'matiere', 'dimension', 'taille', 'sku', 'ean', 'modele', 'model'];
    if (nonFoodMarkers.some((marker) => haystack.includes(marker))) tags.add('nonfood');

    const parentMarkers = ['parent', 'agr', 'regroup', 'sous produit', 'sub product', 'aggregation'];
    if (parentMarkers.some((marker) => haystack.includes(marker))) tags.add('parent');

    const animalMarkers = ['animal', 'pet', 'chien', 'chat'];
    if (animalMarkers.some((marker) => haystack.includes(marker))) tags.add('animal');

    if (tags.size === 0) tags.add('generic');
    return tags;
  }

  function shouldShowUserfieldForProductType(tagsInput, typeKeyInput = '') {
    const tags = tagsInput instanceof Set ? tagsInput : new Set(['generic']);
    const typeKey = normalizeProductTypeKey(typeKeyInput || currentProductTypeKey());
    const allowedByType = {
      parent: new Set(['generic', 'parent']),
      'non-comestible': new Set(['generic', 'nonfood', 'entretien', 'hygiene']),
      entretien: new Set(['generic', 'nonfood', 'entretien']),
      hygiene: new Set(['generic', 'nonfood', 'hygiene']),
      medicament: new Set(['generic', 'nonfood', 'medication']),
      animal: new Set(['generic', 'food', 'animal']),
      comestible: new Set(['generic', 'food', 'animal']),
    };
    const allowed = allowedByType[typeKey] || allowedByType.comestible;
    for (const tag of tags) {
      if (allowed.has(tag)) return true;
    }
    return false;
  }

  function isMedicationOnlyUserfieldHaystack(haystackNormInput = '') {
    const haystack = norm(haystackNormInput || '');
    if (!haystack) return false;
    const compactHaystack = haystack.replace(/[^a-z0-9]+/g, ' ').trim();
    const medicationOnlyMarkers = [
      'dosage',
      'posologie',
      'ordonnance',
      'prescription',
      'contre indication',
      'contre-indication',
      'molecule',
      'dci',
      'notice',
      'lien notice',
      'url notice',
      'cip',
      'pharma',
      'substance active',
      'active substance',
      'renouvellement',
      'renewal',
      'renew',
    ];
    return medicationOnlyMarkers.some((markerInput) => {
      const marker = norm(markerInput).replace(/[^a-z0-9]+/g, ' ').trim();
      if (!marker) return false;
      return compactHaystack.includes(marker);
    });
  }

  function applyProductUserfieldTypeRules(typeKeyInput = '') {
    const typeKey = normalizeProductTypeKey(typeKeyInput || currentProductTypeKey());
    const groups = productUserfieldGroups();
    groups.forEach((group) => {
      const meta = productUserfieldGroupMeta(group);
      const userfieldInput = meta ? meta.input : null;
      if (!userfieldInput) return;
      if (isParentUserfieldMeta(meta)) {
        group.classList.remove('grocy-product-type-hidden');
        setGroupRequiredState(group, true);
        return;
      }
      const haystack = `${meta.nameNorm} ${meta.labelNorm}`.trim();
      const tags = classifyUserfieldTags(haystack);
      let visible = typeKey === 'parent'
        ? true
        : shouldShowUserfieldForProductType(tags, typeKey);
      if (typeKey !== 'medicament') {
        if (isMedicationOnlyUserfieldHaystack(haystack)) visible = false;
      }
      if (typeKey === 'parent') {
        const isBrandOrSubBrandField = haystack.includes('sous-marque')
          || haystack.includes('sub-brand')
          || haystack.includes('subbrand')
          || haystack.includes('marque')
          || haystack.includes('brand');
        if (isBrandOrSubBrandField) visible = false;
      }
      group.classList.toggle('grocy-product-type-hidden', !visible);
      setGroupRequiredState(group, visible);
    });
  }

  function hideInternalNoOwnStockGroup() {
    const noOwnStock = productNoOwnStockCheckbox();
    const noOwnStockGroup = noOwnStock ? noOwnStock.closest('.form-group') : null;
    if (noOwnStockGroup) {
      noOwnStockGroup.classList.add('grocy-parent-internal-hidden');
    }
  }

  function parentModeForcedHintMatch(textInput = '') {
    const text = norm(textInput || '');
    if (!text) return false;
    if (text.includes('deja assigne') && text.includes('parent') && text.includes('autre produit')) return true;
    if (text.includes('already assigned as parent')) return true;
    if (text.includes('already assigned') && text.includes('parent') && text.includes('another product')) return true;
    if (text.includes('assigned as parent') && text.includes('another product')) return true;
    return false;
  }

  function parentModeHintTextsFromNode(node) {
    if (!node || node.nodeType !== 1) return [];
    const texts = [];
    const attrs = [
      'title',
      'data-original-title',
      'data-bs-original-title',
      'data-content',
      'aria-label',
      'data-title',
      'data-tooltip',
      'data-tippy-content',
    ];
    attrs.forEach((attr) => {
      const value = clean(node.getAttribute && node.getAttribute(attr) ? node.getAttribute(attr) : '');
      if (value) texts.push(value);
    });
    const ownText = clean(node.textContent || '');
    if (ownText && ownText.length <= 260) texts.push(ownText);
    return texts;
  }

  function isParentModeForcedByDependency() {
    const form = productFormElement();
    if (!form) return false;
    const noOwnStock = productNoOwnStockCheckbox();
    const noOwnStockGroup = noOwnStock ? noOwnStock.closest('.form-group') : null;
    const parentGroup = productParentSourceGroup();
    const roots = [];
    if (parentGroup) roots.push(parentGroup);
    if (noOwnStockGroup && noOwnStockGroup !== parentGroup) roots.push(noOwnStockGroup);
    roots.push(form);
    const selector = [
      '[title]',
      '[data-original-title]',
      '[data-bs-original-title]',
      '[data-content]',
      '[aria-label]',
      '[data-title]',
      '[data-tooltip]',
      '[data-tippy-content]',
      '.tooltip-inner',
      '.invalid-feedback',
      '.text-danger',
      '.text-warning',
      '.help-block',
    ].join(',');
    const seen = new Set();
    for (const root of roots) {
      if (!root || !root.querySelectorAll) continue;
      const nodes = [root, ...Array.from(root.querySelectorAll(selector))];
      for (const node of nodes) {
        if (!node || seen.has(node)) continue;
        seen.add(node);
        const texts = parentModeHintTextsFromNode(node);
        for (const text of texts) {
          if (parentModeForcedHintMatch(text)) return true;
        }
      }
    }
    return false;
  }

  function applyParentModeForcedLock() {
    const parentSource = productParentSourceCheckbox();
    const noOwnStock = productNoOwnStockCheckbox();
    const disableOpen = productDisableOpenCheckbox();
    if (!parentSource && !noOwnStock) return false;
    const forceParentMode = isParentModeForcedByDependency();
    const syncControl = (control) => {
      if (!control) return;
      if (forceParentMode) {
        if (control.checked !== true) {
          control.checked = true;
        }
        control.disabled = true;
        control.dataset.parentForcedLock = '1';
      } else if (control.dataset.parentForcedLock === '1') {
        control.disabled = false;
        delete control.dataset.parentForcedLock;
      }
    };
    syncControl(parentSource);
    syncControl(noOwnStock);
    if (disableOpen) {
      if (isProductParentModeEnabled() && disableOpen.checked !== true) {
        disableOpen.checked = true;
      }
      disableOpen.disabled = isProductParentModeEnabled();
    }
    scheduleProductParentPersist();
    return forceParentMode;
  }

  function syncProductParentModeState(source = 'parent_source') {
    if (S.productFormRuleSyncing) return;
    const parentSource = productParentSourceCheckbox();
    const noOwnStock = productNoOwnStockCheckbox();
    if (!parentSource && !noOwnStock) return;

    S.productFormRuleSyncing = true;
    try {
      if (source === 'no_own_stock') {
        const desired = !!(noOwnStock && noOwnStock.checked);
        if (parentSource && parentSource.checked !== desired) {
          parentSource.checked = desired;
        }
        return;
      }

      if (!parentSource) return;
      const desired = !!parentSource.checked;
      if (noOwnStock && noOwnStock.checked !== desired) {
        noOwnStock.checked = desired;
        noOwnStock.dispatchEvent(new Event('input', { bubbles: true }));
        noOwnStock.dispatchEvent(new Event('change', { bubbles: true }));
      }
    } finally {
      S.productFormRuleSyncing = false;
    }
  }

  function bindParentModeSourceListeners() {
    const parentSource = productParentSourceCheckbox();
    const noOwnStock = productNoOwnStockCheckbox();
    if (parentSource && parentSource.dataset.parentModeBound !== '1') {
      parentSource.dataset.parentModeBound = '1';
      parentSource.addEventListener('change', () => {
        if (S.productFormRuleSyncing) return;
        applyParentModeForcedLock();
        syncProductParentModeState('parent_source');
        applyProductFormTypeRules();
      });
      parentSource.addEventListener('input', () => {
        if (S.productFormRuleSyncing) return;
        applyParentModeForcedLock();
        syncProductParentModeState('parent_source');
        applyProductFormTypeRules();
      });
    }
    if (noOwnStock && noOwnStock.dataset.parentModeBound !== '1') {
      noOwnStock.dataset.parentModeBound = '1';
      noOwnStock.addEventListener('change', () => {
        if (S.productFormRuleSyncing) return;
        applyParentModeForcedLock();
        syncProductParentModeState('no_own_stock');
        applyProductFormTypeRules();
      });
      noOwnStock.addEventListener('input', () => {
        if (S.productFormRuleSyncing) return;
        applyParentModeForcedLock();
        syncProductParentModeState('no_own_stock');
        applyProductFormTypeRules();
      });
    }
  }

  function applyParentModeStructuralRules(parentModeInput = null) {
    const parentMode = parentModeInput === null ? isProductParentModeEnabled() : parentModeInput === true;

    const barcodeRow = productBarcodeSectionRow();
    const barcodeTitleWrap = productBarcodeTitleWrap();
    const barcodeHeadlineInfo = productBarcodeHeadlineInfoNode();
    const barcodeTableContainer = productBarcodeTableContainer();
    const grocycodeRow = productGrocycodeSectionRow();
    const conversionsRow = productSpecificConversionsRow();
    const conversionsCol = conversionsRow && conversionsRow.closest ? conversionsRow.closest('.col') : null;
    setParentModeNodeHidden(barcodeRow, parentMode);
    setParentModeNodeHidden(barcodeTitleWrap, parentMode);
    setParentModeNodeHidden(barcodeHeadlineInfo, parentMode);
    setParentModeNodeHidden(barcodeTableContainer, parentMode);
    setParentModeNodeHidden(grocycodeRow, parentMode);
    setParentModeNodeHidden(conversionsRow, false);
    if (conversionsRow && conversionsRow.classList) {
      conversionsRow.classList.toggle('grocy-parent-conversions-tight-top', parentMode);
    }
    if (conversionsCol && conversionsCol.classList) {
      conversionsCol.classList.toggle('grocy-parent-conversions-tight-top', parentMode);
    }

    const parentPickerGroup = productParentPickerGroup();
    const parentPickerSelect = productParentPickerSelect();
    setParentModeNodeHidden(parentPickerGroup, parentMode);
    if (parentMode && parentPickerSelect && clean(parentPickerSelect.value || '') !== '') {
      parentPickerSelect.value = '';
      if (window.jQuery && typeof window.jQuery === 'function') {
        try { window.jQuery(parentPickerSelect).trigger('change'); } catch (_err) {}
      }
      parentPickerSelect.dispatchEvent(new Event('input', { bubbles: true }));
      parentPickerSelect.dispatchEvent(new Event('change', { bubbles: true }));
    }

    const keepVisibleInParent = [
      'default_consume_location_id',
      'move_on_open',
      'default_best_before_days',
      'default_best_before_days_after_open',
      'default_best_before_days_after_freezing',
      'default_best_before_days_after_thawing',
      'should_not_be_frozen',
      'quick_consume_amount',
      'quick_open_amount',
      'disable_open',
      'enable_tare_weight_handling',
      'tare_weight',
    ];
    keepVisibleInParent.forEach((inputId) => {
      setParentModeNodeHidden(productFormGroupByInputId(inputId), false);
    });

    const disableOpen = productDisableOpenCheckbox();
    if (disableOpen) {
      if (parentMode && disableOpen.checked !== true) {
        disableOpen.checked = true;
      }
      disableOpen.disabled = parentMode;
    }

    [
      'location_id',
      'shopping_location_id',
      'min_stock_amount',
    ].forEach((inputId) => {
      setParentModeNodeDimmed(productFormGroupByInputId(inputId), false);
    });
  }

  function applyProductFormTypeRules() {
    if (!isProductFormPage()) return;
    spreadProductUserfieldsByUtility();
    applyParentSourcePresentation();
    hideInternalNoOwnStockGroup();
    bindParentModeSourceListeners();
    applyParentModeForcedLock();
    syncProductParentModeState('parent_source');

    const parentMode = isProductParentModeEnabled();
    const typeKey = currentProductTypeKey();
    const form = productFormElement();
    if (form) {
      form.dataset.grocyProductType = typeKey;
      form.dataset.grocyParentMode = parentMode ? '1' : '0';
    }

    applyParentModeStructuralRules(parentMode);
    applyProductUserfieldTypeRules(typeKey);
    applyProductEnergyVisibilityRules();
    scheduleProductParentPersist();

    const barcodeActions = document.querySelector('.grocy-off-heading-actions');
    if (barcodeActions) {
      const hasBarcodeTable = !!document.getElementById('barcode-table');
      barcodeActions.classList.toggle('d-none', parentMode || !hasBarcodeTable);
    }
    const barcodeStatus = document.getElementById('grocy-barcode-header-status');
    if (barcodeStatus && parentMode) {
      barcodeStatus.textContent = '';
      barcodeStatus.classList.add('d-none');
    }

    if (typeof S.productBarcodesHeaderRefresh === 'function') {
      try { S.productBarcodesHeaderRefresh(); } catch (_err) {}
    }
    if (typeof S.productEnergyRobotRefresh === 'function') {
      try { S.productEnergyRobotRefresh(); } catch (_err) {}
    }
    if (typeof S.productImageSearchRefresh === 'function') {
      try { S.productImageSearchRefresh(); } catch (_err) {}
    }
  }

  function initProductFormTypeRules() {
    if (!isProductFormPage()) {
      S.productFormTypeRulesRefresh = null;
      return;
    }
    initProductFormTypeRulesStyle();
    spreadProductUserfieldsByUtility();
    bindParentModeSourceListeners();
    const groupSelect = currentProductGroupSelectElement();
    if (groupSelect && groupSelect.dataset.productTypeRulesBound !== '1') {
      groupSelect.dataset.productTypeRulesBound = '1';
      groupSelect.addEventListener('input', applyProductFormTypeRules);
      groupSelect.addEventListener('change', applyProductFormTypeRules);
    }
    S.productFormTypeRulesRefresh = applyProductFormTypeRules;
    applyProductFormTypeRules();
  }

  function productNameFromMainForm() {
    const input = document.getElementById('name');
    return input ? clean(input.value) : '';
  }

  function makeOpenFoodFactsSearchUrl(productName, providerIdInput = '') {
    return makeFactsSearchByNameUrl(productName, providerIdInput);
  }

  function makeGoogleOpenFoodFactsUrl(productName, providerIdInput = '') {
    return makeGoogleFactsUrl(productName, providerIdInput);
  }

  function currentEditedProductId() {
    try {
      const fromGrocy = num(window?.Grocy?.EditObjectProduct?.id);
      if (fromGrocy > 0) return fromGrocy;
    } catch (_err) {}
    const match = clean(window.location.pathname).match(/\/product\/(\d+)\/?$/);
    return match ? num(match[1]) : 0;
  }

  function currentProductStockUnitId() {
    const selectors = [
      '#qu_id_stock',
      'select[name="qu_id_stock"]',
      'select[id*="qu_id_stock"]',
    ];
    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (!element) continue;
      if (element.closest && element.closest('form#barcode-form')) continue;
      const unitId = num(element.value || element.getAttribute('value') || 0);
      if (unitId > 0) return unitId;
    }
    return 0;
  }

  function currentProductPurchaseUnitId() {
    const selectors = [
      '#qu_id_purchase',
      'select[name="qu_id_purchase"]',
      'select[id*="qu_id_purchase"]',
    ];
    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (!element) continue;
      if (element.closest && element.closest('form#barcode-form')) continue;
      const unitId = num(element.value || element.getAttribute('value') || 0);
      if (unitId > 0) return unitId;
    }
    try {
      const fromGrocy = num(window?.Grocy?.EditObjectProduct?.qu_id_purchase);
      if (fromGrocy > 0) return fromGrocy;
    } catch (_err) {}
    return 0;
  }

  function currentProductGroupSelectElement() {
    const selectors = [
      '#product_group_id',
      'select[name="product_group_id"]',
      'select[id*="product_group_id"]',
      'select[id*="product_group"]',
      'select[name*="product_group"]',
    ];
    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (!element) continue;
      if (element.closest && element.closest('form#barcode-form')) continue;
      return element;
    }
    return null;
  }

  function currentProductGroupLabel() {
    const select = currentProductGroupSelectElement();
    if (!select) return '';
    const selected = select.options && select.selectedIndex >= 0 ? select.options[select.selectedIndex] : null;
    return clean(selected ? selected.textContent : '');
  }

  function isNonEdibleProductGroupLabel(labelInput = '') {
    const labelNorm = norm(labelInput || '');
    if (!labelNorm) return false;
    const markers = [
      'medicament',
      'medicaments',
      'medication',
      'medicine',
      'drug',
      'pharma',
      'hygiene',
      'soin personnel',
      'soins personnels',
      'personal care',
      'toiletr',
      'cosmetic',
      'entretien',
      'cleaning',
      'household',
      'detergent',
      'lessive',
      'nettoy',
    ];
    return markers.some((marker) => labelNorm.includes(marker));
  }

  function shouldHideEnergyForCurrentGroup() {
    if (isProductParentModeEnabled()) return true;
    const groupLabel = currentProductGroupLabel();
    return isNonEdibleProductGroupLabel(groupLabel);
  }

  function forceCaloriesInputToZero(inputNode) {
    const input = inputNode || document.getElementById('calories');
    if (!input) return false;
    const current = num(input.value || input.getAttribute('value') || 0);
    if (!(current > 0)) return false;
    input.value = '0';
    input.dispatchEvent(new Event('input', { bubbles: true }));
    input.dispatchEvent(new Event('change', { bubbles: true }));
    return true;
  }

  function applyProductEnergyVisibilityRules(optionsInput = null) {
    if (!isProductFormPage()) return false;
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const caloriesInput = options.caloriesInput || document.getElementById('calories');
    if (!caloriesInput) return false;
    const caloriesGroup = options.caloriesGroup || caloriesInput.closest('.form-group');
    const caloriesLabel = options.caloriesLabel
      || (caloriesGroup && caloriesGroup.querySelector('label[for="calories"]'))
      || document.querySelector('label[for="calories"]');
    const robotButton = options.robotButton || null;
    const actionsNode = options.actionsNode || null;
    const statusNode = options.statusNode || null;
    const shouldHide = shouldHideEnergyForCurrentGroup() || isProductParentModeEnabled();

    if (shouldHide) {
      forceCaloriesInputToZero(caloriesInput);
    }

    if (caloriesGroup) {
      caloriesGroup.classList.toggle('d-none', shouldHide);
    } else if (caloriesLabel) {
      caloriesLabel.classList.toggle('d-none', shouldHide);
      const inputWrap = caloriesInput.closest('.input-group, .numberpicker, .form-control');
      if (inputWrap && inputWrap.classList) inputWrap.classList.toggle('d-none', shouldHide);
    }

    if (actionsNode) actionsNode.classList.toggle('d-none', shouldHide);
    if (robotButton) {
      robotButton.classList.toggle('d-none', shouldHide);
      if (shouldHide) robotButton.disabled = true;
    }
    if (statusNode && shouldHide) {
      statusNode.textContent = '';
      statusNode.classList.add('d-none');
    }
    return shouldHide;
  }

  function initProductEnergyVisibilityGuard() {
    if (!isProductFormPage()) return;
    const caloriesInput = document.getElementById('calories');
    if (!caloriesInput) return;
    const caloriesGroup = caloriesInput.closest('.form-group');
    const caloriesLabel = (caloriesGroup && caloriesGroup.querySelector('label[for="calories"]'))
      || document.querySelector('label[for="calories"]');
    const groupSelect = currentProductGroupSelectElement();

    const apply = () => {
      applyProductEnergyVisibilityRules({
        caloriesInput,
        caloriesGroup,
        caloriesLabel,
      });
    };

    apply();

    if (groupSelect && groupSelect.dataset.energyVisibilityBound !== '1') {
      groupSelect.dataset.energyVisibilityBound = '1';
      groupSelect.addEventListener('change', apply);
      groupSelect.addEventListener('input', apply);
    }
  }

  function currentProductStockUnitLabel() {
    const selectors = [
      '#qu_id_stock',
      'select[name="qu_id_stock"]',
      'select[id*="qu_id_stock"]',
    ];
    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (!element) continue;
      if (element.closest && element.closest('form#barcode-form')) continue;
      const selected = element.options && element.selectedIndex >= 0 ? element.options[element.selectedIndex] : null;
      const label = clean(selected ? selected.textContent : '');
      if (label) return label;
    }
    return t('default_na');
  }

  function currentProductPurchaseUnitLabel() {
    const selectors = [
      '#qu_id_purchase',
      'select[name="qu_id_purchase"]',
      'select[id*="qu_id_purchase"]',
    ];
    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (!element) continue;
      if (element.closest && element.closest('form#barcode-form')) continue;
      const selected = element.options && element.selectedIndex >= 0 ? element.options[element.selectedIndex] : null;
      const label = clean(selected ? selected.textContent : '');
      if (label) return label;
    }
    return t('default_na');
  }

  function currentProductBarcodeDefaultAmount() {
    const selectors = [
      '#qu_factor_purchase_to_stock',
      'input[name="qu_factor_purchase_to_stock"]',
      '#default_consume_amount',
      'input[name="default_consume_amount"]',
      '#default_amount',
      'input[name="default_amount"]',
    ];
    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (!element) continue;
      if (element.closest && element.closest('form#barcode-form')) continue;
      const value = num(element.value || element.getAttribute('value') || 0);
      if (value > 0) return value;
    }
    try {
      const fromGrocy = num(window?.Grocy?.EditObjectProduct?.qu_factor_purchase_to_stock);
      if (fromGrocy > 0) return fromGrocy;
    } catch (_err) {}
    return 1;
  }

  function currentBarcodeAlreadyExists(codeInput = '') {
    const code = parseBarcodeCandidate(codeInput);
    if (!code) return false;
    return Array.from(document.querySelectorAll('#barcode-table tbody tr td:nth-child(2)'))
      .map((cell) => parseBarcodeCandidate(clean(cell && cell.textContent ? cell.textContent : '')))
      .some((existing) => existing && existing === code);
  }

  function csrfTokenFromPage() {
    const selectors = [
      'meta[name="csrf-token"]',
      'meta[name="csrf_token"]',
      'input[name="_csrf_token"]',
      'input[name="csrf_token"]',
    ];
    for (const selector of selectors) {
      const element = document.querySelector(selector);
      if (!element) continue;
      const token = clean(element.getAttribute('content') || element.value || '');
      if (token) return token;
    }
    return '';
  }

  async function postJson(relativePath, payloadInput = {}) {
    const path = relativePath.startsWith('/') ? relativePath.slice(1) : relativePath;
    const payload = payloadInput && typeof payloadInput === 'object' ? payloadInput : {};
    const headers = {
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
    const csrfToken = csrfTokenFromPage();
    if (csrfToken) {
      headers['X-CSRF-Token'] = csrfToken;
      headers['x-csrf-token'] = csrfToken;
    }
    const response = await fetch(`${apiBaseUrl()}${path}`, {
      method: 'POST',
      credentials: 'same-origin',
      headers,
      body: JSON.stringify(payload),
    });
    if (!response.ok) {
      let detail = '';
      try {
        const text = await response.text();
        const trimmed = clean(text);
        if (trimmed) {
          try {
            const json = JSON.parse(text);
            detail = clean(json?.error_message || json?.error || json?.message || '') || trimmed.slice(0, 220);
          } catch (_err) {
            detail = trimmed.slice(0, 220);
          }
        }
      } catch (_bodyErr) {}
      throw new Error(`HTTP ${response.status}${detail ? ` - ${detail}` : ''}`);
    }
    try {
      return await response.json();
    } catch (_err) {
      return {};
    }
  }

  async function putJson(relativePath, payloadInput = {}) {
    const path = relativePath.startsWith('/') ? relativePath.slice(1) : relativePath;
    const payload = payloadInput && typeof payloadInput === 'object' ? payloadInput : {};
    const headers = {
      Accept: 'application/json',
      'Content-Type': 'application/json',
    };
    const csrfToken = csrfTokenFromPage();
    if (csrfToken) {
      headers['X-CSRF-Token'] = csrfToken;
      headers['x-csrf-token'] = csrfToken;
    }
    const response = await fetch(`${apiBaseUrl()}${path}`, {
      method: 'PUT',
      credentials: 'same-origin',
      headers,
      body: JSON.stringify(payload),
    });
    if (!response.ok) {
      let detail = '';
      try {
        const text = await response.text();
        const trimmed = clean(text);
        if (trimmed) {
          try {
            const json = JSON.parse(text);
            detail = clean(json?.error_message || json?.error || json?.message || '') || trimmed.slice(0, 220);
          } catch (_err) {
            detail = trimmed.slice(0, 220);
          }
        }
      } catch (_bodyErr) {}
      throw new Error(`HTTP ${response.status}${detail ? ` - ${detail}` : ''}`);
    }
    try {
      return await response.json();
    } catch (_err) {
      return {};
    }
  }

  async function createProductBarcodeViaApi({
    productId,
    barcode,
    quId,
    amount = 1,
    shoppingLocationId = null,
  }) {
    const payload = {
      product_id: num(productId),
      barcode: clean(barcode),
      qu_id: num(quId),
      amount: num(amount),
      shopping_location_id: shoppingLocationId === null ? null : num(shoppingLocationId),
    };
    if (payload.product_id <= 0) throw new Error(t('barcode_header_robot_need_product_id'));
    if (!payload.barcode) throw new Error(langText('Code-barres vide.', 'Empty barcode.'));
    if (payload.qu_id <= 0) throw new Error(t('barcode_header_robot_need_unit'));
    if (!(payload.amount > 0)) payload.amount = 1;
    return postJson('api/objects/product_barcodes', payload);
  }

  function refreshBarcodeTableUi() {
    const table = document.getElementById('barcode-table');
    if (!table) return;
    try {
      if (window.jQuery && window.jQuery.fn && typeof window.jQuery.fn.DataTable === 'function') {
        const dtTable = window.jQuery(table).DataTable();
        if (dtTable) {
          const settings = typeof dtTable.settings === 'function' ? dtTable.settings() : null;
          const hasAjaxSource = !!(settings && settings.length > 0 && settings[0] && settings[0].ajax);
          if (hasAjaxSource && dtTable.ajax && typeof dtTable.ajax.reload === 'function') {
            dtTable.ajax.reload(null, false);
          } else if (typeof dtTable.draw === 'function') {
            dtTable.draw(false);
          }
        }
      }
    } catch (_err) {}
  }

  async function lookupBestBarcodeForProductName(productNameInput, settingsInput = null) {
    const productName = clean(productNameInput || '');
    if (!productName) {
      throw new Error(langText('Nom du produit introuvable.', 'Product name not found.'));
    }
    const settings = normalizeBarcodeLookupSettings(settingsInput || barcodeLookupSettings());
    if (settings.enabled !== true) {
      throw new Error(t('facts_provider_disabled'));
    }
    const lookup = await fetchBarcodeLookupProductsByNameWithFallback(productName, settings);
    const best = bestBarcodeLookupMatch(lookup.products, productName);
    if (!best) {
      const attempted = Array.isArray(lookup.attemptedProviders) && lookup.attemptedProviders.length > 0
        ? lookup.attemptedProviders.map((providerId) => barcodeLookupProviderLabel(providerId)).join(' -> ')
        : lookup.providerLabel;
      throw new Error(langText(`Aucun code-barres fiable trouvé via ${attempted}.`, `No reliable barcode found via ${attempted}.`));
    }
    const attemptedProviders = Array.isArray(lookup.attemptedProviders) && lookup.attemptedProviders.length > 0
      ? lookup.attemptedProviders
      : [lookup.provider];
    return { best, lookup, attemptedProviders };
  }

  async function lookupBestBarcodeForProductNameFallbackChain(productNameInput, settingsInput = null, optionsInput = {}) {
    const settings = normalizeBarcodeLookupSettings(settingsInput || barcodeLookupSettings());
    const options = optionsInput && typeof optionsInput === 'object' ? optionsInput : {};
    const variants = buildProductNameFallbackVariants(productNameInput, options.limit || 14);
    if (!variants.length) {
      throw new Error(langText('Nom du produit introuvable.', 'Product name not found.'));
    }

    const failures = [];
    for (let i = 0; i < variants.length; i += 1) {
      const currentName = variants[i];
      try {
        const result = await lookupBestBarcodeForProductName(currentName, settings);
        return { ...result, usedName: currentName, triedNames: variants.slice(0, i + 1) };
      } catch (error) {
        const msg = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
        if (!isLookupNotFoundMessage(msg) && !isFactsProductTypeMismatchDetail(msg)) {
          failures.push(msg);
        }
      }
    }

    if (failures.length > 0) {
      throw new Error(failures[0]);
    }
    throw new Error(langText(
      'Aucun résultat après simplification progressive du nom.',
      'No result after progressive product name simplification.'
    ));
  }

  function openNewTab(url) {
    window.open(url, '_blank', 'noopener');
  }

  function duckDuckGoIconUrl(domain) {
    const host = clean(domain || '');
    if (!host) return '';
    return `https://icons.duckduckgo.com/ip3/${encodeURIComponent(host)}.ico`;
  }

  function initProductBarcodesHeaderButtons() {
    if (!isProductEditPage()) {
      S.productBarcodesHeaderRefresh = null;
      return;
    }
    const barcodeTable = document.getElementById('barcode-table');
    if (!barcodeTable) return;
    const barcodeSection = barcodeTable.closest('.col');
    if (!barcodeSection) return;
    const titleWrap = barcodeSection.querySelector('.title-related-links');
    if (!titleWrap) return;
    const heading = titleWrap.querySelector('h4');
    if (!heading) return;

    initOpenFoodFactsToolsStyle();

    let actions = heading.querySelector('.grocy-off-heading-actions');
    if (!actions) {
      actions = document.createElement('span');
      actions.className = 'grocy-off-heading-actions';
      heading.appendChild(actions);
    }

    let offButton = actions.querySelector('[data-facts-open-off]');
    if (!offButton) {
      offButton = document.createElement('button');
      offButton.type = 'button';
      offButton.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm';
      offButton.setAttribute('data-facts-open-off', '1');
      actions.appendChild(offButton);
    }

    let opfButton = actions.querySelector('[data-facts-open-opf]');
    if (!opfButton) {
      opfButton = document.createElement('button');
      opfButton.type = 'button';
      opfButton.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm';
      opfButton.setAttribute('data-facts-open-opf', '1');
      actions.appendChild(opfButton);
    }

    let robotButton = actions.querySelector('[data-facts-robot-create]');
    if (!robotButton) {
      robotButton = document.createElement('button');
      robotButton.type = 'button';
      robotButton.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm grocy-off-btn-icon';
      robotButton.setAttribute('data-facts-robot-create', '1');
      robotButton.innerHTML = '<i class="fa-solid fa-robot"></i>';
      actions.appendChild(robotButton);
    }

    let robotRetryButton = actions.querySelector('[data-facts-robot-retry]');
    if (robotRetryButton && robotRetryButton.parentNode) {
      robotRetryButton.parentNode.removeChild(robotRetryButton);
    }
    robotRetryButton = null;

    let googleButton = actions.querySelector('[data-facts-google]');
    if (!googleButton) {
      googleButton = document.createElement('button');
      googleButton.type = 'button';
      googleButton.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm grocy-off-btn-icon';
      googleButton.setAttribute('data-facts-google', '1');
      actions.appendChild(googleButton);
    }
    googleButton.innerHTML = `<img class="grocy-off-ddg-icon" src="${duckDuckGoIconUrl('google.com')}" alt="Google">`;
    const googleImg = googleButton.querySelector('img');
    if (googleImg && googleButton.dataset.googleImgBound !== '1') {
      googleButton.dataset.googleImgBound = '1';
      googleImg.addEventListener('error', () => {
        googleButton.textContent = 'G';
      });
    }

    let headingStatus = titleWrap.querySelector('#grocy-barcode-header-status');
    if (!headingStatus) {
      headingStatus = document.createElement('div');
      headingStatus.id = 'grocy-barcode-header-status';
      headingStatus.className = 'grocy-off-heading-status text-muted d-none';
      titleWrap.appendChild(headingStatus);
    }
    headingStatus.dataset.terminalSource = langText('Code-barres', 'Barcodes');

    let selectedCard = titleWrap.querySelector('#grocy-barcode-header-selected-card');
    if (!selectedCard) {
      selectedCard = document.createElement('div');
      selectedCard.id = 'grocy-barcode-header-selected-card';
      selectedCard.className = 'grocy-barcode-robot-card d-none';
      titleWrap.appendChild(selectedCard);
    }

    const setHeadingStatus = (text = '', tone = 'muted', detailsInput = null) => {
      const msg = clean(text);
      if (!msg) {
        headingStatus.textContent = '';
        headingStatus.classList.add('d-none');
        return;
      }
      headingStatus.classList.remove('d-none');
      setBarcodeAutofillStatus(headingStatus, text, tone, detailsInput);
    };

    const refreshState = () => {
      const parentMode = isProductParentModeEnabled();
      const hasBarcodeTable = !!document.getElementById('barcode-table');
      const hasName = productNameFromMainForm() !== '';
      const settings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
      const productId = currentEditedProductId();
      const purchaseUnitId = currentProductPurchaseUnitId();

      actions.classList.toggle('d-none', parentMode || !hasBarcodeTable);
      if (parentMode || !hasBarcodeTable) {
        setHeadingStatus('', 'muted');
        renderBarcodeRobotSelectionCard(selectedCard, null);
        return;
      }

      applyFactsIconToButton(offButton, 'openfoodfacts', 'OFF');
      applyFactsIconToButton(opfButton, 'openproductsfacts', 'OPF');
      offButton.title = t('barcode_header_open_off_title');
      offButton.setAttribute('aria-label', offButton.title);
      opfButton.title = t('barcode_header_open_opf_title');
      opfButton.setAttribute('aria-label', opfButton.title);
      googleButton.title = t('barcode_header_google_title');
      googleButton.setAttribute('aria-label', googleButton.title);
      robotButton.title = t('barcode_header_robot_title');
      robotButton.setAttribute('aria-label', robotButton.title);
      offButton.disabled = !hasName;
      opfButton.disabled = !hasName;
      googleButton.disabled = !hasName;
      robotButton.disabled = !hasName || settings.enabled !== true || productId <= 0 || purchaseUnitId <= 0;

      if (robotButton.disabled && settings.enabled !== true) {
        setHeadingStatus(t('facts_provider_disabled'), 'muted');
      } else if (robotButton.disabled && purchaseUnitId <= 0 && hasName) {
        setHeadingStatus(t('barcode_header_robot_need_unit'), 'muted');
      } else if (headingStatus && !clean(headingStatus.textContent)) {
        setHeadingStatus('', 'muted');
      }
    };

    if (offButton.dataset.factsBound !== '1') {
      offButton.dataset.factsBound = '1';
      offButton.addEventListener('click', () => {
        if (isProductParentModeEnabled()) return;
        const productName = productNameFromMainForm();
        if (!productName) return;
        const url = makeOpenFoodFactsSearchUrl(productName, 'openfoodfacts');
        if (!url) return;
        openNewTab(url);
      });
    }

    if (opfButton.dataset.factsBound !== '1') {
      opfButton.dataset.factsBound = '1';
      opfButton.addEventListener('click', () => {
        if (isProductParentModeEnabled()) return;
        const productName = productNameFromMainForm();
        if (!productName) return;
        const url = makeOpenFoodFactsSearchUrl(productName, 'openproductsfacts');
        if (!url) return;
        openNewTab(url);
      });
    }

    if (googleButton.dataset.factsBound !== '1') {
      googleButton.dataset.factsBound = '1';
      googleButton.addEventListener('click', () => {
        if (isProductParentModeEnabled()) return;
        const productName = productNameFromMainForm();
        if (!productName) return;
        const providerId = barcodeLookupProviderFromSettings();
        const url = makeGoogleOpenFoodFactsUrl(productName, providerId);
        if (!url) return;
        openNewTab(url);
      });
    }

    const runHeaderRobotCreate = async (useFallbackChain = false) => {
        if (isProductParentModeEnabled()) {
          setHeadingStatus(langText('Mode parent actif: section code-barres masquée.', 'Parent mode active: barcode section hidden.'), 'warning');
          renderBarcodeRobotSelectionCard(selectedCard, null);
          refreshState();
          return;
        }
        const productName = productNameFromMainForm();
        if (!productName) {
          setHeadingStatus(langText('Nom du produit introuvable.', 'Product name not found.'), 'danger');
          renderBarcodeRobotSelectionCard(selectedCard, null);
          refreshState();
          return;
        }

        const productId = currentEditedProductId();
        if (productId <= 0) {
          setHeadingStatus(t('barcode_header_robot_need_product_id'), 'danger');
          renderBarcodeRobotSelectionCard(selectedCard, null);
          refreshState();
          return;
        }

        const purchaseUnitId = currentProductPurchaseUnitId();
        const purchaseUnitName = currentProductPurchaseUnitLabel();
        if (purchaseUnitId <= 0) {
          setHeadingStatus(t('barcode_header_robot_need_unit'), 'danger');
          renderBarcodeRobotSelectionCard(selectedCard, null);
          refreshState();
          return;
        }

        const settings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
        if (settings.enabled !== true) {
          setHeadingStatus(t('facts_provider_disabled'), 'danger');
          renderBarcodeRobotSelectionCard(selectedCard, null);
          refreshState();
          return;
        }

        const configuredProviderOrder = barcodeLookupProviderOrder(settings);
        let shouldReload = false;
        let finalError = '';
        let usedName = '';
        let bestName = '';
        let bestCode = '';
        let createdAmount = 0;
        let attemptedProviders = [];
        let autoRetried = false;
        let effectiveFallback = useFallbackChain === true;
        setButtonBusy(robotButton, true);
        setHeadingStatus(
          langText('1/3 Recherche du code-barres…', '1/3 Searching barcode...'),
          'info',
          [
            `${langText('Produit', 'Product')}: ${productName}`,
            `${langText('Unité utilisée', 'Used unit')}: ${purchaseUnitName} (#${purchaseUnitId})`,
            `${langText('Fournisseurs configurés', 'Configured providers')}: ${configuredProviderOrder.map((id) => barcodeLookupProviderLabel(id)).join(' -> ') || t('default_na')}`,
            `${langText('Mode', 'Mode')}: ${effectiveFallback ? langText('Relance avec simplification', 'Retry with simplification') : langText('Recherche standard', 'Standard lookup')}`,
          ]
        );
        try {
          let lookup = null;
          if (effectiveFallback) {
            lookup = await lookupBestBarcodeForProductNameFallbackChain(productName, settings, { limit: 14 });
          } else {
            try {
              lookup = await lookupBestBarcodeForProductName(productName, settings);
            } catch (firstError) {
              const firstMsg = clean(firstError && firstError.message ? firstError.message : String(firstError));
              if (!isLookupNotFoundMessage(firstMsg)) throw firstError;
              autoRetried = true;
              effectiveFallback = true;
              setHeadingStatus(
                langText(
                  'Aucun résultat fiable en mode standard, relance simplifiée automatique…',
                  'No reliable result in standard mode, running simplified retry automatically...'
                ),
                'info',
                [
                  `${langText('Produit', 'Product')}: ${productName}`,
                  `${langText('Unité utilisée', 'Used unit')}: ${purchaseUnitName} (#${purchaseUnitId})`,
                  `${langText('Fournisseurs configurés', 'Configured providers')}: ${configuredProviderOrder.map((id) => barcodeLookupProviderLabel(id)).join(' -> ') || t('default_na')}`,
                  `${langText('Mode', 'Mode')}: ${langText('Relance simplifiée auto', 'Automatic simplified retry')}`,
                ]
              );
              lookup = await lookupBestBarcodeForProductNameFallbackChain(productName, settings, { limit: 14 });
            }
          }
          const { best } = lookup;
          renderBarcodeRobotSelectionCard(selectedCard, barcodeRobotSelectionMeta(best, lookup.lookup));
          usedName = clean(lookup.usedName || '');
          bestName = clean(best && best.name ? best.name : '');
          bestCode = clean(best && best.code ? best.code : '');
          attemptedProviders = Array.isArray(lookup.attemptedProviders) && lookup.attemptedProviders.length > 0
            ? lookup.attemptedProviders
            : [];
          if (currentBarcodeAlreadyExists(best.code)) {
            setHeadingStatus(t('barcode_header_robot_exists', { code: best.code }), 'danger');
            finalError = t('barcode_header_robot_exists', { code: best.code });
            return;
          }

          setHeadingStatus(
            langText(`2/3 Création ${best.code}…`, `2/3 Creating ${best.code}...`),
            'info',
            [
              `${langText('Code trouvé', 'Found barcode')}: ${best.code}`,
              `${langText('Nom source', 'Source name')}: ${bestName || t('default_na')}`,
              `${langText('Fournisseurs tentés', 'Attempted providers')}: ${(attemptedProviders.map((id) => barcodeLookupProviderLabel(id)).join(' -> ') || t('default_na'))}`,
            ]
          );
          const amount = currentProductBarcodeDefaultAmount();
          createdAmount = amount;
          await createProductBarcodeViaApi({
            productId,
            barcode: best.code,
            quId: purchaseUnitId,
            amount,
            shoppingLocationId: null,
          });
          const providers = attemptedProviders.map((providerId) => barcodeLookupProviderLabel(providerId)).join(' + ');
          setHeadingStatus(t('barcode_header_robot_created', {
            code: best.code,
            unit: purchaseUnitName,
            amount: fmt(amount, amount % 1 === 0 ? 0 : 3),
            providers,
          }), 'success');
          setHeadingStatus(langText('3/3 Code-barres créé. Rechargement…', '3/3 Barcode created. Reloading...'), 'success');
          shouldReload = true;
        } catch (error) {
          const msg = clean(error && error.message ? error.message : String(error));
          finalError = msg || t('focus_unknown_error');
          renderBarcodeRobotSelectionCard(selectedCard, null);
          setHeadingStatus(
            t('barcode_header_robot_api_error', { msg: finalError }),
            'danger',
            [
              `${langText('Produit', 'Product')}: ${productName}`,
              `${langText('Unité utilisée', 'Used unit')}: ${purchaseUnitName} (#${purchaseUnitId})`,
              `${langText('Erreur', 'Error')}: ${finalError}`,
            ]
          );
        } finally {
          const detailLines = [
            `${langText('Produit', 'Product')}: ${productName}`,
            `${langText('ID produit', 'Product ID')}: ${productId}`,
            `${langText('Mode', 'Mode')}: ${effectiveFallback ? langText('Relance simplifiée', 'Simplified retry') : langText('Standard', 'Standard')}`,
            `${langText('Relance auto', 'Auto retry')}: ${autoRetried ? 'ON' : 'OFF'}`,
            `${langText('Unité appliquée', 'Applied unit')}: ${purchaseUnitName} (#${purchaseUnitId})`,
            `${langText('Nom simplifié', 'Simplified name')}: ${usedName || t('default_na')}`,
            `${langText('Code trouvé', 'Found barcode')}: ${bestCode || t('default_na')}`,
            `${langText('Nom source', 'Source name')}: ${bestName || t('default_na')}`,
            `${langText('Quantité créée', 'Created amount')}: ${createdAmount > 0 ? fmt(createdAmount, createdAmount % 1 === 0 ? 0 : 3) : t('default_na')}`,
            `${langText('Fournisseurs configurés', 'Configured providers')}: ${configuredProviderOrder.map((id) => barcodeLookupProviderLabel(id)).join(' -> ') || t('default_na')}`,
            `${langText('Fournisseurs tentés', 'Attempted providers')}: ${(attemptedProviders.map((id) => barcodeLookupProviderLabel(id)).join(' -> ') || t('default_na'))}`,
            `${langText('Résultat', 'Result')}: ${shouldReload ? langText('Créé', 'Created') : langText('Échec', 'Failed')}`,
          ];
          if (finalError) {
            detailLines.push(`${langText('Erreur finale', 'Final error')}: ${finalError}`);
          }
          pushProductStatusTerminal(
            langText('Données robot code-barres', 'Barcode robot data'),
            'data',
            langText('Code-barres', 'Barcodes'),
            detailLines
          );

          if (shouldReload) {
            S.productStatusTerminalExpanded = true;
            S.productStatusTerminalUnseen = 0;
            saveProductStatusTerminalSettings();
            saveProductStatusTerminalSession({
              expanded: true,
              reason: 'barcode-robot-reload',
            });
            setTimeout(() => {
              window.location.reload();
            }, 450);
            return;
          }
          setButtonBusy(robotButton, false);
          refreshState();
        }
      };
    if (robotButton.dataset.factsBound !== '1') {
      robotButton.dataset.factsBound = '1';
      robotButton.addEventListener('click', async () => {
        runHeaderRobotCreate(false);
      });
    }
    const nameInput = document.getElementById('name');
    if (nameInput && nameInput.dataset.factsHeaderBound !== '1') {
      nameInput.dataset.factsHeaderBound = '1';
      nameInput.addEventListener('input', refreshState);
      nameInput.addEventListener('change', refreshState);
    }
    S.productBarcodesHeaderRefresh = refreshState;
    refreshState();
  }

  function tokenizeName(value) {
    return norm(value)
      .split(/[^a-z0-9]+/)
      .map((t) => clean(t))
      .filter((t) => t.length >= 2);
  }

  function offBarcodeCandidateCode(product) {
    const rawCode = clean(product && product.code ? product.code : '');
    return /^\d{8,14}$/.test(rawCode) ? rawCode : '';
  }

  function offBarcodeCandidateName(product) {
    if (!product || typeof product !== 'object') return '';
    return pickFirstString(product, ['product_name_fr', 'product_name_en', 'product_name', 'generic_name_fr', 'generic_name_en', 'generic_name']);
  }

  function offBarcodeCandidateScore(product, queryName) {
    const code = offBarcodeCandidateCode(product);
    if (!code) return -1;

    const candidateName = offBarcodeCandidateName(product);
    const queryNorm = norm(queryName);
    const candidateNorm = norm(candidateName);
    if (!queryNorm || !candidateNorm) return -1;

    const queryTokens = tokenizeName(queryNorm).filter((token) => token.length >= 3);
    let score = 0;

    if (candidateNorm === queryNorm) score += 140;
    if (candidateNorm.includes(queryNorm) && queryNorm.length >= 4) score += 80;
    if (queryNorm.includes(candidateNorm) && candidateNorm.length >= 4) score += 40;

    for (const token of queryTokens) {
      if (candidateNorm.includes(token)) score += 12;
    }

    const brands = norm(pickFirstString(product, ['brands']));
    for (const token of queryTokens) {
      if (brands && brands.includes(token)) score += 5;
    }

    const countries = Array.isArray(product.countries_tags) ? product.countries_tags : [];
    if (countries.some((entry) => norm(entry).includes('france'))) score += 2;

    return score;
  }

  function barcodeLookupProviderSearchHost(providerId) {
    const id = normalizeBarcodeLookupProvider(providerId);
    if (id === 'openproductsfacts') return 'world.openproductsfacts.org';
    if (id === 'openfoodfacts') return 'world.openfoodfacts.org';
    return '';
  }

  function buildBarcodeLookupSearchApiUrl(providerId, productName) {
    const host = barcodeLookupProviderSearchHost(providerId);
    if (!host) return '';
    const params = new URLSearchParams({
      search_terms: productName,
      search_simple: '1',
      action: 'process',
      json: '1',
      page_size: '24',
    });
    return `https://${host}/cgi/search.pl?${params.toString()}`;
  }

  async function fetchBarcodeLookupProductsByName(productName, providerIdInput = '') {
    const selected = normalizeBarcodeLookupProvider(providerIdInput || barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(selected);
    const url = buildBarcodeLookupSearchApiUrl(selected, productName);
    if (!url) {
      throw new Error(langText('Fournisseur code-barres invalide.', 'Invalid barcode provider.'));
    }

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 18000);

    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: { Accept: 'application/json' },
        signal: controller.signal,
      });
      if (!response.ok) {
        let detail = '';
        try {
          const text = await response.text();
          const trimmed = clean(text);
          if (trimmed) {
            try {
              const payload = JSON.parse(text);
              const statusVerbose = clean(payload?.status_verbose || payload?.error || '');
              if (statusVerbose) detail = statusVerbose;
              else detail = trimmed.slice(0, 220);
            } catch (_jsonErr) {
              detail = trimmed.slice(0, 220);
            }
          }
        } catch (_bodyErr) {}
        if (response.status === 404 && isFactsProductTypeMismatchDetail(detail)) {
          return { products: [], provider: selected, providerLabel, _softNotFound: true };
        }
        throw new Error(`${providerLabel}: HTTP ${response.status}${detail ? ` - ${detail}` : ''}`);
      }
      const payload = await response.json().catch(() => ({}));
      const products = Array.isArray(payload && payload.products) ? payload.products : [];
      return { products, provider: selected, providerLabel };
    } catch (error) {
      if (error && (error.name === 'AbortError' || /aborted/i.test(clean(error.message || '')))) {
        throw new Error(`${providerLabel}: ${langText('timeout (18s)', 'timeout (18s)')}`);
      }
      const message = clean(error && error.message ? error.message : String(error));
      throw new Error(message || `${providerLabel}: ${langText('erreur inconnue', 'unknown error')}`);
    } finally {
      clearTimeout(timeout);
    }
  }

  async function fetchBarcodeLookupProductsByNameWithFallback(productName, settingsInput = null) {
    const settings = normalizeBarcodeLookupSettings(settingsInput || barcodeLookupSettings());
    if (settings.enabled !== true) {
      throw new Error(t('facts_provider_disabled'));
    }
    const order = barcodeLookupProviderOrder(settings);
    const failures = [];
    let lastResult = null;
    for (let i = 0; i < order.length; i += 1) {
      const providerId = order[i];
      try {
        const result = await fetchBarcodeLookupProductsByName(productName, providerId);
        lastResult = result;
        const products = Array.isArray(result.products) ? result.products : [];
        if (products.length > 0) {
          return { ...result, attemptedProviders: order.slice(0, i + 1) };
        }
      } catch (error) {
        const providerLabel = barcodeLookupProviderLabel(providerId);
        const msg = clean(error && error.message ? error.message : String(error)) || t('focus_unknown_error');
        if (!isFactsProductTypeMismatchDetail(msg)) {
          failures.push(`${providerLabel}: ${msg}`);
        }
      }
      if (settings.autoFallback !== true) break;
    }
    if (failures.length > 0 && !lastResult) {
      throw new Error(failures.join(' | '));
    }
    const firstProvider = order[0] || settings.provider;
    return {
      products: [],
      provider: firstProvider,
      providerLabel: barcodeLookupProviderLabel(firstProvider),
      attemptedProviders: order,
    };
  }

  function bestBarcodeLookupMatch(products, productName) {
    if (!Array.isArray(products) || products.length === 0) return null;
    let best = null;
    let bestScore = -Infinity;
    for (const product of products) {
      const score = offBarcodeCandidateScore(product, productName);
      if (score > bestScore) {
        bestScore = score;
        best = product;
      }
    }
    if (!best || bestScore < 18) return null;
    const code = offBarcodeCandidateCode(best);
    if (!code) return null;
    return {
      code,
      name: offBarcodeCandidateName(best),
      product: best,
    };
  }

  function barcodeRobotSelectionMeta(bestInput = null, lookupInput = null) {
    const best = bestInput && typeof bestInput === 'object' ? bestInput : null;
    const lookup = lookupInput && typeof lookupInput === 'object' ? lookupInput : null;
    if (!best) return null;
    const code = parseBarcodeCandidate(best.code || '');
    if (!code) return null;
    const providerId = normalizeBarcodeLookupProvider(lookup && lookup.provider ? lookup.provider : barcodeLookupProviderFromSettings());
    const providerLabel = barcodeLookupProviderLabel(providerId);
    const product = best && best.product && typeof best.product === 'object' ? best.product : null;
    const name = clean(best.name || offBarcodeCandidateName(product) || '');
    const imageUrl = product ? extractFactsImageUrl(product, providerId) : '';
    const sourceUrl = makeFactsProductUrl(code, providerId);
    return {
      code,
      name,
      imageUrl,
      providerId,
      providerLabel,
      sourceUrl,
    };
  }

  function renderBarcodeRobotSelectionCard(cardNodeInput = null, metaInput = null) {
    const cardNode = cardNodeInput && cardNodeInput.nodeType === 1 ? cardNodeInput : null;
    if (!cardNode) return;
    const meta = metaInput && typeof metaInput === 'object' ? metaInput : null;
    if (!meta || !clean(meta.code || '')) {
      cardNode.innerHTML = '';
      cardNode.classList.add('d-none');
      return;
    }
    const code = clean(meta.code || '');
    const name = clean(meta.name || '');
    const providerLabel = clean(meta.providerLabel || t('default_na'));
    const imageUrl = clean(meta.imageUrl || '');
    const sourceUrl = clean(meta.sourceUrl || '');
    const sourceLabel = langText('Produit sélectionné', 'Selected product');
    const codeLabel = langText('Code', 'Barcode');
    const openLabel = langText('Ouvrir sur la source', 'Open on source');
    const thumbHtml = imageUrl
      ? `<img class="grocy-barcode-robot-card-thumb" src="${escapeHtml(imageUrl)}" alt="${escapeHtml(name || code)}" loading="lazy" referrerpolicy="no-referrer">`
      : `<div class="grocy-barcode-robot-card-thumb grocy-barcode-robot-card-thumb-empty"><i class="fa-solid fa-image"></i></div>`;
    const openHtml = sourceUrl
      ? `<a class="grocy-barcode-robot-card-link" href="${escapeHtml(sourceUrl)}" target="_blank" rel="noopener noreferrer">${escapeHtml(openLabel)}</a>`
      : '';
    cardNode.innerHTML = `
      <div class="grocy-barcode-robot-card-head">${escapeHtml(sourceLabel)}: ${escapeHtml(providerLabel)}</div>
      <div class="grocy-barcode-robot-card-body">
        ${thumbHtml}
        <div class="grocy-barcode-robot-card-meta">
          <div class="grocy-barcode-robot-card-name">${escapeHtml(name || t('default_na'))}</div>
          <div class="grocy-barcode-robot-card-code">${escapeHtml(codeLabel)}: <strong>${escapeHtml(code)}</strong></div>
          ${openHtml}
        </div>
      </div>
    `;
    cardNode.classList.remove('d-none');
  }

  function barcodeFormProductName(form) {
    try {
      if (window.Grocy && window.Grocy.EditObjectProduct && clean(window.Grocy.EditObjectProduct.name)) {
        return clean(window.Grocy.EditObjectProduct.name);
      }
    } catch (_err) {}

    const fromMainForm = productNameFromMainForm();
    if (fromMainForm) return fromMainForm;

    const subtitleStrong = form.querySelector('.text-muted strong');
    if (subtitleStrong && clean(subtitleStrong.textContent)) return clean(subtitleStrong.textContent);

    return '';
  }

  function setBarcodeAutofillStatus(statusNode, text, tone = 'muted', detailsInput = null, sourceInput = '') {
    if (!statusNode) return;
    const msg = clean(text);
    if (msg) {
      const source = clean(sourceInput || statusNode.dataset.terminalSource || '');
      pushProductStatusTerminal(msg, tone, source, detailsInput);
    }
    if (isProductFormPage()) {
      statusNode.textContent = '';
      statusNode.classList.add('d-none');
      return;
    }
    statusNode.classList.remove('d-none', 'text-muted', 'text-info', 'text-success', 'text-danger', 'text-warning');
    const toneClass = tone === 'danger'
      ? 'text-danger'
      : tone === 'warning'
        ? 'text-warning'
      : tone === 'success'
        ? 'text-success'
        : tone === 'info'
          ? 'text-info'
          : 'text-muted';
    statusNode.classList.add(toneClass);
    statusNode.textContent = msg;
  }

  function setButtonBusy(button, busy) {
    if (!button) return;
    if (busy) {
      button.dataset.offOriginalHtml = button.innerHTML;
      button.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
      button.disabled = true;
      return;
    }
    button.innerHTML = button.dataset.offOriginalHtml || '<i class="fa-solid fa-robot"></i>';
    delete button.dataset.offOriginalHtml;
  }

  function initBarcodeAutofillButtonInForm(form) {
    if (!form) return;
    if (form.dataset.offBarcodeAutofillInit === '1') {
      if (typeof form.__offBarcodeRefresh === 'function') {
        try { form.__offBarcodeRefresh(); } catch (_err) {}
      }
      return;
    }
    const barcodeInput = form.querySelector('input#barcode');
    if (!barcodeInput) return;

    const label = form.querySelector('.form-group label');
    if (!label) return;

    form.dataset.offBarcodeAutofillInit = '1';
    initOpenFoodFactsToolsStyle();

    const actions = document.createElement('span');
    actions.className = 'grocy-off-label-actions';

    const robotButton = document.createElement('button');
    robotButton.type = 'button';
    robotButton.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm grocy-off-btn-icon';
    robotButton.innerHTML = '<i class="fa-solid fa-robot"></i>';
    robotButton.title = langText('Remplir automatiquement via l’API code-barres', 'Autofill via barcode API');
    robotButton.setAttribute('aria-label', robotButton.title);

    const assistToggleButton = document.createElement('button');
    assistToggleButton.type = 'button';
    assistToggleButton.className = 'btn btn-outline-secondary btn-sm grocy-off-btn-sm grocy-off-btn-toggle is-off';
    assistToggleButton.setAttribute('aria-pressed', 'false');
    assistToggleButton.innerHTML = '<i class="fa-solid fa-toggle-off"></i>';

    actions.appendChild(robotButton);
    actions.appendChild(assistToggleButton);
    label.appendChild(actions);

    const status = document.createElement('div');
    status.className = 'form-text small grocy-off-autofill-status text-muted';
    status.textContent = '';
    status.dataset.terminalSource = langText('Code-barres', 'Barcodes');
    const firstFormGroup = form.querySelector('.form-group');
    if (firstFormGroup) firstFormGroup.appendChild(status);

    const selectedCard = document.createElement('div');
    selectedCard.className = 'grocy-barcode-robot-card d-none';
    if (firstFormGroup) firstFormGroup.appendChild(selectedCard);

    const refreshAssistToggleUi = () => {
      const settings = normalizeBarcodeAutofillUiSettings(barcodeAutofillUiSettings());
      const enabled = settings.instantAssist === true;
      assistToggleButton.classList.toggle('is-on', enabled);
      assistToggleButton.classList.toggle('is-off', !enabled);
      assistToggleButton.setAttribute('aria-pressed', enabled ? 'true' : 'false');
      assistToggleButton.innerHTML = enabled
        ? '<i class="fa-solid fa-toggle-on"></i>'
        : '<i class="fa-solid fa-toggle-off"></i>';
      assistToggleButton.title = enabled
        ? t('barcode_autofill_assist_on_title')
        : t('barcode_autofill_assist_off_title');
      assistToggleButton.setAttribute('aria-label', `${t('barcode_autofill_assist_name')}: ${enabled ? 'ON' : 'OFF'}`);
    };

    const refreshState = () => {
      const parentMode = isProductParentModeEnabled();
      actions.classList.toggle('d-none', parentMode);
      if (parentMode) {
        setBarcodeAutofillStatus(status, '', 'muted');
        return;
      }
      const hasName = barcodeFormProductName(form) !== '';
      const settings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
      robotButton.disabled = !hasName || settings.enabled !== true;
      refreshAssistToggleUi();
    };
    form.__offBarcodeRefresh = refreshState;

    const runRobotLookup = async (autoRun = false, useFallbackChain = false) => {
      if (isProductParentModeEnabled()) {
        setBarcodeAutofillStatus(status, langText('Mode parent actif: robot code-barres masqué.', 'Parent mode active: barcode robot hidden.'), 'warning');
        renderBarcodeRobotSelectionCard(selectedCard, null);
        refreshState();
        return;
      }
      const productName = barcodeFormProductName(form);
      if (!productName) {
        setBarcodeAutofillStatus(status, langText('Nom du produit introuvable.', 'Product name not found.'), 'danger');
        renderBarcodeRobotSelectionCard(selectedCard, null);
        refreshState();
        return;
      }

      const settings = normalizeBarcodeLookupSettings(barcodeLookupSettings());
      if (settings.enabled !== true) {
        setBarcodeAutofillStatus(status, t('facts_provider_disabled'), 'warning');
        renderBarcodeRobotSelectionCard(selectedCard, null);
        refreshState();
        return;
      }
      const order = barcodeLookupProviderOrder(settings);
      const orderLabel = order.map((providerId) => barcodeLookupProviderLabel(providerId)).join(' -> ');
      let finalError = '';
      let foundCode = '';
      let foundName = '';
      let usedName = '';
      let attemptedProviders = [];
      let matchedProductsCount = 0;
      let autoRetried = false;
      let effectiveFallback = useFallbackChain === true;
      setButtonBusy(robotButton, true);
      const preface = autoRun ? `${t('barcode_autofill_assist_auto_run')} ` : '';
      setBarcodeAutofillStatus(
        status,
        `${preface}${langText(`Recherche ${orderLabel} en cours…`, `Searching ${orderLabel}...`)}`,
        'info',
        [
          `${langText('Produit', 'Product')}: ${productName}`,
          `${langText('Mode', 'Mode')}: ${effectiveFallback ? langText('Relance simplifiée', 'Simplified retry') : langText('Standard', 'Standard')}`,
          `${langText('Auto', 'Auto')}: ${autoRun ? 'ON' : 'OFF'}`,
          `${langText('Chaîne fournisseurs', 'Provider chain')}: ${orderLabel || t('default_na')}`,
        ]
      );

      try {
        let lookup = null;
        if (effectiveFallback) {
          lookup = await lookupBestBarcodeForProductNameFallbackChain(productName, settings, { limit: 14 });
        } else {
          try {
            lookup = await fetchBarcodeLookupProductsByNameWithFallback(productName, settings);
          } catch (firstError) {
            const firstMsg = clean(firstError && firstError.message ? firstError.message : String(firstError));
            if (!isLookupNotFoundMessage(firstMsg)) throw firstError;
            autoRetried = true;
            effectiveFallback = true;
            setBarcodeAutofillStatus(
              status,
              langText(
                'Aucun résultat fiable en mode standard, relance simplifiée automatique…',
                'No reliable result in standard mode, running simplified retry automatically...'
              ),
              'info',
              [
                `${langText('Produit', 'Product')}: ${productName}`,
                `${langText('Mode', 'Mode')}: ${langText('Relance simplifiée auto', 'Automatic simplified retry')}`,
                `${langText('Auto', 'Auto')}: ${autoRun ? 'ON' : 'OFF'}`,
                `${langText('Chaîne fournisseurs', 'Provider chain')}: ${orderLabel || t('default_na')}`,
              ]
            );
            lookup = await lookupBestBarcodeForProductNameFallbackChain(productName, settings, { limit: 14 });
          }
        }
        matchedProductsCount = Array.isArray(lookup && lookup.products) ? lookup.products.length : 0;
        attemptedProviders = Array.isArray(lookup.attemptedProviders) && lookup.attemptedProviders.length > 0
          ? lookup.attemptedProviders
          : [];
        const best = effectiveFallback
          ? lookup.best
          : bestBarcodeLookupMatch(lookup.products, productName);
        usedName = clean(lookup.usedName || '');
        if (!best) {
          renderBarcodeRobotSelectionCard(selectedCard, null);
          const attempted = Array.isArray(lookup.attemptedProviders) && lookup.attemptedProviders.length > 0
            ? lookup.attemptedProviders.map((providerId) => barcodeLookupProviderLabel(providerId)).join(' -> ')
            : lookup.providerLabel;
          finalError = langText(`Aucun code-barres fiable trouvé via ${attempted}.`, `No reliable barcode found via ${attempted}.`);
          setBarcodeAutofillStatus(
            status,
            finalError,
            'danger'
          );
          return;
        }
        renderBarcodeRobotSelectionCard(selectedCard, barcodeRobotSelectionMeta(best, lookup));

        barcodeInput.value = best.code;
        barcodeInput.dispatchEvent(new Event('input', { bubbles: true }));
        barcodeInput.dispatchEvent(new Event('change', { bubbles: true }));

        foundCode = clean(best.code || '');
        foundName = clean(best.name) || langText('produit API', 'API product');
        const attempted = Array.isArray(lookup.attemptedProviders) && lookup.attemptedProviders.length > 0
          ? lookup.attemptedProviders.map((providerId) => barcodeLookupProviderLabel(providerId)).join(' -> ')
          : lookup.providerLabel;
        const note = usedName && norm(usedName) !== norm(productName)
          ? langText(` | nom simplifié: ${usedName}`, ` | simplified name: ${usedName}`)
          : '';
        setBarcodeAutofillStatus(
          status,
          langText(`Code-barres trouvé via ${attempted}: ${best.code} (${foundName}).${note}`, `Barcode found via ${attempted}: ${best.code} (${foundName}).${note}`),
          'success'
        );
      } catch (error) {
        const msg = clean(error && error.message ? error.message : String(error));
        finalError = msg || langText('erreur inconnue', 'unknown error');
        renderBarcodeRobotSelectionCard(selectedCard, null);
        setBarcodeAutofillStatus(
          status,
          langText(`Erreur API code-barres: ${finalError}.`, `Barcode API error: ${finalError}.`),
          'danger'
        );
      } finally {
        const detailLines = [
          `${langText('Produit', 'Product')}: ${productName}`,
          `${langText('Mode', 'Mode')}: ${effectiveFallback ? langText('Relance simplifiée', 'Simplified retry') : langText('Standard', 'Standard')}`,
          `${langText('Relance auto', 'Auto retry')}: ${autoRetried ? 'ON' : 'OFF'}`,
          `${langText('Auto', 'Auto')}: ${autoRun ? 'ON' : 'OFF'}`,
          `${langText('Code trouvé', 'Found barcode')}: ${foundCode || t('default_na')}`,
          `${langText('Nom source', 'Source name')}: ${foundName || t('default_na')}`,
          `${langText('Nom simplifié', 'Simplified name')}: ${usedName || t('default_na')}`,
          `${langText('Résultats candidats', 'Candidate results')}: ${fmt(matchedProductsCount, 0)}`,
          `${langText('Fournisseurs configurés', 'Configured providers')}: ${orderLabel || t('default_na')}`,
          `${langText('Fournisseurs tentés', 'Attempted providers')}: ${(attemptedProviders.map((id) => barcodeLookupProviderLabel(id)).join(' -> ') || t('default_na'))}`,
          `${langText('Résultat', 'Result')}: ${foundCode ? langText('Code-barres rempli', 'Barcode filled') : langText('Aucun résultat', 'No result')}`,
        ];
        if (finalError) detailLines.push(`${langText('Erreur finale', 'Final error')}: ${finalError}`);
        pushProductStatusTerminal(
          langText('Données recherche code-barres', 'Barcode search data'),
          'data',
          langText('Code-barres', 'Barcodes'),
          detailLines
        );
        setButtonBusy(robotButton, false);
        refreshState();
      }
    };

    robotButton.addEventListener('click', () => {
      runRobotLookup(false, false);
    });

    const runAutoAssistIfEnabled = () => {
      const autoSettings = normalizeBarcodeAutofillUiSettings(barcodeAutofillUiSettings());
      if (autoSettings.instantAssist !== true) return;
      const hasBarcodeAlready = parseBarcodeCandidate(barcodeInput.value) !== '';
      refreshState();
      if (hasBarcodeAlready || robotButton.disabled) return;
      runRobotLookup(true);
    };

    assistToggleButton.addEventListener('click', () => {
      const current = normalizeBarcodeAutofillUiSettings(barcodeAutofillUiSettings());
      const next = saveBarcodeAutofillUiSettings({
        ...current,
        instantAssist: current.instantAssist !== true,
      });
      const enabled = next.instantAssist === true;
      refreshAssistToggleUi();
      refreshState();
      if (!enabled) {
        setBarcodeAutofillStatus(status, t('barcode_autofill_assist_off_title'), 'muted');
        return;
      }
      setBarcodeAutofillStatus(status, t('barcode_autofill_assist_on_title'), 'info');
      runAutoAssistIfEnabled();
    });

    refreshState();
    if (form.dataset.offAutoAssistInitDone !== '1') {
      form.dataset.offAutoAssistInitDone = '1';
      setTimeout(runAutoAssistIfEnabled, 120);
    }
    const modal = form.closest('.modal');
    if (modal && modal.dataset.offAutoAssistBound !== '1') {
      modal.dataset.offAutoAssistBound = '1';
      modal.addEventListener('shown.bs.modal', () => {
        setTimeout(runAutoAssistIfEnabled, 90);
      });
    }
  }

  function initBarcodeAutofillButtons(root = document) {
    const forms = root.querySelectorAll ? root.querySelectorAll('form#barcode-form') : [];
    if (!forms || forms.length === 0) return;
    forms.forEach((form) => initBarcodeAutofillButtonInForm(form));
  }

  function initBarcodeAutofillObserver() {
    if (S.barcodeAutofillObserver) return;
    if (!document.body || !window.MutationObserver) return;
    S.barcodeAutofillObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        const nodes = Array.from(mutation.addedNodes || []);
        for (const node of nodes) {
          if (!node || node.nodeType !== 1) continue;
          if (node.matches && node.matches('form#barcode-form')) {
            initBarcodeAutofillButtonInForm(node);
            continue;
          }
          if (node.querySelector) {
            initBarcodeAutofillButtons(node);
          }
        }
      }
    });
    S.barcodeAutofillObserver.observe(document.body, { childList: true, subtree: true });
  }

  function initProductOpenFoodFactsEnhancements() {
    patchUserfieldsFormSaveForProductForm();
    initProductFormTypeRules();
    initProductEnergyVisibilityGuard();
    initProductEnergyRobotButton();
    initProductBarcodesHeaderButtons();
    initBarcodeAutofillButtons(document);
    initBarcodeAutofillObserver();
    if (typeof S.productFormTypeRulesRefresh === 'function') {
      try { S.productFormTypeRulesRefresh(); } catch (_err) {}
    }
  }

  function init() {
    const safeRun = (label, fn) => {
      try {
        return fn();
      } catch (error) {
        console.error(`[custom_js] ${label} failed`, error);
        return null;
      }
    };

    safeRun('loadBarcodeLookupSettings', () => loadBarcodeLookupSettings());
    safeRun('loadBarcodeAutofillUiSettings', () => loadBarcodeAutofillUiSettings());
    safeRun('loadPhotoSearchSettings', () => loadPhotoSearchSettings());
    safeRun('loadPhotoSearchProgress', () => loadPhotoSearchProgress());
    safeRun('initProductStatusTerminal', () => initProductStatusTerminal());
    safeRun('initProductImageSearchButton', () => initProductImageSearchButton());
    safeRun('initProductOpenFoodFactsEnhancements', () => initProductOpenFoodFactsEnhancements());

    const table = document.getElementById('stock-overview-table');
    if (!table) return;

    safeRun('loadAiSettings', () => loadAiSettings());
    safeRun('loadBrandLogoSettings', () => loadBrandLogoSettings());
    safeRun('loadUiState', () => loadUiState());
    safeRun('loadAddonCompatibilityState', () => loadAddonCompatibilityState());
    safeRun('loadAddonUpdateState', () => loadAddonUpdateState());
    safeRun('initTabs', () => initTabs());
    safeRun('registerFacetFilter', () => registerFacetFilter());
    safeRun('initDashboard', () => initDashboard());
    safeRun('bindDraw', () => bindDraw());

    const search = document.getElementById('search');
    const gf = document.getElementById('product-group-filter');
    const sf = document.getElementById('status-filter');
    const clearBtn = document.getElementById('clear-filter-button');

    if (search) search.addEventListener('input', scheduleRender);
    if (gf) gf.addEventListener('change', scheduleRender);
    if (sf) sf.addEventListener('change', scheduleRender);
    if (clearBtn) {
      clearBtn.addEventListener('click', () => {
        clearStockFacetFilter(false);
        setTimeout(scheduleRender, 0);
      });
    }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>


